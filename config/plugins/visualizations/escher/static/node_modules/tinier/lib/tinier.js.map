{"version":3,"sources":["../src/tinier.js"],"names":["tail","head","fromPairs","get","isUndefined","isObject","isArray","isString","isNumber","isBoolean","isFunction","notNull","mapValues","reduceValues","zipArrays","zipObjects","filterValues","any","tagType","checkType","match","hasChildren","checkRenderResult","updateEl","addressWith","addressEqual","makeTree","checkState","diffWithModelMin","makeSignal","makeOneSignalAPI","makeChildSignalsAPI","reduceChildren","mergeSignals","objectOf","arrayOf","createComponent","patchMethods","makeCallMethod","makeCallReducer","makeStateCallers","run","addressToObj","objectForBindings","createElement","bind","createDOMElement","getStyles","updateDOMElement","render","ARRAY_OF","OBJECT_OF","COMPONENT","ARRAY","OBJECT","NODE","NULL","STRING","NUMBER","BOOLEAN","ANY","NO_ARGUMENT","TOP","CREATE","UPDATE","DESTROY","noop","constant","val","identity","last","array","length","slice","pairs","reduce","accum","key","object","property","hasOwnProperty","Array","v","obj","fn","newObj","init","arrays","lenLongest","Math","max","apply","filter","x","map","a","res","i","push","objects","len","allKeys","k","out","value","ar","l","Error","defer","setTimeout","type","fns","defaultFn","throwUnrecognizedType","node","Object","keys","checkRenderResultRecurse","userBindings","state","updateRecurse","s","u","recurse","n","address","component","diffVal","lastRenderedEl","el","stateCallers","opts","reducers","patchReducersWithState","callReducer","signals","patchSignals","callSignal","methods","callMethod","arg","displayName","join","willUnmount","bindings","shouldUpdate","willMount","willUpdate","verbose","console","log","model","didMount","didUpdate","dropNodes","tree","data","updateComponents","diff","renderResult","d","newAddress","b","r","nextRenderResult","children","a1","a2","treeGet","treeSet","rest","treeSetMutable","parent","mutable","set","modelNode","newState","objOf","arOf","o","computeDiffValue","lastState","isValidFn","triggeringAddress","stateValid","lastStateValid","same","componentTriggeredUpdate","diffWithModel","assign","_","longest","singleOrAll","minTreeAr","getMin","indices","nonNullIndices","minSignals","minUpdate","update","_onFns","on","call","args","isCollection","_callFns","onName","argObject","index","makeSignalsAPI","signalNames","name","runSignalSetup","signalsAPI","childSignalsAPI","signalSetup","childSignals","diffNode","signalNode","upChild","upAddress","newUpAddress","callbackObj","upCallbackObj","signal","hasCreated","destroyed","childSignalsAPINode","childAddress","newUpChild","defaultShouldUpdate","checkInputs","options","defaults","error","patchInitNoArg","patchReducersOneArg","reducer","reducersRaw","signalName","Event","method","stateTree","target","event","localState","makeCallSignal","topComponent","bindingTree","signalTree","triggeringComponent","newLocalState","localSignals","newSignals","minUpdateBindings","minUpdateEl","minUpdateState","newBindings","appEl","topBinding","initialState","setStateReducer","setState","getState","setStateNoRender","signalsCall","BINDING","ELEMENT","LISTENER_OBJECT","reverseObject","ATTRIBUTE_RENAME","ATTRIBUTE_RENAME_REV","ATTRIBUTE_APPLY","checked","indexOf","NAMESPACES","svg","xhtml","xlink","xml","xmlns","keyBy","arr","f","objectForBindingsArray","j","binding","acc","objectForBindingsObject","isTinierBinding","isTinierElement","isElement","nodeType","nodeName","isText","tagName","attributesIn","attributes","addressIn","explicitNamespace","prefix","newName","explicit","tinierEl","tag","ns","namespaceURI","document","createElementNS","cssText","reg","exec","toCamelCase","replace","m","toUpperCase","stripOn","toLowerCase","setAttributeCheckBool","namespace","valToSet","setAttribute","setAttributeNS","thenFn","parentNamespace","onFn","removeEventListener","id","sv","sk","style","setProperty","addEventListener","attributeNames","removeAttribute","tStyle","removeProperty","flattenElementsAr","removeExtraNodes","container","childNodes","removeChild","tinierElementsAr","tinierElements","first","childrenWithKeys","from","c","elementsByID","bindingsAr","movedEl","replaceChild","appendChild","elToUpdate","cloneNode","newEl","newEl2","String","textContent","createTextNode"],"mappings":"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","file":"tinier.js","sourcesContent":["/** @module tinier */\n\n// constants\nexport const ARRAY_OF    = '@TINIER_ARRAY_OF'\nexport const OBJECT_OF   = '@TINIER_OBJECT_OF'\nexport const COMPONENT   = '@TINIER_COMPONENT'\nexport const ARRAY       = '@TINIER_ARRAY'\nexport const OBJECT      = '@TINIER_OBJECT'\nexport const NODE        = '@TINIER_NODE'\nexport const NULL        = '@TINIER_NULL'\nexport const STRING      = '@TINIER_STRING'\nexport const NUMBER      = '@TINIER_NUMBER'\nexport const BOOLEAN     = '@TINIER_BOOLEAN'\nexport const ANY         = '@TINIER_ANY'\nexport const NO_ARGUMENT = '@TINIER_NO_ARGUMENT'\nexport const TOP         = '@TINIER_TOP'\nexport const CREATE      = '@TINIER_CREATE'\nexport const UPDATE      = '@TINIER_UPDATE'\nexport const DESTROY     = '@TINIER_DESTROY'\n\n// basic functions\nfunction noop () {}\n\nfunction constant (val) {\n  return () => val\n}\n\nfunction identity (val) {\n  return val\n}\n\nfunction last (array) {\n  return array[array.length - 1]\n}\n\nexport function tail (array) {\n  return [ array.slice(0, -1), last(array) ]\n}\n\nexport function head (array) {\n  return [ array[0], array.slice(1) ]\n}\n\nexport function fromPairs (pairs) {\n  return pairs.reduce((accum, [ key, val ]) => {\n    return { ...accum, [key]: val }\n  }, {})\n}\n\n/**\n * Get the property of the object or index of the array, or return the default\n * value.\n * @param {Object|Array} object - An object or array.\n * @param {String} property - An property of the object.\n * @return {*} The value of the property or, if not present, the default value.\n */\nexport function get (object, property) {\n  return (object &&\n          typeof object !== 'string' &&\n          object.hasOwnProperty(property)) ? object[property] : null\n}\n\nexport function isUndefined (object) {\n  return typeof object === 'undefined'\n}\n\n/**\n * Check if the value is an object with enumerable properties. Also returns true\n * for arrays.\n * @param {*} value - The value to test.\n * @return {Boolean}\n */\nexport function isObject (object) {\n  return object != null && (typeof object === 'object')\n}\n\n/**\n * Check if the object is an array\n * @param {*} object - The object to test.\n * @return {Boolean}\n */\nexport function isArray (object) {\n  return Array.isArray(object)\n}\n\nexport function isString (v) {\n  return typeof v === 'string'\n}\n\nexport function isNumber (v) {\n  return typeof v === 'number'\n}\n\nexport function isBoolean (v) {\n  return typeof v === 'boolean'\n}\n\n/**\n * Check if the object is a function.\n * @param {*} object - The object to test.\n * @return {Boolean}\n */\nexport function isFunction (object) {\n  return typeof(object) === 'function'\n}\n\nexport function notNull (val) {\n  return val !== null\n}\n\n/**\n * Iterate over the keys and values of an object. Uses Object.keys to find\n * iterable keys.\n * @param {Object} obj - The input object.\n * @param {Function} fn - A function that takes the arguments (value, key).\n * @return {Object} A transformed object with values returned by the function.\n */\nexport function mapValues (obj, fn) {\n  const newObj = {}\n  for (let key in obj) {\n    newObj[key] = fn(obj[key], key)\n  }\n  return newObj\n}\n\nexport function reduceValues (obj, fn, init) {\n  let accum = init\n  for (let key in obj) {\n    accum = fn(accum, obj[key], key)\n  }\n  return accum\n}\n\nexport function zipArrays (arrays) {\n  const lenLongest = Math.max.apply(null, arrays.filter(x => x !== null).map(a => a.length))\n  const res = []\n  for (let i = 0; i < lenLongest; i++) {\n    res.push(arrays.map(a => a !== null && i < a.length ? a[i] : null))\n  }\n  return res\n}\n\nexport function zipObjects (objects) {\n  const len = objects.length\n  // find all the keys\n  const allKeys = {}\n  for (let i = 0; i < len; i++) {\n    const object = objects[i]\n    if (object === null) {\n      continue\n    }\n    for (let k in object) {\n      allKeys[k] = true\n    }\n  }\n  // make new object\n  const res = {}\n  for (let key in allKeys) {\n    res[key] = Array(len)\n    for (let i = 0; i < len; i++) {\n      const object = objects[i]\n      res[key][i] = get(object, key)\n    }\n  }\n  return res\n}\n\nexport function filterValues (object, fn) {\n  const out = {}\n  for (let key in object) {\n    const value = object[key]\n    if (fn(value, key)) out[key] = value\n  }\n  return out\n}\n\n/**\n * Lazy any function.\n * @param {[Boolean]}\n * @return {Boolean}\n */\nexport function any (ar) {\n  for (let i = 0, l = ar.length; i < l; i++) {\n    const val = ar[i]\n    if (!isBoolean(val)) {\n      throw new Error('Not a boolean: ' + val)\n    }\n    if (val) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Defers calling fn until the current process finishes.\n */\nfunction defer (fn) {\n  setTimeout(fn, 1)\n}\n\n/**\n * Adds a tag to the object.\n */\nexport function tagType (type, obj) {\n  if (!isString(type)) {\n    throw new Error('First argument must be a string')\n  }\n  if (!isObject(obj)) {\n    throw new Error('Second argument must be an object')\n  }\n  obj.type = type\n  return obj\n}\n\nexport function checkType (type, obj) {\n  if (obj === null) {\n    return type === NULL\n  }\n  if (typeof type !== 'string') {\n    throw new Error('First argument must be a string')\n  }\n  if (isUndefined(obj)) {\n    throw new Error('Bad second argument')\n  }\n  return get(obj, 'type') === type\n}\n\n/**\n * Basic pattern matching.\n * @param {Object|null} object - An object generated with tagType, an object, an\n *                               array, or null.\n * @param {Object} fns - An object with types for keys and functions for values.\n *                       Also accepts keys tinier.OBJECT, tinier.ARRAY, and\n *                       tinier.NULL. To avoid conflict, tinier.OBJECT has the\n *                       lowest priority.\n * @param {Function} defaultFn - A function to run if the object type is not\n *                               found. Takes `object` as a single argument.\n * @return {*} Return value from the called function.\n */\nexport function match (object, fns, defaultFn = throwUnrecognizedType) {\n  for (let key in fns) {\n    if ((key === NULL   && object === null ) ||\n        (key === ARRAY  && isArray(object) ) ||\n        (isObject(object) && checkType(key, object))) {\n      return fns[key](object)\n    }\n  }\n  if (OBJECT in fns && isObject(object)) {\n    return fns[OBJECT](object)\n  }\n  return defaultFn(object)\n}\n\nfunction throwUnrecognizedType (node) {\n  throw new Error('Unrecognized type in pattern matching: ' + node)\n}\n\n// -------------------------------------------------------------------\n// Update components\n// -------------------------------------------------------------------\n\n/**\n * Determine whether the model has any child components.\n */\nexport function hasChildren (node) {\n  return match(\n    node,\n    {\n      [ARRAY_OF]: () => true,\n      [OBJECT_OF]: () => true,\n      [COMPONENT]: () => true,\n      [ARRAY]: node => any(node.map(hasChildren)),\n      [OBJECT]: node => any(Object.keys(node).map(k => hasChildren(node[k]))),\n    }\n  )\n}\n\nfunction checkRenderResultRecurse (userBindings, node, state) {\n  const updateRecurse = (s, k) => {\n    const u = k === null ? userBindings : get(userBindings, k)\n    if (userBindings !== null && u === null) {\n      throw new Error('Shape of the bindings object does not match the model.' +\n                      'Model: ' + node + '  Bindings object: ' + userBindings)\n    }\n  }\n  const recurse = (n, k) => {\n    checkRenderResultRecurse(get(userBindings, k), n, get(state, k))\n  }\n  match(\n    node,\n    {\n      [OBJECT_OF]: objOf => {\n        // check for extra attributes\n        if (userBindings !== null\n            && any(Object.keys(userBindings).map(k => !(k in state)))) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          mapValues(state, updateRecurse)\n        }\n      },\n      [ARRAY_OF]: arOf => {\n        // check array lengths\n        if (userBindings !== null && state.length !== userBindings.length) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          state.map(updateRecurse)\n        }\n      },\n      [COMPONENT]: component => updateRecurse(state, null),\n      [ARRAY]: ar => {\n        if (userBindings !== null && !isArray(userBindings)) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          ar.map(recurse)\n        }\n      },\n      [OBJECT]: obj => {\n        if (userBindings !== null && isArray(userBindings)) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          mapValues(obj, recurse)\n        }\n      }\n    }\n  )\n}\n\n/**\n * Check the result of render against the model and state.\n * @param {Object} node - A model node.\n * @param {*} state - A state node.\n * @param {Object} userBindings - The new bindings returned by render.\n * @return {Object} The userBindings object.\n */\nexport function checkRenderResult (userBindings, node, state) {\n  checkRenderResultRecurse(userBindings, node, state)\n  return userBindings\n}\n\n/**\n * Run lifecycle functions for the component.\n * @param {Object} address -\n * @param {Object} component -\n * @param {Object} state -\n * @param {Object} diffVal -\n * @param {Object|null} lastRenderedEl - The element rendered in previously, if\n *                                       there was one.\n * @param {Object|null} el - The element to render in provided by\n *                           component.render.\n * @param {Object} stateCallers -\n * @return {Object}\n */\nexport function updateEl (address, component, state, diffVal, lastRenderedEl, el,\n                          stateCallers, opts) {\n  // the object passed to lifecycle functions\n  const reducers = patchReducersWithState(address, component, stateCallers.callReducer)\n  const signals = patchSignals(address, component, stateCallers.callSignal)\n  const methods = patchMethods(address, component, stateCallers.callMethod,\n                               reducers, signals)\n  const arg = { state, methods, reducers, signals, el, lastRenderedEl }\n\n  // warn if the el is null\n  if (el === null && !(diffVal === DESTROY) && component.render !== noop) {\n    throw new Error('No binding provided for component ' + component.displayName\n                    + ' at [' + address.join(', ') + '].')\n  }\n\n  if (diffVal === DESTROY) {\n    // destroy\n    component.willUnmount(arg)\n    return { bindings: null, lastRenderedEl }\n  } else {\n    // create or update\n    const shouldUpdate = (diffVal === CREATE || diffVal === UPDATE ||\n                          el !== lastRenderedEl)\n\n    if      (diffVal === CREATE) component.willMount(arg)\n    else if (shouldUpdate)     component.willUpdate(arg)\n\n    if (opts.verbose && shouldUpdate) {\n      console.log('Rendering ' + component.displayName + ' at [' +\n                  address.join(', ') + '].')\n    }\n\n    // render\n    const bindings = shouldUpdate ?\n            checkRenderResult(component.render(arg), component.model, state) :\n            null\n    // check result\n    if (shouldUpdate && bindings === null && hasChildren(component.model)) {\n      throw new Error('The render function of component ' +\n                      component.displayName + ' did not return new bindings')\n    }\n\n    // These need to be asynchronous.\n    if (diffVal === CREATE) {\n      defer(() => component.didMount(arg))\n    } else if (shouldUpdate) {\n      defer(() => component.didUpdate(arg))\n    }\n\n    // If the component rendered, then change lastEl.\n    return { bindings, lastRenderedEl: shouldUpdate ? el : lastRenderedEl }\n  }\n}\n\n/**\n * For a tree, return everything down to the first set of NODES with data for\n * leaves.\n */\nfunction dropNodes (tree) {\n  return match(tree, {\n    [NODE]: node => node.data,\n    [OBJECT]: obj => mapValues(obj, dropNodes),\n    [ARRAY]: ar => ar.map(dropNodes),\n    [NULL]: () => null,\n  })\n}\n\n/**\n * Run create, update, and destroy for component.\n * @param {Array} address - The location of the component in the state.\n * @param {Object} node - A model or a node within a model.\n * @param {Object} diff - The diff object for this component.\n * @param {Object|null} bindings -\n * @param {Object|null} renderResult -\n * @param {Object} stateCallers -\n * @return {Object}\n */\nfunction updateComponents (address, node, state, diff, bindings, renderResult,\n                           stateCallers, opts) {\n  const updateRecurse = ([ d, s ], k) => {\n    // TODO in updateRecurse functions where k can be null, there must be a\n    // nicer way to organize things with fewer null checks\n    const component = k !== null ? node.component : node\n    const newAddress = k !== null ? addressWith(address, k) : address\n    const b = k !== null ? get(bindings, k) : bindings\n    const r = k !== null ? get(renderResult, k) : renderResult\n    // Update the component. If DESTROY, then there will not be a binding.\n    const res = updateEl(newAddress, component, s, d.data, get(b, 'data'), r,\n                         stateCallers, opts)\n    // Fall back on old bindings.\n    const nextRenderResult = res.bindings !== null ? res.bindings :\n            dropNodes(b.children)\n    const data = res.lastRenderedEl\n    // update children\n    const children = updateComponents(newAddress, component.model, s,\n                                      d.children, get(b, 'children'),\n                                      nextRenderResult, stateCallers, opts)\n    return tagType(NODE, { data, children })\n  }\n  const recurse = (n, k) => {\n    return updateComponents(addressWith(address, k), n, get(state, k), diff[k],\n                            get(bindings, k), get(renderResult, k),\n                            stateCallers, opts)\n  }\n  return match(\n    node,\n    {\n      [OBJECT_OF]: objOf => {\n        return mapValues(zipObjects([ diff, state ]), updateRecurse)\n      },\n      [ARRAY_OF]: arOf => {\n        return zipArrays([ diff, state ]).map(updateRecurse)\n      },\n      [COMPONENT]: component => updateRecurse([ diff, state ], null),\n      [ARRAY]: ar => ar.map(recurse),\n      [OBJECT]: obj => mapValues(obj, recurse),\n    })\n}\n\n// -------------------------------------------------------------------\n// State\n// -------------------------------------------------------------------\n\nexport function addressWith (address, key) {\n  if (key === null) {\n    return address\n  } else {\n    const newAddress = address.slice(0)\n    newAddress.push(key)\n    return newAddress\n  }\n}\n\nexport function addressEqual (a1, a2) {\n  if (a1 === null || a2 === null || a1.length !== a2.length) return false\n  return a1.reduce((accum, v, i) => accum && v === a2[i], true)\n}\n\n/**\n * Get the value in a tree.\n * @param {Array} address -\n * @param {Object} tree -\n * @return {*} - The value at the given address.\n */\nfunction treeGet (address, tree) {\n  return address.reduce((accum, val) => {\n    return checkType(NODE, accum) ? accum.children[val] : accum[val]\n  }, tree)\n}\n\n/**\n * Set the value in a tree; immutable.\n * @param {Array} address -\n * @param {Object} tree -\n * @param {*} value - The new value to set at address.\n * @return (*) The new tree.\n */\nfunction treeSet (address, tree, value) {\n  if (address.length === 0) {\n    return value\n  } else {\n    const [ k, rest ] = head(address)\n    return (typeof k === 'string' ?\n            { ...tree, [k]: treeSet(rest, treeGet([ k ], tree), value) } :\n            [ ...tree.slice(0, k), treeSet(rest, treeGet([ k ], tree), value),\n              ...tree.slice(k + 1) ])\n  }\n}\n\n/**\n * Set the value in a tree; mutable.\n * @param {Array} address -\n * @param {Object} tree -\n * @param {*} value - The new value to set at address.\n * @return (*) The tree.\n */\nfunction treeSetMutable (address, tree, value) {\n  if (address.length === 0) {\n    return value\n  } else {\n    const [ rest, last ] = tail(address)\n    const parent = treeGet(rest, tree)\n    if (checkType(NODE, parent)) {\n      parent.children[last] = value\n    } else {\n      parent[last] = value\n    }\n    return tree\n  }\n}\n\nexport function makeTree (init, mutable) {\n  let state = init\n  return {\n    get: (address) => {\n      return treeGet(address, state)\n    },\n    set: (address, value) => {\n      state = mutable ?\n        treeSetMutable(address, state, value) :\n        treeSet(address, state, value)\n    },\n  }\n}\n\n/**\n * Check that the new state is valid. If not, then throw an Error.\n * @param {Object} modelNode - A model or a node of a model.\n * @param {Object} newState - The new state corresponding to modelNode.\n */\nexport function checkState (modelNode, newState) {\n  if (newState === null) {\n    return\n  }\n  match(modelNode, {\n    [OBJECT_OF]: objOf => {\n      if (!isObject(newState) || isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model. ' +\n                        'Model: ' + objOf + '  State: ' + newState)\n      } else {\n        mapValues(newState, s => checkState(modelNode.component.model, s))\n      }\n    },\n    [ARRAY_OF]: arOf => {\n      if (!isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model.' +\n                        'Model: ' + arOf + '  State: ' + newState)\n      } else {\n        newState.map(s => checkState(modelNode.component.model, s))\n      }\n    },\n    [COMPONENT]: component => {\n      checkState(modelNode.model, newState)\n    },\n    [ARRAY]: ar => {\n      if (!isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model.' +\n                        'Model: ' + ar + '  State: ' + newState)\n      } else {\n        ar.map((a, i) => checkState(a, get(newState, i)))\n      }\n    },\n    [OBJECT]: obj => {\n      if (!isObject(newState) || isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model. ' +\n                        'Model: ' + obj + '  State: ' + newState)\n      } else {\n        mapValues(obj, (o, k) => checkState(o, get(newState, k)))\n      }\n    },\n  })\n}\n\nfunction computeDiffValue (state, lastState, key, isValidFn, shouldUpdate,\n                           address, triggeringAddress) {\n  const stateValid = isValidFn(state, key)\n  const lastStateValid = isValidFn(lastState, key)\n  if (stateValid && !lastStateValid) {\n    return CREATE\n  } else if (stateValid && lastStateValid) {\n    const same = (key === null ? state !== lastState :\n                  state[key] !== lastState[key])\n    const componentTriggeredUpdate = addressEqual(address, triggeringAddress)\n    if (same && shouldUpdate({ state, lastState, componentTriggeredUpdate })) {\n      return UPDATE\n    } else {\n      return null\n    }\n  } else if (!stateValid && lastStateValid) {\n    return DESTROY\n  } else {\n    return null\n  }\n}\n\n/**\n * Compute the full diff tree for the model node. Calls shouldUpdate.\n */\nfunction diffWithModel (modelNode, state, lastState, address,\n                        triggeringAddress) {\n  return match(\n    modelNode,\n    {\n      [OBJECT_OF]: objOf => {\n        const isValidFn = (obj, k) => {\n          return isObject(obj) && k in obj && obj[k] !== null\n        }\n        const l = Object.assign({}, state || {}, lastState || {})\n        return mapValues(l, function (_, k) {\n          const data = computeDiffValue(state, lastState, k, isValidFn,\n                                        objOf.component.shouldUpdate,\n                                        addressWith(address, k),\n                                        triggeringAddress)\n          const children = diffWithModel(objOf.component.model,\n                                         get(state, k),\n                                         get(lastState, k),\n                                         addressWith(address, k),\n                                         triggeringAddress)\n          return tagType(NODE, { data, children })\n        })\n      },\n      [ARRAY_OF]: arOf => {\n        const isValidFn = (obj, i) => {\n          return isArray(obj) && i < obj.length && obj[i] !== null\n        }\n        const longest = Math.max(isArray(state) ? state.length : 0,\n                                 isArray(lastState) ? lastState.length : 0)\n        const l = Array.apply(null, { length: longest })\n        return l.map(function (_, i) {\n          const data = computeDiffValue(state, lastState, i, isValidFn,\n                                        arOf.component.shouldUpdate,\n                                        addressWith(address, i), triggeringAddress)\n          const children = diffWithModel(arOf.component.model,\n                                         get(state, i),\n                                         get(lastState, i),\n                                         addressWith(address, i),\n                                         triggeringAddress)\n          return tagType(NODE, { data, children })\n        })\n      },\n      [COMPONENT]: component => {\n        const isValidFn = (obj, _) => obj !== null\n        const data = computeDiffValue(state, lastState, null, isValidFn,\n                                      component.shouldUpdate,\n                                      address, triggeringAddress)\n        const children = diffWithModel(component.model, state || null,\n                                       lastState || null, address,\n                                       triggeringAddress)\n        return tagType(NODE, { data, children })\n      },\n      [ARRAY]: ar => {\n        return ar.map((n, i) => {\n          return diffWithModel(n, get(state, i), get(lastState, i),\n                               addressWith(address, i), triggeringAddress)\n        })\n      },\n      [OBJECT]: obj => {\n        return mapValues(obj, (n, k) => {\n          return diffWithModel(n, get(state, k), get(lastState, k),\n                               addressWith(address, k), triggeringAddress)\n        })\n      },\n    })\n}\n\n/**\n * For an array of minSignals and minUpdate trees, return the minimal trees that\n * represent the whole array.\n */\nfunction singleOrAll (modelNode, address, minTreeAr) {\n  const getMin = indices => {\n    if (indices.length === 0) {\n      // If all elements in the array are null, return null.\n      return null\n    } else if (nonNullIndices.signals.length === 1) {\n      // If there is a single value, return that tree, with an updated address.\n      return {\n        minSignals: {\n          diff: minTreeAr.map(a => a.minSignals.diff),\n          address,\n          modelNode,\n        },\n        minUpdate: {\n          diff: minTreeAr.map(a => a.minUpdate.diff),\n          address,\n          modelNode,\n        },\n      }\n    } else {\n      // Otherwise, return full trees from this level.\n      return {\n        minSignals: {\n          diff: minTreeAr.map(a => a.minSignals.diff),\n          address,\n          modelNode,\n        },\n        minUpdate: {\n          diff: minTreeAr.map(a => a.minUpdate.diff),\n          address,\n          modelNode,\n        },\n      }\n    }\n  }\n  // Get the indices where the signal and update trees are not null.\n  const nonNullIndices = minTreeAr.reduce((accum, val, i) => {\n    return {\n      signals: val.minSignals !== null ? [ ...accum.signals, i ]: accum.signals,\n      update: val.minUpdate !== null ? [ ...accum.update, i ]: accum.update,\n    }\n  }, { signals: [], update: [] })\n  // For each set of indices, test the diffs with these tests to get a minimum\n  // tree.\n  const minSignals = getMin(nonNullIndices.signals)\n  const minUpdate = getMin(nonNullIndices.update)\n  return { minSignals, minUpdate }\n}\n\n/**\n * 1. Run shouldUpdate for every component in the tree.\n * 2. Return the information about the minimal tree to update with\n *    updateComponents (whenever shouldUpdate is true) as minUpdate.\n * 3. Return the information about the minimal tree to update with\n *    mergeSignals (whenever nodes are added or deleted) as minSignals.\n *\n * @param {Object} modelNode - A model or a node of a model.\n * @param {Object} state - The new state corresponding to modelNode.\n * @param {Object|null} lastState - The old state corresponding to modelNode.\n * @param {Array} address -\n * @param {Array} triggeringAddress -\n * @returns {Object} An object with the attributes minSignals and\n *                   minUpdate. Each represents a minimal tree necessary for the\n *                   appropriate update function and has the attributes diff,\n *                   modelNode, and address.\n */\nexport function diffWithModelMin (modelNode, state, lastState, address,\n                                  triggeringAddress) {\n  // 1. calculate whole diff tree\n  const diff = diffWithModel(modelNode, state, lastState, address,\n                             triggeringAddress)\n  // 2. trim the tree for the two needs\n  return {\n    minSignals: {\n      diff,\n      address,\n      modelNode,\n    },\n    minUpdate: {\n      diff,\n      address,\n      modelNode,\n    },\n  }\n}\n\n// -------------------------------------------------------------------\n// Signals\n// -------------------------------------------------------------------\n\n/**\n * Make a signal.\n * @return {Object} A signal with attributes `on` and `call`.\n */\nexport function makeSignal () {\n  const res = { _onFns: [] }\n  res.on = fn => {\n    if (!isFunction(fn)) {\n      throw new Error('First argument to \"on\" must be a function')\n    }\n    res._onFns = [ ...res._onFns, fn ]\n  }\n  res.call = (...args) => res._onFns.map(fn => fn(...args))\n  return res\n}\n\n/**\n * Create an object that with `on/onEach` and `call` attributes.\n * @param {Boolean} isCollection -\n * @return {Object}\n */\nexport function makeOneSignalAPI (isCollection) {\n  // make a `_callFn` function that will be replaced later and is the target of\n  // `call`\n  const res = { _callFns: [] }\n  // call will run all functions in `_callFns`\n  res.call = (...args) => {\n    if (args.length > 1 || !isObject(args[0])) {\n      throw new Error('Call only accepts a single object as argument.')\n    }\n    res._callFns.map(({ fn }) => fn(args[0]))\n  }\n  // store callbacks passed with `on` or `onEach`\n  res._onFns = []\n  const onName = isCollection ? 'onEach' : 'on'\n  res[onName] = fn => {\n    if (!isFunction(fn)) {\n      throw new Error('Argument to \"' + onName + '\" must be a function')\n    }\n    res._onFns.push(index => (...args) => {\n      if (args.length > 1 || !isObject(args[0])) {\n        throw new Error('On function only accepts a single object as argument.')\n      }\n      const argObject = ( typeof index === 'string' ? { k: index, ...args[0] } :\n                          (typeof index === 'number' ? { i: index, ...args[0] } :\n                           args[0]))\n      fn(argObject)\n    })\n  }\n  return res\n}\n\n/**\n * Implement the signals API.\n */\nfunction makeSignalsAPI (signalNames, isCollection) {\n  return fromPairs(signalNames.map(name => {\n    return [ name, makeOneSignalAPI(isCollection) ]\n  }))\n}\n\n/**\n * Implement the childSignals API.\n */\nexport function makeChildSignalsAPI (model) {\n  return match(\n    model,\n    {\n      [OBJECT_OF]: node => makeSignalsAPI(node.component.signalNames, true),\n      [ARRAY_OF]:  node => makeSignalsAPI(node.component.signalNames, true),\n      [COMPONENT]: node => makeSignalsAPI(node.signalNames, false),\n      [ARRAY]: ar => ar.map(makeChildSignalsAPI).filter(notNull),\n      [OBJECT]: obj => filterValues(mapValues(obj, makeChildSignalsAPI), notNull),\n    },\n    constant(null)\n  )\n}\n\n/**\n * Reduce the direct children of the tree.\n * @param {Object} node - A node in a tree.\n * @param {Function} fn - Function with arguments (accum, object).\n * @param {*} init - An initial value.\n * @param {Array} address - The local address.\n * @return {*}\n */\nexport function reduceChildren (node, fn, init, address = []) {\n  return match(node, {\n    [NODE]: node => fn(init, node.data, address),\n    [ARRAY]: ar => {\n      return ar.reduce((accum, n, k) => {\n        return reduceChildren(n, fn, accum, addressWith(address, k))\n      }, init)\n    },\n    [OBJECT]: obj => {\n      return reduceValues(obj, (accum, n, k) => {\n        return reduceChildren(n, fn, accum, addressWith(address, k))\n      }, init)\n    },\n  }, constant(init))\n}\n\n/**\n * Run signalSetup with the component.\n * @param {Object} component -\n * @param {Array} address -\n * @param {Object} stateCallers -\n * @return {Object} Object with keys signalsAPI and childSignalsAPI.\n */\nfunction runSignalSetup (component, address, stateCallers) {\n  const signalsAPI = makeSignalsAPI(component.signalNames, false)\n  const childSignalsAPI = makeChildSignalsAPI(component.model)\n  const reducers = patchReducersWithState(address, component, stateCallers.callReducer)\n  const signals = patchSignals(address, component, stateCallers.callSignal)\n  const methods = patchMethods(address, component, stateCallers.callMethod,\n                               reducers, signals)\n  // cannot call signalSetup any earlier because it needs a reference to\n  // `methods`, which must know the address\n  component.signalSetup({\n    methods,\n    reducers,\n    signals: signalsAPI,\n    childSignals: childSignalsAPI,\n  })\n  return { signalsAPI, childSignalsAPI }\n}\n\n/**\n * Merge a signals object with signal callbacks from signalSetup.\n * @param {Object} node - A model node.\n * @param {Array} address - The address.\n * @param {Object} diffNode - A node in the diff tree.\n * @param {Object|null} signalNode - A node in the existing signals tree.\n * @param {Object} stateCallers - The object with 3 functions to modify global\n *                                state.\n * @param {Object|null} upChild - The childSignalsAPI object for the parent\n *                                Component.\n * @param {Array|null} upAddress - A local address specifying the location\n *                                 relative to the parent Component.\n * @return {Object} The new signals tree.\n */\nexport function mergeSignals (node, address, diffNode, signalNode, stateCallers,\n                              upChild = null, upAddress = null) {\n  const updateRecurse = ([ d, s ], k) => {\n    const component = k !== null ? node.component : node\n    const newAddress = k !== null ? addressWith(address, k) : address\n    const diffVal = d.data\n    if (diffVal === CREATE) {\n      // For create, apply the callbacks\n      const { signalsAPI, childSignalsAPI } = runSignalSetup(component,\n                                                             newAddress,\n                                                             stateCallers)\n      const newUpAddress = upAddress === null ? null : addressWith(upAddress, k)\n      const signals = mapValues(\n        zipObjects([ signalsAPI, upChild ]),\n        ([ callbackObj, upCallbackObj ], key) => {\n          const signal = makeSignal()\n\n          // For each callback, add each onFn to the signal,\n          // and set the callFn to the signal dispatch. Only\n          // on, not onEach, so execute the fn with no\n          // argument.\n          callbackObj._onFns.map(fn => signal.on(fn()))\n          callbackObj._callFns = [ { fn: signal.call, address: null } ]\n\n          // For the childSignalCallbacks from the parent\n          if (upCallbackObj !== null) {\n            upCallbackObj._onFns.map(fn => signal.on(fn(k)))\n            upCallbackObj._callFns = [\n              ...upCallbackObj._callFns,\n              { fn: signal.call, address: newUpAddress }\n            ]\n          }\n\n          return signal\n        }\n      )\n      const data = { signals, signalsAPI, childSignalsAPI }\n\n      // loop through the children of signals and node\n      const children = mergeSignals(component.model, newAddress, d.children,\n                                    get(s, 'children'), stateCallers,\n                                    childSignalsAPI, [])\n\n      return tagType(NODE, { data, children })\n    } else if (diffVal === DESTROY) {\n      // In the case of destroy, this leaf in the signals object will be null.\n      return null\n    } else {\n      // update\n      const { hasCreated, destroyed } = reduceChildren(\n        d.children, (accum, diffVal, address) => {\n          const hasCreated = accum.hasCreated || diffVal === CREATE\n          const destroyed = (diffVal === DESTROY ?\n                             [ ...accum.destroyed, address ] :\n                             accum.destroyed)\n          return { hasCreated, destroyed }\n        }, { hasCreated: false, destroyed: [] }\n      )\n\n      // if there are deleted children, delete references to them\n      destroyed.map(childAddress => {\n        // get the right child within childSignalsAPI\n        const childSignalsAPINode = childAddress.reduce((accum, k, i) => {\n          if (k in accum) {\n            return accum[k]\n          } else if (i === childAddress.length - 1) {\n            return accum\n          } else {\n            throw new Error('Bad address ' + childAddress + ' for object ' +\n                            s.data.childSignalsAPI)\n          }\n        }, s.data.childSignalsAPI)\n        mapValues(childSignalsAPINode, obj => {\n          // remove the matching callFns\n          obj._callFns = obj._callFns.filter(({ address }) => {\n            return !addressEqual(address, childAddress)\n          })\n        })\n      })\n\n      const newUpChild = hasCreated ? s.data.childSignalsAPI : null\n      const newUpAddress = hasCreated ? [] : null\n      const children = mergeSignals(component.model, newAddress, d.children,\n                                    get(s, 'children'), stateCallers,\n                                    newUpChild, newUpAddress)\n      return tagType(NODE, { data: get(s, 'data'), children })\n    }\n  }\n\n  const recurse = ([ n, d, s, u ], k) => {\n    const newAddress = addressWith(address, k)\n    const newUpAddress = upAddress === null ? null : addressWith(upAddress, k)\n    return mergeSignals(n, newAddress, d, s, stateCallers, u, newUpAddress)\n  }\n\n  return match(node, {\n    [OBJECT_OF]: objOf => {\n      return filterValues(mapValues(zipObjects([ diffNode, signalNode ]), updateRecurse), notNull)\n    },\n    [ARRAY_OF]: arOf => {\n      return zipArrays([ diffNode, signalNode ]).map(updateRecurse).filter(notNull)\n    },\n    [COMPONENT]: component => updateRecurse([ diffNode, signalNode ], null),\n    [ARRAY]: ar => zipArrays([ ar, diffNode, signalNode, upChild ]).map(recurse),\n    [OBJECT]: obj => mapValues(zipObjects([ obj, diffNode, signalNode, upChild ]), recurse),\n  }, constant(null))\n}\n\n// -------------------------------------------------------------------\n// Component & run functions\n// -------------------------------------------------------------------\n\n/**\n * Create an object representing many instances of this component, for use in a\n * tinier model.\n * @param {Object} component - Tinier component.\n * @return {Object}\n */\nexport function objectOf (component) {\n  return tagType(OBJECT_OF, { component })\n}\n\n/**\n * Create an array representing many instances of this component, for use in a\n * tinier model.\n * @param {Object} component - Tinier component.\n * @return {Object}\n */\nexport function arrayOf (component) {\n  return tagType(ARRAY_OF, { component })\n}\n\nfunction defaultShouldUpdate ({ state, lastState }) {\n  return state !== lastState\n}\n\nfunction checkInputs (options, defaults) {\n  mapValues(options, (_, k) => {\n    if (!(k in defaults)) {\n      console.error('Unexpected argument ' + k)\n    }\n  })\n}\n\nfunction patchInitNoArg (init) {\n  return (...args) => {\n    if (args.length === 0) {\n      return init({})\n    } else if (args.length > 1 || !isObject(args[0])) {\n      throw new Error('Reducers can only take 1 or 0 arguments, and the ' +\n                      'argument should be an object.')\n    } else {\n      return init(args[0])\n    }\n  }\n}\n\nfunction patchReducersOneArg (reducers) {\n  return mapValues(reducers, (reducer, name) => {\n    return (...args) => {\n      if (args.length !== 1 || !isObject(args[0])) {\n        throw new Error('Reducers can only take 1 arguments, and the ' +\n                        'argument should be an object.')\n      } else if (!('state' in args[0])) {\n        throw new Error('The argument to the reducer must have a \"state\" ' +\n                        'attribute.')\n      } else {\n        return reducer(args[0])\n      }\n    }\n  })\n}\n\n/**\n * Create a tinier component.\n * @param {Object} componentArgs - Functions defining the Tinier component.\n * @param {str} componentArgs.displayName - A name for the component.\n * @param {[str]} componentArgs.signals - An array of signal names.\n * @param {Object} componentArgs.model - The model object.\n * @param {Function} componentArgs.init - A function to initialize the state.\n * @param {Object} componentArgs.reducers -\n * @param {Object} componentArgs.methods -\n * @param {Function} componentArgs.willMount -\n * @param {Function} componentArgs.didMount -\n * @param {Function} componentArgs.shouldUpdate - Return true if the component\n *                                                should update, false if it\n *                                                should not, or null to use to\n *                                                default behavior (update when\n *                                                state changes).\n * @param {Function} componentArgs.willUpdate -\n * @param {Function} componentArgs.didUpdate -\n * @param {Function} componentArgs.willUnmount -\n * @param {Function} componentArgs.render -\n * @returns {Object} A tinier component.\n */\nexport function createComponent (options = {}) {\n  // default attributes\n  const defaults = {\n    displayName:  '',\n    signalNames:  [],\n    signalSetup:  noop,\n    model:        {},\n    init:         constant({}),\n    reducers:     {},\n    methods:      {},\n    willMount:    noop,\n    didMount:     noop,\n    shouldUpdate: defaultShouldUpdate,\n    willUpdate:   noop,\n    didUpdate:    noop,\n    willUnmount:  noop,\n    render:       noop,\n  }\n  // check inputs\n  checkInputs(options, defaults)\n\n  if ('init' in options) {\n    options.init = patchInitNoArg(options.init)\n  }\n\n  if ('reducers' in options) {\n    options.reducersRaw = options.reducers\n    options.reducers = patchReducersOneArg(options.reducers)\n  }\n\n  // check model\n  if (options.model && checkType(COMPONENT, options.model)) {\n    throw new Error('The model cannot be another Component. The top level of ' +\n                    'the model should be an array or an object literal')\n  }\n  // set defaults & tag\n  return tagType(COMPONENT, { ...defaults, ...options })\n}\n\nfunction patchReducersWithState (address, component, callReducer) {\n  return mapValues(component.reducersRaw, (reducer, name) => {\n    return function (...args) {\n      if (args.length === 0) {\n        callReducer(address, component, reducer, {}, name)\n      } else if (args.length > 1 || !isObject(args[0])) {\n        throw new Error('Reducers can only take 1 or 0 arguments, and the ' +\n                        'argument should be an object.')\n      } else {\n        callReducer(address, component, reducer, args[0], name)\n      }\n    }\n  })\n}\n\nfunction patchSignals (address, component, callSignal) {\n  return fromPairs(component.signalNames.map(signalName => {\n    return [\n      signalName,\n      { call: arg => callSignal(address, signalName, arg) }\n    ]\n  }))\n}\n\n/**\n * Return an object of functions that call the methods with component-specific\n * arguments.\n */\nexport function patchMethods (address, component, callMethod, reducers, signals) {\n  const methods = mapValues(component.methods, method => {\n    return function (arg) {\n      if (typeof Event !== 'undefined' && arg instanceof Event) {\n        callMethod(address, method, signals, methods, reducers, this, arg, {})\n      } else {\n        callMethod(address, method, signals, methods, reducers, null, null, arg)\n      }\n    }\n  })\n  return methods\n}\n\nexport function makeCallMethod (stateTree, opts) {\n  /**\n   * Call a method on the local stateTree\n   * @param address\n   * @param method\n   * @param signals\n   * @param methods - Patched method functions.\n   * @param reducers - Patched reducer functions.\n   * @param target - The value of this in the called function.\n   * @param event - The event at the time of the function call.\n   * @param arg - An argument object.\n   */\n  return (address, method, signals, methods, reducers, target, event, arg) => {\n    // check for uninitialized stateTree\n    if (stateTree.get([]) === null) {\n      throw new Error('Cannot call method before the app is initialized (e.g. ' +\n                      'in signalSetup).')\n    }\n    // get the local state\n    const localState = stateTree.get(address)\n    // run the method\n    method({ state: localState, signals, methods, reducers, target, event,\n             ...arg })\n  }\n}\n\n/**\n * Return a callSignal function.\n */\nfunction makeCallSignal (signals, opts) {\n  return (address, signalName, arg) => {\n    if (opts.verbose) {\n      console.log('Called signal ' + signalName + ' at [' + address.join(', ') +\n                  '].')\n    }\n    signals.get(address).data.signals[signalName].call(arg)\n  }\n}\n\n/**\n * Return a new callReducer function.\n * @param {Object} topComponent - The top-level component.\n * @param {Object} stateTree - The global stateTree.\n * @param {Object} bindingTree - The global bindingTree.\n * @param {Object} signalTree - The global signalTree.\n * @param {Object} stateCallers - An object with functions callMethod,\n *                                callSignal, and callReducer.\n * @param {Object} opts - Options from `run`.\n * @returns {Function} - Call a reducer on the local state\n *   @param {Array} address - A location, as an array of keys (strings and\n *                            integers).\n *   @param {Object} triggeringComponent -\n *   @param {Function} reducer - A reducer.\n *   @param {Object} arg - An argument object.\n *   @param {String} name - The name of the reducer (for logging).\n */\nexport function makeCallReducer (topComponent, stateTree, bindingTree,\n                                 signalTree, stateCallers, opts) {\n  return (address, triggeringComponent, reducer, arg, name) => {\n    if (!isFunction(reducer)) {\n      throw new Error('Reducer ' + name + ' is not a function')\n    }\n    // Run the reducer, and optionally log the result.\n    const localState = stateTree.get(address)\n    const newLocalState = reducer({ ...arg, state: localState })\n    if (opts.verbose) {\n      console.log('Called reducer ' + name + ' for ' +\n                  triggeringComponent.displayName + ' at [' + address.join(', ')\n                  + '].')\n      console.log(localState)\n      console.log(newLocalState)\n    }\n\n    // Check that the new state is valid. If not, throw an Error, and the new\n    // state will be thrown out.\n    checkState(triggeringComponent.model, newLocalState)\n\n    // Set the state with immutable objects and arrays. A reference to oldState\n    // will used for diffing.\n    const lastState = stateTree.get([])\n    stateTree.set(address, newLocalState)\n\n    // Run diffWithModelMin, which will do a few things:\n    // 1. Run shouldUpdate for every component in the tree.\n    // 2. Return the information about the minimal tree to update with\n    //    updateComponents (whenever shouldUpdate is true) as minUpdate.\n    // 3. Return the information about the minimal tree to update with\n    //    mergeSignals (whenever nodes are added or deleted) as minSignals.\n    // The output objects have the attributes diff, modelNode, and address.\n    // TODO might be best to go back to returning just one full diff here\n    const { minSignals, minUpdate } = diffWithModelMin(topComponent,\n                                                       stateTree.get([]),\n                                                       lastState, [], address)\n\n    // Update the signals.\n    const localSignals = signalTree.get(minSignals.address)\n    const newSignals = mergeSignals(minSignals.modelNode, minSignals.address,\n                                    minSignals.diff, localSignals, stateCallers)\n    signalTree.set(minSignals.address, newSignals)\n\n    // Update the components.\n    const minUpdateBindings = bindingTree.get(minUpdate.address)\n    const minUpdateEl = minUpdateBindings.data\n    const minUpdateState = stateTree.get(minUpdate.address)\n    const newBindings = updateComponents(minUpdate.address, minUpdate.modelNode,\n                                         minUpdateState, minUpdate.diff,\n                                         minUpdateBindings, minUpdateEl,\n                                         stateCallers, opts)\n    bindingTree.set(minUpdate.address, newBindings)\n  }\n}\n\n/**\n * Return an object with functions callMethod, callSignal, and callReducer.\n * @param {Object} component - The top-level component.\n * @param {Object} stateTree - The global stateTree.\n * @param {Object} bindingTree - The global bindings.\n * @param {Object} signalTree - The global signalTree.\n * @return {Object} An object with functions callMethod, callSignal, and\n *                  callReducer.\n */\nexport function makeStateCallers (component, stateTree, bindingTree,\n                                  signalTree, opts) {\n  const stateCallers = {}\n  stateCallers.callMethod = makeCallMethod(stateTree, opts)\n  stateCallers.callSignal = makeCallSignal(signalTree, opts)\n  stateCallers.callReducer = makeCallReducer(component, stateTree, bindingTree,\n                                             signalTree, stateCallers, opts)\n  return stateCallers\n}\n\n/**\n * Run a tinier component.\n * @param {Object} component - A tinier component.\n * @param {*} appEl - An element to pass to the component's create, update, and\n *                    destroy methods.\n * @param {Object|null} initialState - The initial state. If null, then init()\n *                                     will be called to initialize the state.\n * @return {Object} The API functions, incuding getState, signals, and methods.\n */\nexport function run (component, appEl, opts = {}) {\n  // Create variables that will store the state for the whole lifetime of the\n  // application. Similar to the redux model.\n  let stateTree = makeTree(null, false)\n  const topBinding = tagType(NODE, { data: appEl, children: null })\n  let bindingTree = makeTree(topBinding, true)\n  let signalTree = makeTree(null, true)\n\n  // functions that access state, signals, and bindings\n  const stateCallers = makeStateCallers(component, stateTree, bindingTree,\n                                        signalTree, opts)\n\n  // make sure initial state is valid\n  // TODO LEFT OFF ... does this work?\n  // Q: Does the state for a child component need to be defined? Are we checking\n  // all the way down the line?\n  const initialState = ('initialState' in opts ? opts.initialState :\n                        component.init())\n\n  // first draw\n  const setStateReducer = ({ newState }) => newState\n  const setState = newState => {\n    return stateCallers.callReducer([], component, setStateReducer,\n                                    { newState }, 'setState')\n  }\n  setState(initialState)\n\n  // return API\n  const getState = () => stateTree.get([])\n  // TODO check state\n  const setStateNoRender = newState => stateTree.set([], newState)\n  const reducers = patchReducersWithState([], component,\n                                          stateCallers.callReducer)\n  const signalsCall = patchSignals([], component, stateCallers.callSignal)\n  const methods = patchMethods([], component, stateCallers.callMethod, reducers,\n                               signalsCall)\n  // if state is null, then data will be null\n  const signals = get(signalTree.get([]).data, 'signals')\n\n  return { setState, setStateNoRender, getState, reducers, methods, signals }\n}\n\n// -------------------------------------------------------------------\n// DOM\n// -------------------------------------------------------------------\n\n// constants\nexport const BINDING = '@TINIER_BINDING'\nexport const ELEMENT = '@TINIER_ELEMENT'\nconst LISTENER_OBJECT = '@TINIER_LISTENERS'\n\nfunction reverseObject (obj) {\n  const newObj = {}\n  for (let k in obj) {\n    newObj[obj[k]] = k\n  }\n  return newObj\n}\n\n// some attribute renaming as seen in React\nconst ATTRIBUTE_RENAME = {}\nconst ATTRIBUTE_RENAME_REV = reverseObject(ATTRIBUTE_RENAME)\nconst ATTRIBUTE_APPLY = {\n  checked: (el, name, val = false) => {\n    if (name !== 'input') {\n      throw new Error('\"checked\" attribute is only supported on input elements.')\n    }\n    el.checked = val\n  },\n  value: (el, name, val = false) => {\n    if ([ 'input', 'textarea' ].indexOf(name) === -1) {\n      throw new Error('\"value\" attribute is only supported on input and ' +\n                      'textarea elements.')\n    }\n    el.value = val\n  },\n}\n\n// namespace management inspired by of D3.js, Mike Bostock, BSD license\nconst NAMESPACES = {\n  svg: 'http://www.w3.org/2000/svg',\n  xhtml: 'http://www.w3.org/1999/xhtml',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n}\n\n/**\n * Turn an array of objects into a new object of objects where the keys are\n * given by the value of `key` in each child object.\n * @param {[Object]} arr - The array of objects.\n * @param {String} key - The key to look for.\n */\nfunction keyBy (arr, key) {\n  var obj = {}\n  arr.map(x => obj[x[key]] = x)\n  return obj\n}\n\n/**\n *\n */\nexport function addressToObj (address, val) {\n  // If address is []\n  if (isUndefined(address[0])) {\n    return val\n  }\n  const f = address[0]\n  if (isString(f)) {\n    return { [f]: addressToObj(address.slice(1), val) }\n  } else {\n    const ar = Array(f + 1)\n    ar[f] = addressToObj(address.slice(1), val)\n    return ar\n  }\n}\n\nfunction objectForBindingsArray (bindings) {\n  // Check arrays and find longest internal array.\n  let longest = 0\n  for (let j = 0, l = bindings.length; j < l; j++) {\n    const binding = bindings[j]\n    if (!isArray(binding)) {\n      throw Error('Incompatible bindings: mix of types')\n    }\n    const len = binding.length\n    if (len > longest) {\n      longest = len\n    }\n  }\n  const acc = []\n  for (let i = 0; i < longest; i++) {\n    for (let j = 0, l = bindings.length; j < l; j++) {\n      const binding = bindings[j]\n      if (binding[i] != null) { // not null or undefined\n        if (acc[i] != null) { // not null or undefined\n          acc[i] = objectForBindings([ binding[i], acc[i] ])\n        } else {\n          acc[i] = binding[i]\n        }\n      }\n    }\n  }\n  return acc\n}\n\nfunction objectForBindingsObject (bindings) {\n  return bindings.reduce((acc, binding) => {\n    if (isArray(binding))\n      throw Error('Incompatible bindings: mix of types')\n    for (let k in binding) {\n      if (binding[k]) {\n        if (acc[k]) {\n          acc[k] = objectForBindings([ binding[k], acc[k] ])\n        } else {\n          acc[k] = binding[k]\n        }\n      }\n    }\n    return acc\n  }, {})\n}\n\nexport function objectForBindings (bindings) {\n  return isArray(bindings[0]) ?\n    objectForBindingsArray(bindings) :\n    objectForBindingsObject(bindings)\n}\n\n// Make sure default is null so undefined type constant do not match\nconst isTinierBinding = obj => checkType(BINDING, obj)\nconst isTinierElement = obj => checkType(ELEMENT, obj)\n\n/**\n * Returns true if it is a DOM element.\n * http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n */\nfunction isElement (o) {\n  return (o && typeof o === 'object' && o !== null &&\n          o.nodeType === 1 && typeof o.nodeName === 'string')\n}\n\n/**\n * Returns true if it is a DOM text element.\n */\nfunction isText (o) {\n  return (o && typeof o === 'object' && o !== null &&\n          o.nodeType === 3 && typeof o.nodeName === 'string')\n}\n\n/**\n * Create a new TinierDOM element.\n * @param {String} tagName - The name for the element.\n * @param {Object|null} attributesIn - The attributes. Note that JSX will pass\n *                                     null in when there are no attributes. In\n *                                     the resulting object, this will be an\n *                                     empty object {}.\n * @param {Object[]|Object|String} ...children - A single binding or a mix of\n *                                               elements and strings.\n * @return {Object} A TinierDOM element.\n */\nexport function createElement (tagName, attributesIn, ...children) {\n  const attributes = attributesIn == null ? {} : attributesIn\n  return tagType(ELEMENT, { tagName, attributes, children })\n}\n\n/**\n * Create a new TinierDOM binding.\n * @param {Array|String|Number} addressIn - An address array, or single key or\n *                                          index.\n * @return {Object} A TinierDOM binding.\n */\nexport function bind (addressIn) {\n  const address = isArray(addressIn) ? addressIn : [ addressIn ]\n  return tagType(BINDING, { address })\n}\n\nfunction explicitNamespace (name) {\n  const i = name.indexOf(':')\n  if (i !== -1) {\n    const prefix = name.slice(0, i)\n    if (prefix in NAMESPACES) {\n      // for xmlns, treat the whole name (e.g. xmlns:xlink) as the name\n      const newName = prefix === 'xmlns' ? name : name.slice(i + 1)\n      return { name: newName, explicit: NAMESPACES[prefix] }\n    } else {\n      return { name, explicit: null }\n    }\n  } else {\n    return { name, explicit: null }\n  }\n}\n\n/**\n * Create a DOM element, inheriting namespace or choosing one based on tag.\n * @param {Object} tinierEl - A TinierDOM element.\n * @param {Object} parent - The parent el.\n * @return {Object} The DOM element.\n */\nexport function createDOMElement (tinierEl, parent) {\n  const tag = tinierEl.tagName\n  const { name, explicit } = explicitNamespace(tag)\n  const ns = (explicit !== null ? explicit :\n              (tag in NAMESPACES ? NAMESPACES[tag] : parent.namespaceURI))\n  const el = (ns === NAMESPACES.xhtml ?\n              document.createElement(name) :\n              document.createElementNS(ns, name))\n  return updateDOMElement(el, tinierEl)\n}\n\nexport function getStyles (cssText) {\n  const reg = /([^:; ]+):/g\n  const res = []\n  let ar\n  while ((ar = reg.exec(cssText)) !== null) {\n    res.push(ar[1])\n  }\n  return res\n}\n\nfunction toCamelCase (name) {\n  return name\n  // Uppercase the first character in each group immediately following a dash\n    .replace(/-(.)/g, m => m.toUpperCase())\n  // Remove dashes\n    .replace(/-/g, '')\n}\n\nfunction stripOn (name) {\n  return name.slice(2).toLowerCase()\n}\n\nfunction setAttributeCheckBool (namespace, el, name, val) {\n  // set boolean appropriately\n  const valToSet = val === true ? name : val\n  if (namespace === NAMESPACES.xhtml) {\n    el.setAttribute(name, valToSet)\n  } else {\n    el.setAttributeNS(namespace, name, valToSet)\n  }\n}\n\n/**\n * Update the DOM element to match a TinierDOM element.\n * @param {Element} el - An existing DOM element.\n * @param {Object} tinierEl - A TinierDOM element.\n */\nexport function updateDOMElement (el, tinierEl) {\n  let thenFn = null\n  const parentNamespace = el.namespaceURI\n\n  // remove event listeners first, because they cannot simply be replaced\n  if (el.hasOwnProperty(LISTENER_OBJECT)) {\n    mapValues(el[LISTENER_OBJECT], (onFn, name) => {\n      el.removeEventListener(name, onFn)\n    })\n    delete el[LISTENER_OBJECT]\n  }\n\n  // Update the attributes.\n  // TODO is it faster to check first, or set first?\n  mapValues(tinierEl.attributes, (v, k) => {\n    if (k === 'id') {\n      // ID is set directly\n      el.id = v\n    } else if (k === 'style' && !isString(v)) {\n      // For a style object. For a style string, use setAttribute below.\n      mapValues(v, (sv, sk) => {\n        el.style.setProperty(sk, sv)\n      })\n    } else if (k.indexOf('on') === 0) {\n      // Special handling for listeners\n      if (!el.hasOwnProperty(LISTENER_OBJECT)) {\n        el[LISTENER_OBJECT] = {}\n      }\n      // allow null\n      if (v !== null) {\n        const name = stripOn(k)\n        if (!isFunction(v) && v !== null) {\n          throw new Error(v + ' is not a function.')\n        }\n        el[LISTENER_OBJECT][name] = v\n        el.addEventListener(name, v)\n      }\n    } else if (k in ATTRIBUTE_RENAME) {\n      // By default, set the attribute.\n      const { name, explicit } = explicitNamespace(k)\n      setAttributeCheckBool(explicit !== null ? explicit : parentNamespace,\n                            el, ATTRIBUTE_RENAME[explicit], v)\n    } else if (k in ATTRIBUTE_APPLY) {\n      ATTRIBUTE_APPLY[k](el, tinierEl.tagName, v)\n\n    } else if (k === 'then') {\n      if (v !== null) {\n        if (!isFunction(v)) {\n          throw new Error(v + ' is not a function or null.')\n        }\n        thenFn = v\n      }\n    } else {\n      // By default, set the attribute.\n      const { name, explicit } = explicitNamespace(k)\n      setAttributeCheckBool(explicit !== null ? explicit : parentNamespace,\n                            el, name, v)\n    }\n  })\n  // Delete attributes if not provided. First, loop through this attributes\n  // object to get a nice array.\n  let attributeNames = []\n  for (let i = 0, l = el.attributes.length; i < l; i++) {\n    attributeNames.push(el.attributes[i].name)\n  }\n  attributeNames\n    .filter(k => !(k in tinierEl.attributes) || tinierEl.attributes[k] === false)\n    .map(k => {\n      if (k in ATTRIBUTE_RENAME_REV) {\n        el.removeAttribute(ATTRIBUTE_RENAME_REV[k])\n      } else if (k in ATTRIBUTE_APPLY) {\n        ATTRIBUTE_APPLY[k](el, tinierEl.tagName)\n      } else {\n        el.removeAttribute(k)\n      }\n    })\n  // Delete styles if not provided.\n  const tStyle = tinierEl.attributes.style\n  if (tStyle && !isString(tStyle)) {\n    getStyles(el.style.cssText)\n      .filter(a => !(a in tStyle || toCamelCase(a) in tStyle))\n      .map(a => el.style.removeProperty(a))\n  }\n\n  // call the callback\n  if (thenFn) {\n    defer(() => thenFn(el))\n  }\n\n  return el\n}\n\n/**\n* flatten the elements array\n*/\nfunction flattenElementsAr (ar) {\n  return ar.reduce((acc, el) => {\n    return isArray(el) ? [ ...acc, ...el ] : [ ...acc, el ]\n  }, []).filter(notNull) // null means ignore\n}\n\nfunction removeExtraNodes (container, length) {\n  for (let i = container.childNodes.length - 1; i >= length; i--) {\n    container.removeChild(container.childNodes[i])\n  }\n}\n\n/**\n * Render the given element tree into the container.\n * @param {Element} container - A DOM element that will be the container for\n *                              the renedered element tree.\n * @param {...[Object|String]|Object|String} tinierElementsAr -\n *   Any number of TinierDOM elements or strings that will be rendered.\n * @return {Object} A nested data structure of bindings for use in Tinier.\n */\nexport function render (container, ...tinierElementsAr) {\n  // check arguments\n  if (!isElement(container)) {\n    throw new Error('First argument must be a DOM Element.')\n  }\n\n  const tinierElements = flattenElementsAr(tinierElementsAr)\n\n  const first = get(tinierElements, 0)\n  if (isTinierBinding(first)) {\n    if (tinierElements.length !== 1) {\n      throw new Error('A binding cannot have siblings in TinierDOM. ' +\n                      'At binding: [ ' + first.address.join(', ') + ' ].')\n    }\n    return objectForBindings([ addressToObj(first.address, container) ])\n  }\n\n  // get the children with IDs\n  const childrenWithKeys = Array.from(container.children).filter(c => c.id)\n  const elementsByID = keyBy(childrenWithKeys, 'id')\n\n  // render each element\n  const bindingsAr = tinierElements.map((tinierEl, i) => {\n    // If an element if a binding, then there can only be one child.\n    if (isUndefined(tinierEl)) {\n      // cannot be undefined\n      throw new Error('Children in Tinier Elements cannot be undefined.')\n    } else if (isTinierElement(tinierEl)) {\n      // container.childNodes is a live collection, so get the current node at\n      // this index.\n      const el = container.childNodes[i]\n      // tinierEl is a TinierDOM element.\n      if (tinierEl.attributes.id in elementsByID) {\n        // el exist, then check for a matching node by ID\n        const movedEl = elementsByID[tinierEl.attributes.id]\n        if (el) {\n          // if match and existing el, then replace the element\n          container.replaceChild(movedEl, el)\n        } else {\n          // if match and el is undefined, then append the element\n          container.appendChild(movedEl)\n        }\n        // then render children\n        return render(movedEl, ...tinierEl.children)\n      } else if (el) {\n        // both defined, check type and id\n        if (el.tagName && el.tagName.toLowerCase() ===\n            tinierEl.tagName.toLowerCase()) {\n          // matching tag, then update the node to match. Be aware that existing\n          // nodes with IDs might get moved, so we should clone them?\n          const elToUpdate = el.id ? el.cloneNode(true) : el\n          updateDOMElement(elToUpdate, tinierEl)\n          if (el.id) container.replaceChild(elToUpdate, el)\n          return render(elToUpdate, ...tinierEl.children)\n        } else {\n          // not a matching tag, then replace the element with a new one\n          const newEl = createDOMElement(tinierEl, container)\n          container.replaceChild(newEl, el)\n          return render(newEl, ...tinierEl.children)\n        }\n      } else {\n        // no el and no ID match, then add a new Element or string node\n        const newEl2 = createDOMElement(tinierEl, container)\n        container.appendChild(newEl2)\n        return render(newEl2, ...tinierEl.children)\n      }\n      // There should not be any bindings here\n    } else if (isTinierBinding(tinierEl)) {\n      throw new Error('A binding cannot have siblings in TinierDOM. ' +\n                      'At binding: [ ' + tinierEl.address.join(', ') + ' ].')\n    } else {\n      const el = container.childNodes[i]\n      const s = String(tinierEl)\n      // This should be a text node.\n      if (isText(el)) {\n        // If already a text node, then set the text content.\n        el.textContent = s\n      } else if (el) {\n        // If not a text node, then replace it.\n        container.replaceChild(document.createTextNode(s), el)\n      } else {\n        // If no existing node, then add a new one.\n        container.appendChild(document.createTextNode(s))\n      }\n      // No binding here.\n      return null\n    }\n  })\n\n  // remove extra nodes\n  // TODO This should not run if the child is a binding. Make a test for\n  // this. When else should it not run?\n  removeExtraNodes(container, tinierElements.length)\n\n  // bindings array to object\n  return objectForBindings(bindingsAr.filter(b => b !== null))\n}\n\n// export API\nexport default {\n  arrayOf, objectOf, createComponent, run, bind, createElement, render,\n}\n"]}