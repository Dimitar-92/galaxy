'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.tail = tail;
exports.head = head;
exports.fromPairs = fromPairs;
exports.get = get;
exports.isUndefined = isUndefined;
exports.isObject = isObject;
exports.isArray = isArray;
exports.isString = isString;
exports.isNumber = isNumber;
exports.isBoolean = isBoolean;
exports.isFunction = isFunction;
exports.notNull = notNull;
exports.mapValues = mapValues;
exports.reduceValues = reduceValues;
exports.zipArrays = zipArrays;
exports.zipObjects = zipObjects;
exports.filterValues = filterValues;
exports.any = any;
exports.tagType = tagType;
exports.checkType = checkType;
exports.match = match;
exports.hasChildren = hasChildren;
exports.checkRenderResult = checkRenderResult;
exports.updateEl = updateEl;
exports.addressWith = addressWith;
exports.addressEqual = addressEqual;
exports.makeTree = makeTree;
exports.checkState = checkState;
exports.diffWithModelMin = diffWithModelMin;
exports.makeSignal = makeSignal;
exports.makeOneSignalAPI = makeOneSignalAPI;
exports.makeChildSignalsAPI = makeChildSignalsAPI;
exports.reduceChildren = reduceChildren;
exports.mergeSignals = mergeSignals;
exports.objectOf = objectOf;
exports.arrayOf = arrayOf;
exports.createComponent = createComponent;
exports.patchMethods = patchMethods;
exports.makeCallMethod = makeCallMethod;
exports.makeCallReducer = makeCallReducer;
exports.makeStateCallers = makeStateCallers;
exports.run = run;
exports.addressToObj = addressToObj;
exports.objectForBindings = objectForBindings;
exports.createElement = createElement;
exports.bind = bind;
exports.createDOMElement = createDOMElement;
exports.getStyles = getStyles;
exports.updateDOMElement = updateDOMElement;
exports.render = render;
/** @module tinier */

// constants
var ARRAY_OF = exports.ARRAY_OF = '@TINIER_ARRAY_OF';
var OBJECT_OF = exports.OBJECT_OF = '@TINIER_OBJECT_OF';
var COMPONENT = exports.COMPONENT = '@TINIER_COMPONENT';
var ARRAY = exports.ARRAY = '@TINIER_ARRAY';
var OBJECT = exports.OBJECT = '@TINIER_OBJECT';
var NODE = exports.NODE = '@TINIER_NODE';
var NULL = exports.NULL = '@TINIER_NULL';
var STRING = exports.STRING = '@TINIER_STRING';
var NUMBER = exports.NUMBER = '@TINIER_NUMBER';
var BOOLEAN = exports.BOOLEAN = '@TINIER_BOOLEAN';
var ANY = exports.ANY = '@TINIER_ANY';
var NO_ARGUMENT = exports.NO_ARGUMENT = '@TINIER_NO_ARGUMENT';
var TOP = exports.TOP = '@TINIER_TOP';
var CREATE = exports.CREATE = '@TINIER_CREATE';
var UPDATE = exports.UPDATE = '@TINIER_UPDATE';
var DESTROY = exports.DESTROY = '@TINIER_DESTROY';

// basic functions
function noop() {}

function constant(val) {
  return function () {
    return val;
  };
}

function identity(val) {
  return val;
}

function last(array) {
  return array[array.length - 1];
}

function tail(array) {
  return [array.slice(0, -1), last(array)];
}

function head(array) {
  return [array[0], array.slice(1)];
}

function fromPairs(pairs) {
  return pairs.reduce(function (accum, _ref) {
    var _extends2;

    var key = _ref[0],
        val = _ref[1];

    return _extends({}, accum, (_extends2 = {}, _extends2[key] = val, _extends2));
  }, {});
}

/**
 * Get the property of the object or index of the array, or return the default
 * value.
 * @param {Object|Array} object - An object or array.
 * @param {String} property - An property of the object.
 * @return {*} The value of the property or, if not present, the default value.
 */
function get(object, property) {
  return object && typeof object !== 'string' && object.hasOwnProperty(property) ? object[property] : null;
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

/**
 * Check if the value is an object with enumerable properties. Also returns true
 * for arrays.
 * @param {*} value - The value to test.
 * @return {Boolean}
 */
function isObject(object) {
  return object != null && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object';
}

/**
 * Check if the object is an array
 * @param {*} object - The object to test.
 * @return {Boolean}
 */
function isArray(object) {
  return Array.isArray(object);
}

function isString(v) {
  return typeof v === 'string';
}

function isNumber(v) {
  return typeof v === 'number';
}

function isBoolean(v) {
  return typeof v === 'boolean';
}

/**
 * Check if the object is a function.
 * @param {*} object - The object to test.
 * @return {Boolean}
 */
function isFunction(object) {
  return typeof object === 'function';
}

function notNull(val) {
  return val !== null;
}

/**
 * Iterate over the keys and values of an object. Uses Object.keys to find
 * iterable keys.
 * @param {Object} obj - The input object.
 * @param {Function} fn - A function that takes the arguments (value, key).
 * @return {Object} A transformed object with values returned by the function.
 */
function mapValues(obj, fn) {
  var newObj = {};
  for (var key in obj) {
    newObj[key] = fn(obj[key], key);
  }
  return newObj;
}

function reduceValues(obj, fn, init) {
  var accum = init;
  for (var key in obj) {
    accum = fn(accum, obj[key], key);
  }
  return accum;
}

function zipArrays(arrays) {
  var lenLongest = Math.max.apply(null, arrays.filter(function (x) {
    return x !== null;
  }).map(function (a) {
    return a.length;
  }));
  var res = [];

  var _loop = function _loop(i) {
    res.push(arrays.map(function (a) {
      return a !== null && i < a.length ? a[i] : null;
    }));
  };

  for (var i = 0; i < lenLongest; i++) {
    _loop(i);
  }
  return res;
}

function zipObjects(objects) {
  var len = objects.length;
  // find all the keys
  var allKeys = {};
  for (var i = 0; i < len; i++) {
    var object = objects[i];
    if (object === null) {
      continue;
    }
    for (var k in object) {
      allKeys[k] = true;
    }
  }
  // make new object
  var res = {};
  for (var key in allKeys) {
    res[key] = Array(len);
    for (var _i = 0; _i < len; _i++) {
      var _object = objects[_i];
      res[key][_i] = get(_object, key);
    }
  }
  return res;
}

function filterValues(object, fn) {
  var out = {};
  for (var key in object) {
    var value = object[key];
    if (fn(value, key)) out[key] = value;
  }
  return out;
}

/**
 * Lazy any function.
 * @param {[Boolean]}
 * @return {Boolean}
 */
function any(ar) {
  for (var i = 0, l = ar.length; i < l; i++) {
    var val = ar[i];
    if (!isBoolean(val)) {
      throw new Error('Not a boolean: ' + val);
    }
    if (val) {
      return true;
    }
  }
  return false;
}

/**
 * Defers calling fn until the current process finishes.
 */
function defer(fn) {
  setTimeout(fn, 1);
}

/**
 * Adds a tag to the object.
 */
function tagType(type, obj) {
  if (!isString(type)) {
    throw new Error('First argument must be a string');
  }
  if (!isObject(obj)) {
    throw new Error('Second argument must be an object');
  }
  obj.type = type;
  return obj;
}

function checkType(type, obj) {
  if (obj === null) {
    return type === NULL;
  }
  if (typeof type !== 'string') {
    throw new Error('First argument must be a string');
  }
  if (isUndefined(obj)) {
    throw new Error('Bad second argument');
  }
  return get(obj, 'type') === type;
}

/**
 * Basic pattern matching.
 * @param {Object|null} object - An object generated with tagType, an object, an
 *                               array, or null.
 * @param {Object} fns - An object with types for keys and functions for values.
 *                       Also accepts keys tinier.OBJECT, tinier.ARRAY, and
 *                       tinier.NULL. To avoid conflict, tinier.OBJECT has the
 *                       lowest priority.
 * @param {Function} defaultFn - A function to run if the object type is not
 *                               found. Takes `object` as a single argument.
 * @return {*} Return value from the called function.
 */
function match(object, fns) {
  var defaultFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : throwUnrecognizedType;

  for (var key in fns) {
    if (key === NULL && object === null || key === ARRAY && isArray(object) || isObject(object) && checkType(key, object)) {
      return fns[key](object);
    }
  }
  if (OBJECT in fns && isObject(object)) {
    return fns[OBJECT](object);
  }
  return defaultFn(object);
}

function throwUnrecognizedType(node) {
  throw new Error('Unrecognized type in pattern matching: ' + node);
}

// -------------------------------------------------------------------
// Update components
// -------------------------------------------------------------------

/**
 * Determine whether the model has any child components.
 */
function hasChildren(node) {
  var _match;

  return match(node, (_match = {}, _match[ARRAY_OF] = function () {
    return true;
  }, _match[OBJECT_OF] = function () {
    return true;
  }, _match[COMPONENT] = function () {
    return true;
  }, _match[ARRAY] = function (node) {
    return any(node.map(hasChildren));
  }, _match[OBJECT] = function (node) {
    return any(Object.keys(node).map(function (k) {
      return hasChildren(node[k]);
    }));
  }, _match));
}

function checkRenderResultRecurse(userBindings, node, state) {
  var _match2;

  var updateRecurse = function updateRecurse(s, k) {
    var u = k === null ? userBindings : get(userBindings, k);
    if (userBindings !== null && u === null) {
      throw new Error('Shape of the bindings object does not match the model.' + 'Model: ' + node + '  Bindings object: ' + userBindings);
    }
  };
  var recurse = function recurse(n, k) {
    checkRenderResultRecurse(get(userBindings, k), n, get(state, k));
  };
  match(node, (_match2 = {}, _match2[OBJECT_OF] = function (objOf) {
    // check for extra attributes
    if (userBindings !== null && any(Object.keys(userBindings).map(function (k) {
      return !(k in state);
    }))) {
      throw new Error('Shape of the bindings object does not match the ' + 'model. Model: ' + node + ' Bindings object: ' + userBindings);
    } else {
      mapValues(state, updateRecurse);
    }
  }, _match2[ARRAY_OF] = function (arOf) {
    // check array lengths
    if (userBindings !== null && state.length !== userBindings.length) {
      throw new Error('Shape of the bindings object does not match the ' + 'model. Model: ' + node + ' Bindings object: ' + userBindings);
    } else {
      state.map(updateRecurse);
    }
  }, _match2[COMPONENT] = function (component) {
    return updateRecurse(state, null);
  }, _match2[ARRAY] = function (ar) {
    if (userBindings !== null && !isArray(userBindings)) {
      throw new Error('Shape of the bindings object does not match the ' + 'model. Model: ' + node + ' Bindings object: ' + userBindings);
    } else {
      ar.map(recurse);
    }
  }, _match2[OBJECT] = function (obj) {
    if (userBindings !== null && isArray(userBindings)) {
      throw new Error('Shape of the bindings object does not match the ' + 'model. Model: ' + node + ' Bindings object: ' + userBindings);
    } else {
      mapValues(obj, recurse);
    }
  }, _match2));
}

/**
 * Check the result of render against the model and state.
 * @param {Object} node - A model node.
 * @param {*} state - A state node.
 * @param {Object} userBindings - The new bindings returned by render.
 * @return {Object} The userBindings object.
 */
function checkRenderResult(userBindings, node, state) {
  checkRenderResultRecurse(userBindings, node, state);
  return userBindings;
}

/**
 * Run lifecycle functions for the component.
 * @param {Object} address -
 * @param {Object} component -
 * @param {Object} state -
 * @param {Object} diffVal -
 * @param {Object|null} lastRenderedEl - The element rendered in previously, if
 *                                       there was one.
 * @param {Object|null} el - The element to render in provided by
 *                           component.render.
 * @param {Object} stateCallers -
 * @return {Object}
 */
function updateEl(address, component, state, diffVal, lastRenderedEl, el, stateCallers, opts) {
  // the object passed to lifecycle functions
  var reducers = patchReducersWithState(address, component, stateCallers.callReducer);
  var signals = patchSignals(address, component, stateCallers.callSignal);
  var methods = patchMethods(address, component, stateCallers.callMethod, reducers, signals);
  var arg = { state: state, methods: methods, reducers: reducers, signals: signals, el: el, lastRenderedEl: lastRenderedEl };

  // warn if the el is null
  if (el === null && !(diffVal === DESTROY) && component.render !== noop) {
    throw new Error('No binding provided for component ' + component.displayName + ' at [' + address.join(', ') + '].');
  }

  if (diffVal === DESTROY) {
    // destroy
    component.willUnmount(arg);
    return { bindings: null, lastRenderedEl: lastRenderedEl };
  } else {
    // create or update
    var shouldUpdate = diffVal === CREATE || diffVal === UPDATE || el !== lastRenderedEl;

    if (diffVal === CREATE) component.willMount(arg);else if (shouldUpdate) component.willUpdate(arg);

    if (opts.verbose && shouldUpdate) {
      console.log('Rendering ' + component.displayName + ' at [' + address.join(', ') + '].');
    }

    // render
    var bindings = shouldUpdate ? checkRenderResult(component.render(arg), component.model, state) : null;
    // check result
    if (shouldUpdate && bindings === null && hasChildren(component.model)) {
      throw new Error('The render function of component ' + component.displayName + ' did not return new bindings');
    }

    // These need to be asynchronous.
    if (diffVal === CREATE) {
      defer(function () {
        return component.didMount(arg);
      });
    } else if (shouldUpdate) {
      defer(function () {
        return component.didUpdate(arg);
      });
    }

    // If the component rendered, then change lastEl.
    return { bindings: bindings, lastRenderedEl: shouldUpdate ? el : lastRenderedEl };
  }
}

/**
 * For a tree, return everything down to the first set of NODES with data for
 * leaves.
 */
function dropNodes(tree) {
  var _match3;

  return match(tree, (_match3 = {}, _match3[NODE] = function (node) {
    return node.data;
  }, _match3[OBJECT] = function (obj) {
    return mapValues(obj, dropNodes);
  }, _match3[ARRAY] = function (ar) {
    return ar.map(dropNodes);
  }, _match3[NULL] = function () {
    return null;
  }, _match3));
}

/**
 * Run create, update, and destroy for component.
 * @param {Array} address - The location of the component in the state.
 * @param {Object} node - A model or a node within a model.
 * @param {Object} diff - The diff object for this component.
 * @param {Object|null} bindings -
 * @param {Object|null} renderResult -
 * @param {Object} stateCallers -
 * @return {Object}
 */
function updateComponents(address, node, state, diff, bindings, renderResult, stateCallers, opts) {
  var _match4;

  var updateRecurse = function updateRecurse(_ref2, k) {
    var d = _ref2[0],
        s = _ref2[1];

    // TODO in updateRecurse functions where k can be null, there must be a
    // nicer way to organize things with fewer null checks
    var component = k !== null ? node.component : node;
    var newAddress = k !== null ? addressWith(address, k) : address;
    var b = k !== null ? get(bindings, k) : bindings;
    var r = k !== null ? get(renderResult, k) : renderResult;
    // Update the component. If DESTROY, then there will not be a binding.
    var res = updateEl(newAddress, component, s, d.data, get(b, 'data'), r, stateCallers, opts);
    // Fall back on old bindings.
    var nextRenderResult = res.bindings !== null ? res.bindings : dropNodes(b.children);
    var data = res.lastRenderedEl;
    // update children
    var children = updateComponents(newAddress, component.model, s, d.children, get(b, 'children'), nextRenderResult, stateCallers, opts);
    return tagType(NODE, { data: data, children: children });
  };
  var recurse = function recurse(n, k) {
    return updateComponents(addressWith(address, k), n, get(state, k), diff[k], get(bindings, k), get(renderResult, k), stateCallers, opts);
  };
  return match(node, (_match4 = {}, _match4[OBJECT_OF] = function (objOf) {
    return mapValues(zipObjects([diff, state]), updateRecurse);
  }, _match4[ARRAY_OF] = function (arOf) {
    return zipArrays([diff, state]).map(updateRecurse);
  }, _match4[COMPONENT] = function (component) {
    return updateRecurse([diff, state], null);
  }, _match4[ARRAY] = function (ar) {
    return ar.map(recurse);
  }, _match4[OBJECT] = function (obj) {
    return mapValues(obj, recurse);
  }, _match4));
}

// -------------------------------------------------------------------
// State
// -------------------------------------------------------------------

function addressWith(address, key) {
  if (key === null) {
    return address;
  } else {
    var newAddress = address.slice(0);
    newAddress.push(key);
    return newAddress;
  }
}

function addressEqual(a1, a2) {
  if (a1 === null || a2 === null || a1.length !== a2.length) return false;
  return a1.reduce(function (accum, v, i) {
    return accum && v === a2[i];
  }, true);
}

/**
 * Get the value in a tree.
 * @param {Array} address -
 * @param {Object} tree -
 * @return {*} - The value at the given address.
 */
function treeGet(address, tree) {
  return address.reduce(function (accum, val) {
    return checkType(NODE, accum) ? accum.children[val] : accum[val];
  }, tree);
}

/**
 * Set the value in a tree; immutable.
 * @param {Array} address -
 * @param {Object} tree -
 * @param {*} value - The new value to set at address.
 * @return (*) The new tree.
 */
function treeSet(address, tree, value) {
  if (address.length === 0) {
    return value;
  } else {
    var _extends3;

    var _head = head(address),
        k = _head[0],
        rest = _head[1];

    return typeof k === 'string' ? _extends({}, tree, (_extends3 = {}, _extends3[k] = treeSet(rest, treeGet([k], tree), value), _extends3)) : [].concat(tree.slice(0, k), [treeSet(rest, treeGet([k], tree), value)], tree.slice(k + 1));
  }
}

/**
 * Set the value in a tree; mutable.
 * @param {Array} address -
 * @param {Object} tree -
 * @param {*} value - The new value to set at address.
 * @return (*) The tree.
 */
function treeSetMutable(address, tree, value) {
  if (address.length === 0) {
    return value;
  } else {
    var _tail = tail(address),
        rest = _tail[0],
        _last = _tail[1];

    var parent = treeGet(rest, tree);
    if (checkType(NODE, parent)) {
      parent.children[_last] = value;
    } else {
      parent[_last] = value;
    }
    return tree;
  }
}

function makeTree(init, mutable) {
  var state = init;
  return {
    get: function get(address) {
      return treeGet(address, state);
    },
    set: function set(address, value) {
      state = mutable ? treeSetMutable(address, state, value) : treeSet(address, state, value);
    }
  };
}

/**
 * Check that the new state is valid. If not, then throw an Error.
 * @param {Object} modelNode - A model or a node of a model.
 * @param {Object} newState - The new state corresponding to modelNode.
 */
function checkState(modelNode, newState) {
  var _match5;

  if (newState === null) {
    return;
  }
  match(modelNode, (_match5 = {}, _match5[OBJECT_OF] = function (objOf) {
    if (!isObject(newState) || isArray(newState)) {
      throw new Error('Shape of the new state does not match the model. ' + 'Model: ' + objOf + '  State: ' + newState);
    } else {
      mapValues(newState, function (s) {
        return checkState(modelNode.component.model, s);
      });
    }
  }, _match5[ARRAY_OF] = function (arOf) {
    if (!isArray(newState)) {
      throw new Error('Shape of the new state does not match the model.' + 'Model: ' + arOf + '  State: ' + newState);
    } else {
      newState.map(function (s) {
        return checkState(modelNode.component.model, s);
      });
    }
  }, _match5[COMPONENT] = function (component) {
    checkState(modelNode.model, newState);
  }, _match5[ARRAY] = function (ar) {
    if (!isArray(newState)) {
      throw new Error('Shape of the new state does not match the model.' + 'Model: ' + ar + '  State: ' + newState);
    } else {
      ar.map(function (a, i) {
        return checkState(a, get(newState, i));
      });
    }
  }, _match5[OBJECT] = function (obj) {
    if (!isObject(newState) || isArray(newState)) {
      throw new Error('Shape of the new state does not match the model. ' + 'Model: ' + obj + '  State: ' + newState);
    } else {
      mapValues(obj, function (o, k) {
        return checkState(o, get(newState, k));
      });
    }
  }, _match5));
}

function computeDiffValue(state, lastState, key, isValidFn, shouldUpdate, address, triggeringAddress) {
  var stateValid = isValidFn(state, key);
  var lastStateValid = isValidFn(lastState, key);
  if (stateValid && !lastStateValid) {
    return CREATE;
  } else if (stateValid && lastStateValid) {
    var same = key === null ? state !== lastState : state[key] !== lastState[key];
    var componentTriggeredUpdate = addressEqual(address, triggeringAddress);
    if (same && shouldUpdate({ state: state, lastState: lastState, componentTriggeredUpdate: componentTriggeredUpdate })) {
      return UPDATE;
    } else {
      return null;
    }
  } else if (!stateValid && lastStateValid) {
    return DESTROY;
  } else {
    return null;
  }
}

/**
 * Compute the full diff tree for the model node. Calls shouldUpdate.
 */
function diffWithModel(modelNode, state, lastState, address, triggeringAddress) {
  var _match6;

  return match(modelNode, (_match6 = {}, _match6[OBJECT_OF] = function (objOf) {
    var isValidFn = function isValidFn(obj, k) {
      return isObject(obj) && k in obj && obj[k] !== null;
    };
    var l = Object.assign({}, state || {}, lastState || {});
    return mapValues(l, function (_, k) {
      var data = computeDiffValue(state, lastState, k, isValidFn, objOf.component.shouldUpdate, addressWith(address, k), triggeringAddress);
      var children = diffWithModel(objOf.component.model, get(state, k), get(lastState, k), addressWith(address, k), triggeringAddress);
      return tagType(NODE, { data: data, children: children });
    });
  }, _match6[ARRAY_OF] = function (arOf) {
    var isValidFn = function isValidFn(obj, i) {
      return isArray(obj) && i < obj.length && obj[i] !== null;
    };
    var longest = Math.max(isArray(state) ? state.length : 0, isArray(lastState) ? lastState.length : 0);
    var l = Array.apply(null, { length: longest });
    return l.map(function (_, i) {
      var data = computeDiffValue(state, lastState, i, isValidFn, arOf.component.shouldUpdate, addressWith(address, i), triggeringAddress);
      var children = diffWithModel(arOf.component.model, get(state, i), get(lastState, i), addressWith(address, i), triggeringAddress);
      return tagType(NODE, { data: data, children: children });
    });
  }, _match6[COMPONENT] = function (component) {
    var isValidFn = function isValidFn(obj, _) {
      return obj !== null;
    };
    var data = computeDiffValue(state, lastState, null, isValidFn, component.shouldUpdate, address, triggeringAddress);
    var children = diffWithModel(component.model, state || null, lastState || null, address, triggeringAddress);
    return tagType(NODE, { data: data, children: children });
  }, _match6[ARRAY] = function (ar) {
    return ar.map(function (n, i) {
      return diffWithModel(n, get(state, i), get(lastState, i), addressWith(address, i), triggeringAddress);
    });
  }, _match6[OBJECT] = function (obj) {
    return mapValues(obj, function (n, k) {
      return diffWithModel(n, get(state, k), get(lastState, k), addressWith(address, k), triggeringAddress);
    });
  }, _match6));
}

/**
 * For an array of minSignals and minUpdate trees, return the minimal trees that
 * represent the whole array.
 */
function singleOrAll(modelNode, address, minTreeAr) {
  var getMin = function getMin(indices) {
    if (indices.length === 0) {
      // If all elements in the array are null, return null.
      return null;
    } else if (nonNullIndices.signals.length === 1) {
      // If there is a single value, return that tree, with an updated address.
      return {
        minSignals: {
          diff: minTreeAr.map(function (a) {
            return a.minSignals.diff;
          }),
          address: address,
          modelNode: modelNode
        },
        minUpdate: {
          diff: minTreeAr.map(function (a) {
            return a.minUpdate.diff;
          }),
          address: address,
          modelNode: modelNode
        }
      };
    } else {
      // Otherwise, return full trees from this level.
      return {
        minSignals: {
          diff: minTreeAr.map(function (a) {
            return a.minSignals.diff;
          }),
          address: address,
          modelNode: modelNode
        },
        minUpdate: {
          diff: minTreeAr.map(function (a) {
            return a.minUpdate.diff;
          }),
          address: address,
          modelNode: modelNode
        }
      };
    }
  };
  // Get the indices where the signal and update trees are not null.
  var nonNullIndices = minTreeAr.reduce(function (accum, val, i) {
    return {
      signals: val.minSignals !== null ? [].concat(accum.signals, [i]) : accum.signals,
      update: val.minUpdate !== null ? [].concat(accum.update, [i]) : accum.update
    };
  }, { signals: [], update: [] });
  // For each set of indices, test the diffs with these tests to get a minimum
  // tree.
  var minSignals = getMin(nonNullIndices.signals);
  var minUpdate = getMin(nonNullIndices.update);
  return { minSignals: minSignals, minUpdate: minUpdate };
}

/**
 * 1. Run shouldUpdate for every component in the tree.
 * 2. Return the information about the minimal tree to update with
 *    updateComponents (whenever shouldUpdate is true) as minUpdate.
 * 3. Return the information about the minimal tree to update with
 *    mergeSignals (whenever nodes are added or deleted) as minSignals.
 *
 * @param {Object} modelNode - A model or a node of a model.
 * @param {Object} state - The new state corresponding to modelNode.
 * @param {Object|null} lastState - The old state corresponding to modelNode.
 * @param {Array} address -
 * @param {Array} triggeringAddress -
 * @returns {Object} An object with the attributes minSignals and
 *                   minUpdate. Each represents a minimal tree necessary for the
 *                   appropriate update function and has the attributes diff,
 *                   modelNode, and address.
 */
function diffWithModelMin(modelNode, state, lastState, address, triggeringAddress) {
  // 1. calculate whole diff tree
  var diff = diffWithModel(modelNode, state, lastState, address, triggeringAddress);
  // 2. trim the tree for the two needs
  return {
    minSignals: {
      diff: diff,
      address: address,
      modelNode: modelNode
    },
    minUpdate: {
      diff: diff,
      address: address,
      modelNode: modelNode
    }
  };
}

// -------------------------------------------------------------------
// Signals
// -------------------------------------------------------------------

/**
 * Make a signal.
 * @return {Object} A signal with attributes `on` and `call`.
 */
function makeSignal() {
  var res = { _onFns: [] };
  res.on = function (fn) {
    if (!isFunction(fn)) {
      throw new Error('First argument to "on" must be a function');
    }
    res._onFns = [].concat(res._onFns, [fn]);
  };
  res.call = function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return res._onFns.map(function (fn) {
      return fn.apply(undefined, args);
    });
  };
  return res;
}

/**
 * Create an object that with `on/onEach` and `call` attributes.
 * @param {Boolean} isCollection -
 * @return {Object}
 */
function makeOneSignalAPI(isCollection) {
  // make a `_callFn` function that will be replaced later and is the target of
  // `call`
  var res = { _callFns: [] };
  // call will run all functions in `_callFns`
  res.call = function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (args.length > 1 || !isObject(args[0])) {
      throw new Error('Call only accepts a single object as argument.');
    }
    res._callFns.map(function (_ref3) {
      var fn = _ref3.fn;
      return fn(args[0]);
    });
  };
  // store callbacks passed with `on` or `onEach`
  res._onFns = [];
  var onName = isCollection ? 'onEach' : 'on';
  res[onName] = function (fn) {
    if (!isFunction(fn)) {
      throw new Error('Argument to "' + onName + '" must be a function');
    }
    res._onFns.push(function (index) {
      return function () {
        if (arguments.length > 1 || !isObject(arguments.length <= 0 ? undefined : arguments[0])) {
          throw new Error('On function only accepts a single object as argument.');
        }
        var argObject = typeof index === 'string' ? _extends({ k: index }, arguments.length <= 0 ? undefined : arguments[0]) : typeof index === 'number' ? _extends({ i: index }, arguments.length <= 0 ? undefined : arguments[0]) : arguments.length <= 0 ? undefined : arguments[0];
        fn(argObject);
      };
    });
  };
  return res;
}

/**
 * Implement the signals API.
 */
function makeSignalsAPI(signalNames, isCollection) {
  return fromPairs(signalNames.map(function (name) {
    return [name, makeOneSignalAPI(isCollection)];
  }));
}

/**
 * Implement the childSignals API.
 */
function makeChildSignalsAPI(model) {
  var _match7;

  return match(model, (_match7 = {}, _match7[OBJECT_OF] = function (node) {
    return makeSignalsAPI(node.component.signalNames, true);
  }, _match7[ARRAY_OF] = function (node) {
    return makeSignalsAPI(node.component.signalNames, true);
  }, _match7[COMPONENT] = function (node) {
    return makeSignalsAPI(node.signalNames, false);
  }, _match7[ARRAY] = function (ar) {
    return ar.map(makeChildSignalsAPI).filter(notNull);
  }, _match7[OBJECT] = function (obj) {
    return filterValues(mapValues(obj, makeChildSignalsAPI), notNull);
  }, _match7), constant(null));
}

/**
 * Reduce the direct children of the tree.
 * @param {Object} node - A node in a tree.
 * @param {Function} fn - Function with arguments (accum, object).
 * @param {*} init - An initial value.
 * @param {Array} address - The local address.
 * @return {*}
 */
function reduceChildren(node, fn, init) {
  var _match8;

  var address = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  return match(node, (_match8 = {}, _match8[NODE] = function (node) {
    return fn(init, node.data, address);
  }, _match8[ARRAY] = function (ar) {
    return ar.reduce(function (accum, n, k) {
      return reduceChildren(n, fn, accum, addressWith(address, k));
    }, init);
  }, _match8[OBJECT] = function (obj) {
    return reduceValues(obj, function (accum, n, k) {
      return reduceChildren(n, fn, accum, addressWith(address, k));
    }, init);
  }, _match8), constant(init));
}

/**
 * Run signalSetup with the component.
 * @param {Object} component -
 * @param {Array} address -
 * @param {Object} stateCallers -
 * @return {Object} Object with keys signalsAPI and childSignalsAPI.
 */
function runSignalSetup(component, address, stateCallers) {
  var signalsAPI = makeSignalsAPI(component.signalNames, false);
  var childSignalsAPI = makeChildSignalsAPI(component.model);
  var reducers = patchReducersWithState(address, component, stateCallers.callReducer);
  var signals = patchSignals(address, component, stateCallers.callSignal);
  var methods = patchMethods(address, component, stateCallers.callMethod, reducers, signals);
  // cannot call signalSetup any earlier because it needs a reference to
  // `methods`, which must know the address
  component.signalSetup({
    methods: methods,
    reducers: reducers,
    signals: signalsAPI,
    childSignals: childSignalsAPI
  });
  return { signalsAPI: signalsAPI, childSignalsAPI: childSignalsAPI };
}

/**
 * Merge a signals object with signal callbacks from signalSetup.
 * @param {Object} node - A model node.
 * @param {Array} address - The address.
 * @param {Object} diffNode - A node in the diff tree.
 * @param {Object|null} signalNode - A node in the existing signals tree.
 * @param {Object} stateCallers - The object with 3 functions to modify global
 *                                state.
 * @param {Object|null} upChild - The childSignalsAPI object for the parent
 *                                Component.
 * @param {Array|null} upAddress - A local address specifying the location
 *                                 relative to the parent Component.
 * @return {Object} The new signals tree.
 */
function mergeSignals(node, address, diffNode, signalNode, stateCallers) {
  var _match9;

  var upChild = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var upAddress = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

  var updateRecurse = function updateRecurse(_ref4, k) {
    var d = _ref4[0],
        s = _ref4[1];

    var component = k !== null ? node.component : node;
    var newAddress = k !== null ? addressWith(address, k) : address;
    var diffVal = d.data;
    if (diffVal === CREATE) {
      var _ret2 = function () {
        // For create, apply the callbacks
        var _runSignalSetup = runSignalSetup(component, newAddress, stateCallers),
            signalsAPI = _runSignalSetup.signalsAPI,
            childSignalsAPI = _runSignalSetup.childSignalsAPI;

        var newUpAddress = upAddress === null ? null : addressWith(upAddress, k);
        var signals = mapValues(zipObjects([signalsAPI, upChild]), function (_ref5, key) {
          var callbackObj = _ref5[0],
              upCallbackObj = _ref5[1];

          var signal = makeSignal();

          // For each callback, add each onFn to the signal,
          // and set the callFn to the signal dispatch. Only
          // on, not onEach, so execute the fn with no
          // argument.
          callbackObj._onFns.map(function (fn) {
            return signal.on(fn());
          });
          callbackObj._callFns = [{ fn: signal.call, address: null }];

          // For the childSignalCallbacks from the parent
          if (upCallbackObj !== null) {
            upCallbackObj._onFns.map(function (fn) {
              return signal.on(fn(k));
            });
            upCallbackObj._callFns = [].concat(upCallbackObj._callFns, [{ fn: signal.call, address: newUpAddress }]);
          }

          return signal;
        });
        var data = { signals: signals, signalsAPI: signalsAPI, childSignalsAPI: childSignalsAPI };

        // loop through the children of signals and node
        var children = mergeSignals(component.model, newAddress, d.children, get(s, 'children'), stateCallers, childSignalsAPI, []);

        return {
          v: tagType(NODE, { data: data, children: children })
        };
      }();

      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
    } else if (diffVal === DESTROY) {
      // In the case of destroy, this leaf in the signals object will be null.
      return null;
    } else {
      // update
      var _reduceChildren = reduceChildren(d.children, function (accum, diffVal, address) {
        var hasCreated = accum.hasCreated || diffVal === CREATE;
        var destroyed = diffVal === DESTROY ? [].concat(accum.destroyed, [address]) : accum.destroyed;
        return { hasCreated: hasCreated, destroyed: destroyed };
      }, { hasCreated: false, destroyed: [] }),
          hasCreated = _reduceChildren.hasCreated,
          destroyed = _reduceChildren.destroyed;

      // if there are deleted children, delete references to them


      destroyed.map(function (childAddress) {
        // get the right child within childSignalsAPI
        var childSignalsAPINode = childAddress.reduce(function (accum, k, i) {
          if (k in accum) {
            return accum[k];
          } else if (i === childAddress.length - 1) {
            return accum;
          } else {
            throw new Error('Bad address ' + childAddress + ' for object ' + s.data.childSignalsAPI);
          }
        }, s.data.childSignalsAPI);
        mapValues(childSignalsAPINode, function (obj) {
          // remove the matching callFns
          obj._callFns = obj._callFns.filter(function (_ref6) {
            var address = _ref6.address;

            return !addressEqual(address, childAddress);
          });
        });
      });

      var newUpChild = hasCreated ? s.data.childSignalsAPI : null;
      var _newUpAddress = hasCreated ? [] : null;
      var _children = mergeSignals(component.model, newAddress, d.children, get(s, 'children'), stateCallers, newUpChild, _newUpAddress);
      return tagType(NODE, { data: get(s, 'data'), children: _children });
    }
  };

  var recurse = function recurse(_ref7, k) {
    var n = _ref7[0],
        d = _ref7[1],
        s = _ref7[2],
        u = _ref7[3];

    var newAddress = addressWith(address, k);
    var newUpAddress = upAddress === null ? null : addressWith(upAddress, k);
    return mergeSignals(n, newAddress, d, s, stateCallers, u, newUpAddress);
  };

  return match(node, (_match9 = {}, _match9[OBJECT_OF] = function (objOf) {
    return filterValues(mapValues(zipObjects([diffNode, signalNode]), updateRecurse), notNull);
  }, _match9[ARRAY_OF] = function (arOf) {
    return zipArrays([diffNode, signalNode]).map(updateRecurse).filter(notNull);
  }, _match9[COMPONENT] = function (component) {
    return updateRecurse([diffNode, signalNode], null);
  }, _match9[ARRAY] = function (ar) {
    return zipArrays([ar, diffNode, signalNode, upChild]).map(recurse);
  }, _match9[OBJECT] = function (obj) {
    return mapValues(zipObjects([obj, diffNode, signalNode, upChild]), recurse);
  }, _match9), constant(null));
}

// -------------------------------------------------------------------
// Component & run functions
// -------------------------------------------------------------------

/**
 * Create an object representing many instances of this component, for use in a
 * tinier model.
 * @param {Object} component - Tinier component.
 * @return {Object}
 */
function objectOf(component) {
  return tagType(OBJECT_OF, { component: component });
}

/**
 * Create an array representing many instances of this component, for use in a
 * tinier model.
 * @param {Object} component - Tinier component.
 * @return {Object}
 */
function arrayOf(component) {
  return tagType(ARRAY_OF, { component: component });
}

function defaultShouldUpdate(_ref8) {
  var state = _ref8.state,
      lastState = _ref8.lastState;

  return state !== lastState;
}

function checkInputs(options, defaults) {
  mapValues(options, function (_, k) {
    if (!(k in defaults)) {
      console.error('Unexpected argument ' + k);
    }
  });
}

function patchInitNoArg(init) {
  return function () {
    if (arguments.length === 0) {
      return init({});
    } else if (arguments.length > 1 || !isObject(arguments.length <= 0 ? undefined : arguments[0])) {
      throw new Error('Reducers can only take 1 or 0 arguments, and the ' + 'argument should be an object.');
    } else {
      return init(arguments.length <= 0 ? undefined : arguments[0]);
    }
  };
}

function patchReducersOneArg(reducers) {
  return mapValues(reducers, function (reducer, name) {
    return function () {
      if (arguments.length !== 1 || !isObject(arguments.length <= 0 ? undefined : arguments[0])) {
        throw new Error('Reducers can only take 1 arguments, and the ' + 'argument should be an object.');
      } else if (!('state' in (arguments.length <= 0 ? undefined : arguments[0]))) {
        throw new Error('The argument to the reducer must have a "state" ' + 'attribute.');
      } else {
        return reducer(arguments.length <= 0 ? undefined : arguments[0]);
      }
    };
  });
}

/**
 * Create a tinier component.
 * @param {Object} componentArgs - Functions defining the Tinier component.
 * @param {str} componentArgs.displayName - A name for the component.
 * @param {[str]} componentArgs.signals - An array of signal names.
 * @param {Object} componentArgs.model - The model object.
 * @param {Function} componentArgs.init - A function to initialize the state.
 * @param {Object} componentArgs.reducers -
 * @param {Object} componentArgs.methods -
 * @param {Function} componentArgs.willMount -
 * @param {Function} componentArgs.didMount -
 * @param {Function} componentArgs.shouldUpdate - Return true if the component
 *                                                should update, false if it
 *                                                should not, or null to use to
 *                                                default behavior (update when
 *                                                state changes).
 * @param {Function} componentArgs.willUpdate -
 * @param {Function} componentArgs.didUpdate -
 * @param {Function} componentArgs.willUnmount -
 * @param {Function} componentArgs.render -
 * @returns {Object} A tinier component.
 */
function createComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // default attributes
  var defaults = {
    displayName: '',
    signalNames: [],
    signalSetup: noop,
    model: {},
    init: constant({}),
    reducers: {},
    methods: {},
    willMount: noop,
    didMount: noop,
    shouldUpdate: defaultShouldUpdate,
    willUpdate: noop,
    didUpdate: noop,
    willUnmount: noop,
    render: noop
  };
  // check inputs
  checkInputs(options, defaults);

  if ('init' in options) {
    options.init = patchInitNoArg(options.init);
  }

  if ('reducers' in options) {
    options.reducersRaw = options.reducers;
    options.reducers = patchReducersOneArg(options.reducers);
  }

  // check model
  if (options.model && checkType(COMPONENT, options.model)) {
    throw new Error('The model cannot be another Component. The top level of ' + 'the model should be an array or an object literal');
  }
  // set defaults & tag
  return tagType(COMPONENT, _extends({}, defaults, options));
}

function patchReducersWithState(address, component, callReducer) {
  return mapValues(component.reducersRaw, function (reducer, name) {
    return function () {
      if (arguments.length === 0) {
        callReducer(address, component, reducer, {}, name);
      } else if (arguments.length > 1 || !isObject(arguments.length <= 0 ? undefined : arguments[0])) {
        throw new Error('Reducers can only take 1 or 0 arguments, and the ' + 'argument should be an object.');
      } else {
        callReducer(address, component, reducer, arguments.length <= 0 ? undefined : arguments[0], name);
      }
    };
  });
}

function patchSignals(address, component, callSignal) {
  return fromPairs(component.signalNames.map(function (signalName) {
    return [signalName, { call: function call(arg) {
        return callSignal(address, signalName, arg);
      } }];
  }));
}

/**
 * Return an object of functions that call the methods with component-specific
 * arguments.
 */
function patchMethods(address, component, callMethod, reducers, signals) {
  var methods = mapValues(component.methods, function (method) {
    return function (arg) {
      if (typeof Event !== 'undefined' && arg instanceof Event) {
        callMethod(address, method, signals, methods, reducers, this, arg, {});
      } else {
        callMethod(address, method, signals, methods, reducers, null, null, arg);
      }
    };
  });
  return methods;
}

function makeCallMethod(stateTree, opts) {
  /**
   * Call a method on the local stateTree
   * @param address
   * @param method
   * @param signals
   * @param methods - Patched method functions.
   * @param reducers - Patched reducer functions.
   * @param target - The value of this in the called function.
   * @param event - The event at the time of the function call.
   * @param arg - An argument object.
   */
  return function (address, method, signals, methods, reducers, target, event, arg) {
    // check for uninitialized stateTree
    if (stateTree.get([]) === null) {
      throw new Error('Cannot call method before the app is initialized (e.g. ' + 'in signalSetup).');
    }
    // get the local state
    var localState = stateTree.get(address);
    // run the method
    method(_extends({ state: localState, signals: signals, methods: methods, reducers: reducers, target: target, event: event
    }, arg));
  };
}

/**
 * Return a callSignal function.
 */
function makeCallSignal(signals, opts) {
  return function (address, signalName, arg) {
    if (opts.verbose) {
      console.log('Called signal ' + signalName + ' at [' + address.join(', ') + '].');
    }
    signals.get(address).data.signals[signalName].call(arg);
  };
}

/**
 * Return a new callReducer function.
 * @param {Object} topComponent - The top-level component.
 * @param {Object} stateTree - The global stateTree.
 * @param {Object} bindingTree - The global bindingTree.
 * @param {Object} signalTree - The global signalTree.
 * @param {Object} stateCallers - An object with functions callMethod,
 *                                callSignal, and callReducer.
 * @param {Object} opts - Options from `run`.
 * @returns {Function} - Call a reducer on the local state
 *   @param {Array} address - A location, as an array of keys (strings and
 *                            integers).
 *   @param {Object} triggeringComponent -
 *   @param {Function} reducer - A reducer.
 *   @param {Object} arg - An argument object.
 *   @param {String} name - The name of the reducer (for logging).
 */
function makeCallReducer(topComponent, stateTree, bindingTree, signalTree, stateCallers, opts) {
  return function (address, triggeringComponent, reducer, arg, name) {
    if (!isFunction(reducer)) {
      throw new Error('Reducer ' + name + ' is not a function');
    }
    // Run the reducer, and optionally log the result.
    var localState = stateTree.get(address);
    var newLocalState = reducer(_extends({}, arg, { state: localState }));
    if (opts.verbose) {
      console.log('Called reducer ' + name + ' for ' + triggeringComponent.displayName + ' at [' + address.join(', ') + '].');
      console.log(localState);
      console.log(newLocalState);
    }

    // Check that the new state is valid. If not, throw an Error, and the new
    // state will be thrown out.
    checkState(triggeringComponent.model, newLocalState);

    // Set the state with immutable objects and arrays. A reference to oldState
    // will used for diffing.
    var lastState = stateTree.get([]);
    stateTree.set(address, newLocalState);

    // Run diffWithModelMin, which will do a few things:
    // 1. Run shouldUpdate for every component in the tree.
    // 2. Return the information about the minimal tree to update with
    //    updateComponents (whenever shouldUpdate is true) as minUpdate.
    // 3. Return the information about the minimal tree to update with
    //    mergeSignals (whenever nodes are added or deleted) as minSignals.
    // The output objects have the attributes diff, modelNode, and address.
    // TODO might be best to go back to returning just one full diff here

    var _diffWithModelMin = diffWithModelMin(topComponent, stateTree.get([]), lastState, [], address),
        minSignals = _diffWithModelMin.minSignals,
        minUpdate = _diffWithModelMin.minUpdate;

    // Update the signals.


    var localSignals = signalTree.get(minSignals.address);
    var newSignals = mergeSignals(minSignals.modelNode, minSignals.address, minSignals.diff, localSignals, stateCallers);
    signalTree.set(minSignals.address, newSignals);

    // Update the components.
    var minUpdateBindings = bindingTree.get(minUpdate.address);
    var minUpdateEl = minUpdateBindings.data;
    var minUpdateState = stateTree.get(minUpdate.address);
    var newBindings = updateComponents(minUpdate.address, minUpdate.modelNode, minUpdateState, minUpdate.diff, minUpdateBindings, minUpdateEl, stateCallers, opts);
    bindingTree.set(minUpdate.address, newBindings);
  };
}

/**
 * Return an object with functions callMethod, callSignal, and callReducer.
 * @param {Object} component - The top-level component.
 * @param {Object} stateTree - The global stateTree.
 * @param {Object} bindingTree - The global bindings.
 * @param {Object} signalTree - The global signalTree.
 * @return {Object} An object with functions callMethod, callSignal, and
 *                  callReducer.
 */
function makeStateCallers(component, stateTree, bindingTree, signalTree, opts) {
  var stateCallers = {};
  stateCallers.callMethod = makeCallMethod(stateTree, opts);
  stateCallers.callSignal = makeCallSignal(signalTree, opts);
  stateCallers.callReducer = makeCallReducer(component, stateTree, bindingTree, signalTree, stateCallers, opts);
  return stateCallers;
}

/**
 * Run a tinier component.
 * @param {Object} component - A tinier component.
 * @param {*} appEl - An element to pass to the component's create, update, and
 *                    destroy methods.
 * @param {Object|null} initialState - The initial state. If null, then init()
 *                                     will be called to initialize the state.
 * @return {Object} The API functions, incuding getState, signals, and methods.
 */
function run(component, appEl) {
  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // Create variables that will store the state for the whole lifetime of the
  // application. Similar to the redux model.
  var stateTree = makeTree(null, false);
  var topBinding = tagType(NODE, { data: appEl, children: null });
  var bindingTree = makeTree(topBinding, true);
  var signalTree = makeTree(null, true);

  // functions that access state, signals, and bindings
  var stateCallers = makeStateCallers(component, stateTree, bindingTree, signalTree, opts);

  // make sure initial state is valid
  // TODO LEFT OFF ... does this work?
  // Q: Does the state for a child component need to be defined? Are we checking
  // all the way down the line?
  var initialState = 'initialState' in opts ? opts.initialState : component.init();

  // first draw
  var setStateReducer = function setStateReducer(_ref9) {
    var newState = _ref9.newState;
    return newState;
  };
  var setState = function setState(newState) {
    return stateCallers.callReducer([], component, setStateReducer, { newState: newState }, 'setState');
  };
  setState(initialState);

  // return API
  var getState = function getState() {
    return stateTree.get([]);
  };
  // TODO check state
  var setStateNoRender = function setStateNoRender(newState) {
    return stateTree.set([], newState);
  };
  var reducers = patchReducersWithState([], component, stateCallers.callReducer);
  var signalsCall = patchSignals([], component, stateCallers.callSignal);
  var methods = patchMethods([], component, stateCallers.callMethod, reducers, signalsCall);
  // if state is null, then data will be null
  var signals = get(signalTree.get([]).data, 'signals');

  return { setState: setState, setStateNoRender: setStateNoRender, getState: getState, reducers: reducers, methods: methods, signals: signals };
}

// -------------------------------------------------------------------
// DOM
// -------------------------------------------------------------------

// constants
var BINDING = exports.BINDING = '@TINIER_BINDING';
var ELEMENT = exports.ELEMENT = '@TINIER_ELEMENT';
var LISTENER_OBJECT = '@TINIER_LISTENERS';

function reverseObject(obj) {
  var newObj = {};
  for (var k in obj) {
    newObj[obj[k]] = k;
  }
  return newObj;
}

// some attribute renaming as seen in React
var ATTRIBUTE_RENAME = {};
var ATTRIBUTE_RENAME_REV = reverseObject(ATTRIBUTE_RENAME);
var ATTRIBUTE_APPLY = {
  checked: function checked(el, name) {
    var val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (name !== 'input') {
      throw new Error('"checked" attribute is only supported on input elements.');
    }
    el.checked = val;
  },
  value: function value(el, name) {
    var val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (['input', 'textarea'].indexOf(name) === -1) {
      throw new Error('"value" attribute is only supported on input and ' + 'textarea elements.');
    }
    el.value = val;
  }
};

// namespace management inspired by of D3.js, Mike Bostock, BSD license
var NAMESPACES = {
  svg: 'http://www.w3.org/2000/svg',
  xhtml: 'http://www.w3.org/1999/xhtml',
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace',
  xmlns: 'http://www.w3.org/2000/xmlns/'
};

/**
 * Turn an array of objects into a new object of objects where the keys are
 * given by the value of `key` in each child object.
 * @param {[Object]} arr - The array of objects.
 * @param {String} key - The key to look for.
 */
function keyBy(arr, key) {
  var obj = {};
  arr.map(function (x) {
    return obj[x[key]] = x;
  });
  return obj;
}

/**
 *
 */
function addressToObj(address, val) {
  // If address is []
  if (isUndefined(address[0])) {
    return val;
  }
  var f = address[0];
  if (isString(f)) {
    var _ref10;

    return _ref10 = {}, _ref10[f] = addressToObj(address.slice(1), val), _ref10;
  } else {
    var ar = Array(f + 1);
    ar[f] = addressToObj(address.slice(1), val);
    return ar;
  }
}

function objectForBindingsArray(bindings) {
  // Check arrays and find longest internal array.
  var longest = 0;
  for (var j = 0, l = bindings.length; j < l; j++) {
    var binding = bindings[j];
    if (!isArray(binding)) {
      throw Error('Incompatible bindings: mix of types');
    }
    var len = binding.length;
    if (len > longest) {
      longest = len;
    }
  }
  var acc = [];
  for (var i = 0; i < longest; i++) {
    for (var _j = 0, _l = bindings.length; _j < _l; _j++) {
      var _binding = bindings[_j];
      if (_binding[i] != null) {
        // not null or undefined
        if (acc[i] != null) {
          // not null or undefined
          acc[i] = objectForBindings([_binding[i], acc[i]]);
        } else {
          acc[i] = _binding[i];
        }
      }
    }
  }
  return acc;
}

function objectForBindingsObject(bindings) {
  return bindings.reduce(function (acc, binding) {
    if (isArray(binding)) throw Error('Incompatible bindings: mix of types');
    for (var k in binding) {
      if (binding[k]) {
        if (acc[k]) {
          acc[k] = objectForBindings([binding[k], acc[k]]);
        } else {
          acc[k] = binding[k];
        }
      }
    }
    return acc;
  }, {});
}

function objectForBindings(bindings) {
  return isArray(bindings[0]) ? objectForBindingsArray(bindings) : objectForBindingsObject(bindings);
}

// Make sure default is null so undefined type constant do not match
var isTinierBinding = function isTinierBinding(obj) {
  return checkType(BINDING, obj);
};
var isTinierElement = function isTinierElement(obj) {
  return checkType(ELEMENT, obj);
};

/**
 * Returns true if it is a DOM element.
 * http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
 */
function isElement(o) {
  return o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
}

/**
 * Returns true if it is a DOM text element.
 */
function isText(o) {
  return o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && o !== null && o.nodeType === 3 && typeof o.nodeName === 'string';
}

/**
 * Create a new TinierDOM element.
 * @param {String} tagName - The name for the element.
 * @param {Object|null} attributesIn - The attributes. Note that JSX will pass
 *                                     null in when there are no attributes. In
 *                                     the resulting object, this will be an
 *                                     empty object {}.
 * @param {Object[]|Object|String} ...children - A single binding or a mix of
 *                                               elements and strings.
 * @return {Object} A TinierDOM element.
 */
function createElement(tagName, attributesIn) {
  for (var _len3 = arguments.length, children = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    children[_key3 - 2] = arguments[_key3];
  }

  var attributes = attributesIn == null ? {} : attributesIn;
  return tagType(ELEMENT, { tagName: tagName, attributes: attributes, children: children });
}

/**
 * Create a new TinierDOM binding.
 * @param {Array|String|Number} addressIn - An address array, or single key or
 *                                          index.
 * @return {Object} A TinierDOM binding.
 */
function bind(addressIn) {
  var address = isArray(addressIn) ? addressIn : [addressIn];
  return tagType(BINDING, { address: address });
}

function explicitNamespace(name) {
  var i = name.indexOf(':');
  if (i !== -1) {
    var prefix = name.slice(0, i);
    if (prefix in NAMESPACES) {
      // for xmlns, treat the whole name (e.g. xmlns:xlink) as the name
      var newName = prefix === 'xmlns' ? name : name.slice(i + 1);
      return { name: newName, explicit: NAMESPACES[prefix] };
    } else {
      return { name: name, explicit: null };
    }
  } else {
    return { name: name, explicit: null };
  }
}

/**
 * Create a DOM element, inheriting namespace or choosing one based on tag.
 * @param {Object} tinierEl - A TinierDOM element.
 * @param {Object} parent - The parent el.
 * @return {Object} The DOM element.
 */
function createDOMElement(tinierEl, parent) {
  var tag = tinierEl.tagName;

  var _explicitNamespace = explicitNamespace(tag),
      name = _explicitNamespace.name,
      explicit = _explicitNamespace.explicit;

  var ns = explicit !== null ? explicit : tag in NAMESPACES ? NAMESPACES[tag] : parent.namespaceURI;
  var el = ns === NAMESPACES.xhtml ? document.createElement(name) : document.createElementNS(ns, name);
  return updateDOMElement(el, tinierEl);
}

function getStyles(cssText) {
  var reg = /([^:; ]+):/g;
  var res = [];
  var ar = void 0;
  while ((ar = reg.exec(cssText)) !== null) {
    res.push(ar[1]);
  }
  return res;
}

function toCamelCase(name) {
  return name
  // Uppercase the first character in each group immediately following a dash
  .replace(/-(.)/g, function (m) {
    return m.toUpperCase();
  })
  // Remove dashes
  .replace(/-/g, '');
}

function stripOn(name) {
  return name.slice(2).toLowerCase();
}

function setAttributeCheckBool(namespace, el, name, val) {
  // set boolean appropriately
  var valToSet = val === true ? name : val;
  if (namespace === NAMESPACES.xhtml) {
    el.setAttribute(name, valToSet);
  } else {
    el.setAttributeNS(namespace, name, valToSet);
  }
}

/**
 * Update the DOM element to match a TinierDOM element.
 * @param {Element} el - An existing DOM element.
 * @param {Object} tinierEl - A TinierDOM element.
 */
function updateDOMElement(el, tinierEl) {
  var thenFn = null;
  var parentNamespace = el.namespaceURI;

  // remove event listeners first, because they cannot simply be replaced
  if (el.hasOwnProperty(LISTENER_OBJECT)) {
    mapValues(el[LISTENER_OBJECT], function (onFn, name) {
      el.removeEventListener(name, onFn);
    });
    delete el[LISTENER_OBJECT];
  }

  // Update the attributes.
  // TODO is it faster to check first, or set first?
  mapValues(tinierEl.attributes, function (v, k) {
    if (k === 'id') {
      // ID is set directly
      el.id = v;
    } else if (k === 'style' && !isString(v)) {
      // For a style object. For a style string, use setAttribute below.
      mapValues(v, function (sv, sk) {
        el.style.setProperty(sk, sv);
      });
    } else if (k.indexOf('on') === 0) {
      // Special handling for listeners
      if (!el.hasOwnProperty(LISTENER_OBJECT)) {
        el[LISTENER_OBJECT] = {};
      }
      // allow null
      if (v !== null) {
        var name = stripOn(k);
        if (!isFunction(v) && v !== null) {
          throw new Error(v + ' is not a function.');
        }
        el[LISTENER_OBJECT][name] = v;
        el.addEventListener(name, v);
      }
    } else if (k in ATTRIBUTE_RENAME) {
      // By default, set the attribute.
      var _explicitNamespace2 = explicitNamespace(k),
          _name = _explicitNamespace2.name,
          explicit = _explicitNamespace2.explicit;

      setAttributeCheckBool(explicit !== null ? explicit : parentNamespace, el, ATTRIBUTE_RENAME[explicit], v);
    } else if (k in ATTRIBUTE_APPLY) {
      ATTRIBUTE_APPLY[k](el, tinierEl.tagName, v);
    } else if (k === 'then') {
      if (v !== null) {
        if (!isFunction(v)) {
          throw new Error(v + ' is not a function or null.');
        }
        thenFn = v;
      }
    } else {
      // By default, set the attribute.
      var _explicitNamespace3 = explicitNamespace(k),
          _name2 = _explicitNamespace3.name,
          _explicit = _explicitNamespace3.explicit;

      setAttributeCheckBool(_explicit !== null ? _explicit : parentNamespace, el, _name2, v);
    }
  });
  // Delete attributes if not provided. First, loop through this attributes
  // object to get a nice array.
  var attributeNames = [];
  for (var i = 0, l = el.attributes.length; i < l; i++) {
    attributeNames.push(el.attributes[i].name);
  }
  attributeNames.filter(function (k) {
    return !(k in tinierEl.attributes) || tinierEl.attributes[k] === false;
  }).map(function (k) {
    if (k in ATTRIBUTE_RENAME_REV) {
      el.removeAttribute(ATTRIBUTE_RENAME_REV[k]);
    } else if (k in ATTRIBUTE_APPLY) {
      ATTRIBUTE_APPLY[k](el, tinierEl.tagName);
    } else {
      el.removeAttribute(k);
    }
  });
  // Delete styles if not provided.
  var tStyle = tinierEl.attributes.style;
  if (tStyle && !isString(tStyle)) {
    getStyles(el.style.cssText).filter(function (a) {
      return !(a in tStyle || toCamelCase(a) in tStyle);
    }).map(function (a) {
      return el.style.removeProperty(a);
    });
  }

  // call the callback
  if (thenFn) {
    defer(function () {
      return thenFn(el);
    });
  }

  return el;
}

/**
* flatten the elements array
*/
function flattenElementsAr(ar) {
  return ar.reduce(function (acc, el) {
    return isArray(el) ? [].concat(acc, el) : [].concat(acc, [el]);
  }, []).filter(notNull); // null means ignore
}

function removeExtraNodes(container, length) {
  for (var i = container.childNodes.length - 1; i >= length; i--) {
    container.removeChild(container.childNodes[i]);
  }
}

/**
 * Render the given element tree into the container.
 * @param {Element} container - A DOM element that will be the container for
 *                              the renedered element tree.
 * @param {...[Object|String]|Object|String} tinierElementsAr -
 *   Any number of TinierDOM elements or strings that will be rendered.
 * @return {Object} A nested data structure of bindings for use in Tinier.
 */
function render(container) {
  // check arguments
  if (!isElement(container)) {
    throw new Error('First argument must be a DOM Element.');
  }

  for (var _len4 = arguments.length, tinierElementsAr = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    tinierElementsAr[_key4 - 1] = arguments[_key4];
  }

  var tinierElements = flattenElementsAr(tinierElementsAr);

  var first = get(tinierElements, 0);
  if (isTinierBinding(first)) {
    if (tinierElements.length !== 1) {
      throw new Error('A binding cannot have siblings in TinierDOM. ' + 'At binding: [ ' + first.address.join(', ') + ' ].');
    }
    return objectForBindings([addressToObj(first.address, container)]);
  }

  // get the children with IDs
  var childrenWithKeys = Array.from(container.children).filter(function (c) {
    return c.id;
  });
  var elementsByID = keyBy(childrenWithKeys, 'id');

  // render each element
  var bindingsAr = tinierElements.map(function (tinierEl, i) {
    // If an element if a binding, then there can only be one child.
    if (isUndefined(tinierEl)) {
      // cannot be undefined
      throw new Error('Children in Tinier Elements cannot be undefined.');
    } else if (isTinierElement(tinierEl)) {
      // container.childNodes is a live collection, so get the current node at
      // this index.
      var el = container.childNodes[i];
      // tinierEl is a TinierDOM element.
      if (tinierEl.attributes.id in elementsByID) {
        // el exist, then check for a matching node by ID
        var movedEl = elementsByID[tinierEl.attributes.id];
        if (el) {
          // if match and existing el, then replace the element
          container.replaceChild(movedEl, el);
        } else {
          // if match and el is undefined, then append the element
          container.appendChild(movedEl);
        }
        // then render children
        return render.apply(undefined, [movedEl].concat(tinierEl.children));
      } else if (el) {
        // both defined, check type and id
        if (el.tagName && el.tagName.toLowerCase() === tinierEl.tagName.toLowerCase()) {
          // matching tag, then update the node to match. Be aware that existing
          // nodes with IDs might get moved, so we should clone them?
          var elToUpdate = el.id ? el.cloneNode(true) : el;
          updateDOMElement(elToUpdate, tinierEl);
          if (el.id) container.replaceChild(elToUpdate, el);
          return render.apply(undefined, [elToUpdate].concat(tinierEl.children));
        } else {
          // not a matching tag, then replace the element with a new one
          var newEl = createDOMElement(tinierEl, container);
          container.replaceChild(newEl, el);
          return render.apply(undefined, [newEl].concat(tinierEl.children));
        }
      } else {
        // no el and no ID match, then add a new Element or string node
        var newEl2 = createDOMElement(tinierEl, container);
        container.appendChild(newEl2);
        return render.apply(undefined, [newEl2].concat(tinierEl.children));
      }
      // There should not be any bindings here
    } else if (isTinierBinding(tinierEl)) {
      throw new Error('A binding cannot have siblings in TinierDOM. ' + 'At binding: [ ' + tinierEl.address.join(', ') + ' ].');
    } else {
      var _el = container.childNodes[i];
      var s = String(tinierEl);
      // This should be a text node.
      if (isText(_el)) {
        // If already a text node, then set the text content.
        _el.textContent = s;
      } else if (_el) {
        // If not a text node, then replace it.
        container.replaceChild(document.createTextNode(s), _el);
      } else {
        // If no existing node, then add a new one.
        container.appendChild(document.createTextNode(s));
      }
      // No binding here.
      return null;
    }
  });

  // remove extra nodes
  // TODO This should not run if the child is a binding. Make a test for
  // this. When else should it not run?
  removeExtraNodes(container, tinierElements.length);

  // bindings array to object
  return objectForBindings(bindingsAr.filter(function (b) {
    return b !== null;
  }));
}

// export API
exports.default = {
  arrayOf: arrayOf, objectOf: objectOf, createComponent: createComponent, run: run, bind: bind, createElement: createElement, render: render
};
//# sourceMappingURL=tinier.js.map