{"version":3,"sources":["../src/tinier.js"],"names":["noop","constant","val","identity","last","array","length","tail","slice","head","fromPairs","pairs","reduce","accum","_ref","_extends2","key","_extends","get","object","property","hasOwnProperty","isUndefined","isObject","_typeof","isArray","Array","isString","v","isNumber","isBoolean","isFunction","notNull","mapValues","obj","fn","newObj","reduceValues","init","zipArrays","arrays","lenLongest","Math","max","apply","filter","x","map","a","res","_loop","i","push","zipObjects","objects","len","allKeys","k","filterValues","out","value","any","ar","l","Error","defer","setTimeout","tagType","type","checkType","NULL","match","fns","defaultFn","arguments","undefined","throwUnrecognizedType","ARRAY","OBJECT","node","hasChildren","_match","ARRAY_OF","OBJECT_OF","COMPONENT","Object","keys","checkRenderResultRecurse","userBindings","state","_match2","updateRecurse","s","u","recurse","n","objOf","arOf","component","checkRenderResult","updateEl","address","diffVal","lastRenderedEl","el","stateCallers","opts","reducers","patchReducersWithState","callReducer","signals","patchSignals","callSignal","methods","patchMethods","callMethod","arg","DESTROY","render","displayName","join","willUnmount","bindings","shouldUpdate","CREATE","UPDATE","willMount","willUpdate","verbose","console","log","model","didMount","didUpdate","dropNodes","tree","_match3","NODE","data","updateComponents","diff","renderResult","_match4","_ref2","d","newAddress","addressWith","b","r","nextRenderResult","children","addressEqual","a1","a2","treeGet","treeSet","_extends3","_head","rest","concat","treeSetMutable","_tail","parent","makeTree","mutable","set","checkState","modelNode","newState","_match5","o","computeDiffValue","lastState","isValidFn","triggeringAddress","stateValid","lastStateValid","same","componentTriggeredUpdate","diffWithModel","_match6","assign","_","longest","singleOrAll","minTreeAr","getMin","indices","nonNullIndices","minSignals","minUpdate","update","diffWithModelMin","makeSignal","_onFns","on","call","_len","args","_key","makeOneSignalAPI","isCollection","_callFns","_len2","_key2","_ref3","onName","index","argObject","makeSignalsAPI","signalNames","name","makeChildSignalsAPI","_match7","reduceChildren","_match8","runSignalSetup","signalsAPI","childSignalsAPI","signalSetup","childSignals","mergeSignals","diffNode","signalNode","_match9","upChild","upAddress","_ref4","_reduceChildren","hasCreated","destroyed","childAddress","childSignalsAPINode","_ref6","newUpChild","newUpAddress","_ret2","_runSignalSetup","_ref5","callbackObj","upCallbackObj","signal","_ref7","objectOf","arrayOf","defaultShouldUpdate","_ref8","checkInputs","options","defaults","error","patchInitNoArg","patchReducersOneArg","reducer","createComponent","reducersRaw","signalName","method","Event","this","makeCallMethod","stateTree","target","event","localState","makeCallSignal","makeCallReducer","topComponent","bindingTree","signalTree","triggeringComponent","newLocalState","_diffWithModelMin","localSignals","newSignals","minUpdateBindings","minUpdateEl","minUpdateState","newBindings","makeStateCallers","run","appEl","topBinding","initialState","setStateReducer","_ref9","setState","getState","setStateNoRender","signalsCall","reverseObject","keyBy","arr","addressToObj","f","_ref10","objectForBindingsArray","j","binding","acc","objectForBindings","objectForBindingsObject","isElement","nodeType","nodeName","isText","createElement","tagName","attributesIn","_len3","_key3","attributes","ELEMENT","bind","addressIn","BINDING","explicitNamespace","indexOf","prefix","NAMESPACES","newName","explicit","createDOMElement","tinierEl","tag","_explicitNamespace","ns","namespaceURI","xhtml","document","createElementNS","updateDOMElement","getStyles","cssText","reg","exec","toCamelCase","replace","m","toUpperCase","stripOn","toLowerCase","setAttributeCheckBool","namespace","valToSet","setAttribute","setAttributeNS","thenFn","parentNamespace","LISTENER_OBJECT","onFn","removeEventListener","id","addEventListener","ATTRIBUTE_RENAME","_explicitNamespace2","ATTRIBUTE_APPLY","_explicitNamespace3","sv","sk","style","setProperty","attributeNames","ATTRIBUTE_RENAME_REV","removeAttribute","tStyle","removeProperty","flattenElementsAr","removeExtraNodes","container","childNodes","removeChild","_len4","tinierElementsAr","_key4","tinierElements","first","isTinierBinding","childrenWithKeys","from","c","elementsByID","bindingsAr","isTinierElement","movedEl","replaceChild","appendChild","elToUpdate","cloneNode","newEl","newEl2","String","textContent","createTextNode","STRING","NUMBER","BOOLEAN","ANY","NO_ARGUMENT","TOP","checked","svg","xlink","xml","xmlns"],"mappings":"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","file":"lib/tinier.min.js","sourcesContent":["/** @module tinier */\n\n// constants\nexport const ARRAY_OF    = '@TINIER_ARRAY_OF'\nexport const OBJECT_OF   = '@TINIER_OBJECT_OF'\nexport const COMPONENT   = '@TINIER_COMPONENT'\nexport const ARRAY       = '@TINIER_ARRAY'\nexport const OBJECT      = '@TINIER_OBJECT'\nexport const NODE        = '@TINIER_NODE'\nexport const NULL        = '@TINIER_NULL'\nexport const STRING      = '@TINIER_STRING'\nexport const NUMBER      = '@TINIER_NUMBER'\nexport const BOOLEAN     = '@TINIER_BOOLEAN'\nexport const ANY         = '@TINIER_ANY'\nexport const NO_ARGUMENT = '@TINIER_NO_ARGUMENT'\nexport const TOP         = '@TINIER_TOP'\nexport const CREATE      = '@TINIER_CREATE'\nexport const UPDATE      = '@TINIER_UPDATE'\nexport const DESTROY     = '@TINIER_DESTROY'\n\n// basic functions\nfunction noop () {}\n\nfunction constant (val) {\n  return () => val\n}\n\nfunction identity (val) {\n  return val\n}\n\nfunction last (array) {\n  return array[array.length - 1]\n}\n\nexport function tail (array) {\n  return [ array.slice(0, -1), last(array) ]\n}\n\nexport function head (array) {\n  return [ array[0], array.slice(1) ]\n}\n\nexport function fromPairs (pairs) {\n  return pairs.reduce((accum, [ key, val ]) => {\n    return { ...accum, [key]: val }\n  }, {})\n}\n\n/**\n * Get the property of the object or index of the array, or return the default\n * value.\n * @param {Object|Array} object - An object or array.\n * @param {String} property - An property of the object.\n * @return {*} The value of the property or, if not present, the default value.\n */\nexport function get (object, property) {\n  return (object &&\n          typeof object !== 'string' &&\n          object.hasOwnProperty(property)) ? object[property] : null\n}\n\nexport function isUndefined (object) {\n  return typeof object === 'undefined'\n}\n\n/**\n * Check if the value is an object with enumerable properties. Also returns true\n * for arrays.\n * @param {*} value - The value to test.\n * @return {Boolean}\n */\nexport function isObject (object) {\n  return object != null && (typeof object === 'object')\n}\n\n/**\n * Check if the object is an array\n * @param {*} object - The object to test.\n * @return {Boolean}\n */\nexport function isArray (object) {\n  return Array.isArray(object)\n}\n\nexport function isString (v) {\n  return typeof v === 'string'\n}\n\nexport function isNumber (v) {\n  return typeof v === 'number'\n}\n\nexport function isBoolean (v) {\n  return typeof v === 'boolean'\n}\n\n/**\n * Check if the object is a function.\n * @param {*} object - The object to test.\n * @return {Boolean}\n */\nexport function isFunction (object) {\n  return typeof(object) === 'function'\n}\n\nexport function notNull (val) {\n  return val !== null\n}\n\n/**\n * Iterate over the keys and values of an object. Uses Object.keys to find\n * iterable keys.\n * @param {Object} obj - The input object.\n * @param {Function} fn - A function that takes the arguments (value, key).\n * @return {Object} A transformed object with values returned by the function.\n */\nexport function mapValues (obj, fn) {\n  const newObj = {}\n  for (let key in obj) {\n    newObj[key] = fn(obj[key], key)\n  }\n  return newObj\n}\n\nexport function reduceValues (obj, fn, init) {\n  let accum = init\n  for (let key in obj) {\n    accum = fn(accum, obj[key], key)\n  }\n  return accum\n}\n\nexport function zipArrays (arrays) {\n  const lenLongest = Math.max.apply(null, arrays.filter(x => x !== null).map(a => a.length))\n  const res = []\n  for (let i = 0; i < lenLongest; i++) {\n    res.push(arrays.map(a => a !== null && i < a.length ? a[i] : null))\n  }\n  return res\n}\n\nexport function zipObjects (objects) {\n  const len = objects.length\n  // find all the keys\n  const allKeys = {}\n  for (let i = 0; i < len; i++) {\n    const object = objects[i]\n    if (object === null) {\n      continue\n    }\n    for (let k in object) {\n      allKeys[k] = true\n    }\n  }\n  // make new object\n  const res = {}\n  for (let key in allKeys) {\n    res[key] = Array(len)\n    for (let i = 0; i < len; i++) {\n      const object = objects[i]\n      res[key][i] = get(object, key)\n    }\n  }\n  return res\n}\n\nexport function filterValues (object, fn) {\n  const out = {}\n  for (let key in object) {\n    const value = object[key]\n    if (fn(value, key)) out[key] = value\n  }\n  return out\n}\n\n/**\n * Lazy any function.\n * @param {[Boolean]}\n * @return {Boolean}\n */\nexport function any (ar) {\n  for (let i = 0, l = ar.length; i < l; i++) {\n    const val = ar[i]\n    if (!isBoolean(val)) {\n      throw new Error('Not a boolean: ' + val)\n    }\n    if (val) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Defers calling fn until the current process finishes.\n */\nfunction defer (fn) {\n  setTimeout(fn, 1)\n}\n\n/**\n * Adds a tag to the object.\n */\nexport function tagType (type, obj) {\n  if (!isString(type)) {\n    throw new Error('First argument must be a string')\n  }\n  if (!isObject(obj)) {\n    throw new Error('Second argument must be an object')\n  }\n  obj.type = type\n  return obj\n}\n\nexport function checkType (type, obj) {\n  if (obj === null) {\n    return type === NULL\n  }\n  if (typeof type !== 'string') {\n    throw new Error('First argument must be a string')\n  }\n  if (isUndefined(obj)) {\n    throw new Error('Bad second argument')\n  }\n  return get(obj, 'type') === type\n}\n\n/**\n * Basic pattern matching.\n * @param {Object|null} object - An object generated with tagType, an object, an\n *                               array, or null.\n * @param {Object} fns - An object with types for keys and functions for values.\n *                       Also accepts keys tinier.OBJECT, tinier.ARRAY, and\n *                       tinier.NULL. To avoid conflict, tinier.OBJECT has the\n *                       lowest priority.\n * @param {Function} defaultFn - A function to run if the object type is not\n *                               found. Takes `object` as a single argument.\n * @return {*} Return value from the called function.\n */\nexport function match (object, fns, defaultFn = throwUnrecognizedType) {\n  for (let key in fns) {\n    if ((key === NULL   && object === null ) ||\n        (key === ARRAY  && isArray(object) ) ||\n        (isObject(object) && checkType(key, object))) {\n      return fns[key](object)\n    }\n  }\n  if (OBJECT in fns && isObject(object)) {\n    return fns[OBJECT](object)\n  }\n  return defaultFn(object)\n}\n\nfunction throwUnrecognizedType (node) {\n  throw new Error('Unrecognized type in pattern matching: ' + node)\n}\n\n// -------------------------------------------------------------------\n// Update components\n// -------------------------------------------------------------------\n\n/**\n * Determine whether the model has any child components.\n */\nexport function hasChildren (node) {\n  return match(\n    node,\n    {\n      [ARRAY_OF]: () => true,\n      [OBJECT_OF]: () => true,\n      [COMPONENT]: () => true,\n      [ARRAY]: node => any(node.map(hasChildren)),\n      [OBJECT]: node => any(Object.keys(node).map(k => hasChildren(node[k]))),\n    }\n  )\n}\n\nfunction checkRenderResultRecurse (userBindings, node, state) {\n  const updateRecurse = (s, k) => {\n    const u = k === null ? userBindings : get(userBindings, k)\n    if (userBindings !== null && u === null) {\n      throw new Error('Shape of the bindings object does not match the model.' +\n                      'Model: ' + node + '  Bindings object: ' + userBindings)\n    }\n  }\n  const recurse = (n, k) => {\n    checkRenderResultRecurse(get(userBindings, k), n, get(state, k))\n  }\n  match(\n    node,\n    {\n      [OBJECT_OF]: objOf => {\n        // check for extra attributes\n        if (userBindings !== null\n            && any(Object.keys(userBindings).map(k => !(k in state)))) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          mapValues(state, updateRecurse)\n        }\n      },\n      [ARRAY_OF]: arOf => {\n        // check array lengths\n        if (userBindings !== null && state.length !== userBindings.length) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          state.map(updateRecurse)\n        }\n      },\n      [COMPONENT]: component => updateRecurse(state, null),\n      [ARRAY]: ar => {\n        if (userBindings !== null && !isArray(userBindings)) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          ar.map(recurse)\n        }\n      },\n      [OBJECT]: obj => {\n        if (userBindings !== null && isArray(userBindings)) {\n          throw new Error('Shape of the bindings object does not match the ' +\n                          'model. Model: ' + node + ' Bindings object: ' +\n                          userBindings)\n        } else {\n          mapValues(obj, recurse)\n        }\n      }\n    }\n  )\n}\n\n/**\n * Check the result of render against the model and state.\n * @param {Object} node - A model node.\n * @param {*} state - A state node.\n * @param {Object} userBindings - The new bindings returned by render.\n * @return {Object} The userBindings object.\n */\nexport function checkRenderResult (userBindings, node, state) {\n  checkRenderResultRecurse(userBindings, node, state)\n  return userBindings\n}\n\n/**\n * Run lifecycle functions for the component.\n * @param {Object} address -\n * @param {Object} component -\n * @param {Object} state -\n * @param {Object} diffVal -\n * @param {Object|null} lastRenderedEl - The element rendered in previously, if\n *                                       there was one.\n * @param {Object|null} el - The element to render in provided by\n *                           component.render.\n * @param {Object} stateCallers -\n * @return {Object}\n */\nexport function updateEl (address, component, state, diffVal, lastRenderedEl, el,\n                          stateCallers, opts) {\n  // the object passed to lifecycle functions\n  const reducers = patchReducersWithState(address, component, stateCallers.callReducer)\n  const signals = patchSignals(address, component, stateCallers.callSignal)\n  const methods = patchMethods(address, component, stateCallers.callMethod,\n                               reducers, signals)\n  const arg = { state, methods, reducers, signals, el, lastRenderedEl }\n\n  // warn if the el is null\n  if (el === null && !(diffVal === DESTROY) && component.render !== noop) {\n    throw new Error('No binding provided for component ' + component.displayName\n                    + ' at [' + address.join(', ') + '].')\n  }\n\n  if (diffVal === DESTROY) {\n    // destroy\n    component.willUnmount(arg)\n    return { bindings: null, lastRenderedEl }\n  } else {\n    // create or update\n    const shouldUpdate = (diffVal === CREATE || diffVal === UPDATE ||\n                          el !== lastRenderedEl)\n\n    if      (diffVal === CREATE) component.willMount(arg)\n    else if (shouldUpdate)     component.willUpdate(arg)\n\n    if (opts.verbose && shouldUpdate) {\n      console.log('Rendering ' + component.displayName + ' at [' +\n                  address.join(', ') + '].')\n    }\n\n    // render\n    const bindings = shouldUpdate ?\n            checkRenderResult(component.render(arg), component.model, state) :\n            null\n    // check result\n    if (shouldUpdate && bindings === null && hasChildren(component.model)) {\n      throw new Error('The render function of component ' +\n                      component.displayName + ' did not return new bindings')\n    }\n\n    // These need to be asynchronous.\n    if (diffVal === CREATE) {\n      defer(() => component.didMount(arg))\n    } else if (shouldUpdate) {\n      defer(() => component.didUpdate(arg))\n    }\n\n    // If the component rendered, then change lastEl.\n    return { bindings, lastRenderedEl: shouldUpdate ? el : lastRenderedEl }\n  }\n}\n\n/**\n * For a tree, return everything down to the first set of NODES with data for\n * leaves.\n */\nfunction dropNodes (tree) {\n  return match(tree, {\n    [NODE]: node => node.data,\n    [OBJECT]: obj => mapValues(obj, dropNodes),\n    [ARRAY]: ar => ar.map(dropNodes),\n    [NULL]: () => null,\n  })\n}\n\n/**\n * Run create, update, and destroy for component.\n * @param {Array} address - The location of the component in the state.\n * @param {Object} node - A model or a node within a model.\n * @param {Object} diff - The diff object for this component.\n * @param {Object|null} bindings -\n * @param {Object|null} renderResult -\n * @param {Object} stateCallers -\n * @return {Object}\n */\nfunction updateComponents (address, node, state, diff, bindings, renderResult,\n                           stateCallers, opts) {\n  const updateRecurse = ([ d, s ], k) => {\n    // TODO in updateRecurse functions where k can be null, there must be a\n    // nicer way to organize things with fewer null checks\n    const component = k !== null ? node.component : node\n    const newAddress = k !== null ? addressWith(address, k) : address\n    const b = k !== null ? get(bindings, k) : bindings\n    const r = k !== null ? get(renderResult, k) : renderResult\n    // Update the component. If DESTROY, then there will not be a binding.\n    const res = updateEl(newAddress, component, s, d.data, get(b, 'data'), r,\n                         stateCallers, opts)\n    // Fall back on old bindings.\n    const nextRenderResult = res.bindings !== null ? res.bindings :\n            dropNodes(b.children)\n    const data = res.lastRenderedEl\n    // update children\n    const children = updateComponents(newAddress, component.model, s,\n                                      d.children, get(b, 'children'),\n                                      nextRenderResult, stateCallers, opts)\n    return tagType(NODE, { data, children })\n  }\n  const recurse = (n, k) => {\n    return updateComponents(addressWith(address, k), n, get(state, k), diff[k],\n                            get(bindings, k), get(renderResult, k),\n                            stateCallers, opts)\n  }\n  return match(\n    node,\n    {\n      [OBJECT_OF]: objOf => {\n        return mapValues(zipObjects([ diff, state ]), updateRecurse)\n      },\n      [ARRAY_OF]: arOf => {\n        return zipArrays([ diff, state ]).map(updateRecurse)\n      },\n      [COMPONENT]: component => updateRecurse([ diff, state ], null),\n      [ARRAY]: ar => ar.map(recurse),\n      [OBJECT]: obj => mapValues(obj, recurse),\n    })\n}\n\n// -------------------------------------------------------------------\n// State\n// -------------------------------------------------------------------\n\nexport function addressWith (address, key) {\n  if (key === null) {\n    return address\n  } else {\n    const newAddress = address.slice(0)\n    newAddress.push(key)\n    return newAddress\n  }\n}\n\nexport function addressEqual (a1, a2) {\n  if (a1 === null || a2 === null || a1.length !== a2.length) return false\n  return a1.reduce((accum, v, i) => accum && v === a2[i], true)\n}\n\n/**\n * Get the value in a tree.\n * @param {Array} address -\n * @param {Object} tree -\n * @return {*} - The value at the given address.\n */\nfunction treeGet (address, tree) {\n  return address.reduce((accum, val) => {\n    return checkType(NODE, accum) ? accum.children[val] : accum[val]\n  }, tree)\n}\n\n/**\n * Set the value in a tree; immutable.\n * @param {Array} address -\n * @param {Object} tree -\n * @param {*} value - The new value to set at address.\n * @return (*) The new tree.\n */\nfunction treeSet (address, tree, value) {\n  if (address.length === 0) {\n    return value\n  } else {\n    const [ k, rest ] = head(address)\n    return (typeof k === 'string' ?\n            { ...tree, [k]: treeSet(rest, treeGet([ k ], tree), value) } :\n            [ ...tree.slice(0, k), treeSet(rest, treeGet([ k ], tree), value),\n              ...tree.slice(k + 1) ])\n  }\n}\n\n/**\n * Set the value in a tree; mutable.\n * @param {Array} address -\n * @param {Object} tree -\n * @param {*} value - The new value to set at address.\n * @return (*) The tree.\n */\nfunction treeSetMutable (address, tree, value) {\n  if (address.length === 0) {\n    return value\n  } else {\n    const [ rest, last ] = tail(address)\n    const parent = treeGet(rest, tree)\n    if (checkType(NODE, parent)) {\n      parent.children[last] = value\n    } else {\n      parent[last] = value\n    }\n    return tree\n  }\n}\n\nexport function makeTree (init, mutable) {\n  let state = init\n  return {\n    get: (address) => {\n      return treeGet(address, state)\n    },\n    set: (address, value) => {\n      state = mutable ?\n        treeSetMutable(address, state, value) :\n        treeSet(address, state, value)\n    },\n  }\n}\n\n/**\n * Check that the new state is valid. If not, then throw an Error.\n * @param {Object} modelNode - A model or a node of a model.\n * @param {Object} newState - The new state corresponding to modelNode.\n */\nexport function checkState (modelNode, newState) {\n  if (newState === null) {\n    return\n  }\n  match(modelNode, {\n    [OBJECT_OF]: objOf => {\n      if (!isObject(newState) || isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model. ' +\n                        'Model: ' + objOf + '  State: ' + newState)\n      } else {\n        mapValues(newState, s => checkState(modelNode.component.model, s))\n      }\n    },\n    [ARRAY_OF]: arOf => {\n      if (!isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model.' +\n                        'Model: ' + arOf + '  State: ' + newState)\n      } else {\n        newState.map(s => checkState(modelNode.component.model, s))\n      }\n    },\n    [COMPONENT]: component => {\n      checkState(modelNode.model, newState)\n    },\n    [ARRAY]: ar => {\n      if (!isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model.' +\n                        'Model: ' + ar + '  State: ' + newState)\n      } else {\n        ar.map((a, i) => checkState(a, get(newState, i)))\n      }\n    },\n    [OBJECT]: obj => {\n      if (!isObject(newState) || isArray(newState)) {\n        throw new Error('Shape of the new state does not match the model. ' +\n                        'Model: ' + obj + '  State: ' + newState)\n      } else {\n        mapValues(obj, (o, k) => checkState(o, get(newState, k)))\n      }\n    },\n  })\n}\n\nfunction computeDiffValue (state, lastState, key, isValidFn, shouldUpdate,\n                           address, triggeringAddress) {\n  const stateValid = isValidFn(state, key)\n  const lastStateValid = isValidFn(lastState, key)\n  if (stateValid && !lastStateValid) {\n    return CREATE\n  } else if (stateValid && lastStateValid) {\n    const same = (key === null ? state !== lastState :\n                  state[key] !== lastState[key])\n    const componentTriggeredUpdate = addressEqual(address, triggeringAddress)\n    if (same && shouldUpdate({ state, lastState, componentTriggeredUpdate })) {\n      return UPDATE\n    } else {\n      return null\n    }\n  } else if (!stateValid && lastStateValid) {\n    return DESTROY\n  } else {\n    return null\n  }\n}\n\n/**\n * Compute the full diff tree for the model node. Calls shouldUpdate.\n */\nfunction diffWithModel (modelNode, state, lastState, address,\n                        triggeringAddress) {\n  return match(\n    modelNode,\n    {\n      [OBJECT_OF]: objOf => {\n        const isValidFn = (obj, k) => {\n          return isObject(obj) && k in obj && obj[k] !== null\n        }\n        const l = Object.assign({}, state || {}, lastState || {})\n        return mapValues(l, function (_, k) {\n          const data = computeDiffValue(state, lastState, k, isValidFn,\n                                        objOf.component.shouldUpdate,\n                                        addressWith(address, k),\n                                        triggeringAddress)\n          const children = diffWithModel(objOf.component.model,\n                                         get(state, k),\n                                         get(lastState, k),\n                                         addressWith(address, k),\n                                         triggeringAddress)\n          return tagType(NODE, { data, children })\n        })\n      },\n      [ARRAY_OF]: arOf => {\n        const isValidFn = (obj, i) => {\n          return isArray(obj) && i < obj.length && obj[i] !== null\n        }\n        const longest = Math.max(isArray(state) ? state.length : 0,\n                                 isArray(lastState) ? lastState.length : 0)\n        const l = Array.apply(null, { length: longest })\n        return l.map(function (_, i) {\n          const data = computeDiffValue(state, lastState, i, isValidFn,\n                                        arOf.component.shouldUpdate,\n                                        addressWith(address, i), triggeringAddress)\n          const children = diffWithModel(arOf.component.model,\n                                         get(state, i),\n                                         get(lastState, i),\n                                         addressWith(address, i),\n                                         triggeringAddress)\n          return tagType(NODE, { data, children })\n        })\n      },\n      [COMPONENT]: component => {\n        const isValidFn = (obj, _) => obj !== null\n        const data = computeDiffValue(state, lastState, null, isValidFn,\n                                      component.shouldUpdate,\n                                      address, triggeringAddress)\n        const children = diffWithModel(component.model, state || null,\n                                       lastState || null, address,\n                                       triggeringAddress)\n        return tagType(NODE, { data, children })\n      },\n      [ARRAY]: ar => {\n        return ar.map((n, i) => {\n          return diffWithModel(n, get(state, i), get(lastState, i),\n                               addressWith(address, i), triggeringAddress)\n        })\n      },\n      [OBJECT]: obj => {\n        return mapValues(obj, (n, k) => {\n          return diffWithModel(n, get(state, k), get(lastState, k),\n                               addressWith(address, k), triggeringAddress)\n        })\n      },\n    })\n}\n\n/**\n * For an array of minSignals and minUpdate trees, return the minimal trees that\n * represent the whole array.\n */\nfunction singleOrAll (modelNode, address, minTreeAr) {\n  const getMin = indices => {\n    if (indices.length === 0) {\n      // If all elements in the array are null, return null.\n      return null\n    } else if (nonNullIndices.signals.length === 1) {\n      // If there is a single value, return that tree, with an updated address.\n      return {\n        minSignals: {\n          diff: minTreeAr.map(a => a.minSignals.diff),\n          address,\n          modelNode,\n        },\n        minUpdate: {\n          diff: minTreeAr.map(a => a.minUpdate.diff),\n          address,\n          modelNode,\n        },\n      }\n    } else {\n      // Otherwise, return full trees from this level.\n      return {\n        minSignals: {\n          diff: minTreeAr.map(a => a.minSignals.diff),\n          address,\n          modelNode,\n        },\n        minUpdate: {\n          diff: minTreeAr.map(a => a.minUpdate.diff),\n          address,\n          modelNode,\n        },\n      }\n    }\n  }\n  // Get the indices where the signal and update trees are not null.\n  const nonNullIndices = minTreeAr.reduce((accum, val, i) => {\n    return {\n      signals: val.minSignals !== null ? [ ...accum.signals, i ]: accum.signals,\n      update: val.minUpdate !== null ? [ ...accum.update, i ]: accum.update,\n    }\n  }, { signals: [], update: [] })\n  // For each set of indices, test the diffs with these tests to get a minimum\n  // tree.\n  const minSignals = getMin(nonNullIndices.signals)\n  const minUpdate = getMin(nonNullIndices.update)\n  return { minSignals, minUpdate }\n}\n\n/**\n * 1. Run shouldUpdate for every component in the tree.\n * 2. Return the information about the minimal tree to update with\n *    updateComponents (whenever shouldUpdate is true) as minUpdate.\n * 3. Return the information about the minimal tree to update with\n *    mergeSignals (whenever nodes are added or deleted) as minSignals.\n *\n * @param {Object} modelNode - A model or a node of a model.\n * @param {Object} state - The new state corresponding to modelNode.\n * @param {Object|null} lastState - The old state corresponding to modelNode.\n * @param {Array} address -\n * @param {Array} triggeringAddress -\n * @returns {Object} An object with the attributes minSignals and\n *                   minUpdate. Each represents a minimal tree necessary for the\n *                   appropriate update function and has the attributes diff,\n *                   modelNode, and address.\n */\nexport function diffWithModelMin (modelNode, state, lastState, address,\n                                  triggeringAddress) {\n  // 1. calculate whole diff tree\n  const diff = diffWithModel(modelNode, state, lastState, address,\n                             triggeringAddress)\n  // 2. trim the tree for the two needs\n  return {\n    minSignals: {\n      diff,\n      address,\n      modelNode,\n    },\n    minUpdate: {\n      diff,\n      address,\n      modelNode,\n    },\n  }\n}\n\n// -------------------------------------------------------------------\n// Signals\n// -------------------------------------------------------------------\n\n/**\n * Make a signal.\n * @return {Object} A signal with attributes `on` and `call`.\n */\nexport function makeSignal () {\n  const res = { _onFns: [] }\n  res.on = fn => {\n    if (!isFunction(fn)) {\n      throw new Error('First argument to \"on\" must be a function')\n    }\n    res._onFns = [ ...res._onFns, fn ]\n  }\n  res.call = (...args) => res._onFns.map(fn => fn(...args))\n  return res\n}\n\n/**\n * Create an object that with `on/onEach` and `call` attributes.\n * @param {Boolean} isCollection -\n * @return {Object}\n */\nexport function makeOneSignalAPI (isCollection) {\n  // make a `_callFn` function that will be replaced later and is the target of\n  // `call`\n  const res = { _callFns: [] }\n  // call will run all functions in `_callFns`\n  res.call = (...args) => {\n    if (args.length > 1 || !isObject(args[0])) {\n      throw new Error('Call only accepts a single object as argument.')\n    }\n    res._callFns.map(({ fn }) => fn(args[0]))\n  }\n  // store callbacks passed with `on` or `onEach`\n  res._onFns = []\n  const onName = isCollection ? 'onEach' : 'on'\n  res[onName] = fn => {\n    if (!isFunction(fn)) {\n      throw new Error('Argument to \"' + onName + '\" must be a function')\n    }\n    res._onFns.push(index => (...args) => {\n      if (args.length > 1 || !isObject(args[0])) {\n        throw new Error('On function only accepts a single object as argument.')\n      }\n      const argObject = ( typeof index === 'string' ? { k: index, ...args[0] } :\n                          (typeof index === 'number' ? { i: index, ...args[0] } :\n                           args[0]))\n      fn(argObject)\n    })\n  }\n  return res\n}\n\n/**\n * Implement the signals API.\n */\nfunction makeSignalsAPI (signalNames, isCollection) {\n  return fromPairs(signalNames.map(name => {\n    return [ name, makeOneSignalAPI(isCollection) ]\n  }))\n}\n\n/**\n * Implement the childSignals API.\n */\nexport function makeChildSignalsAPI (model) {\n  return match(\n    model,\n    {\n      [OBJECT_OF]: node => makeSignalsAPI(node.component.signalNames, true),\n      [ARRAY_OF]:  node => makeSignalsAPI(node.component.signalNames, true),\n      [COMPONENT]: node => makeSignalsAPI(node.signalNames, false),\n      [ARRAY]: ar => ar.map(makeChildSignalsAPI).filter(notNull),\n      [OBJECT]: obj => filterValues(mapValues(obj, makeChildSignalsAPI), notNull),\n    },\n    constant(null)\n  )\n}\n\n/**\n * Reduce the direct children of the tree.\n * @param {Object} node - A node in a tree.\n * @param {Function} fn - Function with arguments (accum, object).\n * @param {*} init - An initial value.\n * @param {Array} address - The local address.\n * @return {*}\n */\nexport function reduceChildren (node, fn, init, address = []) {\n  return match(node, {\n    [NODE]: node => fn(init, node.data, address),\n    [ARRAY]: ar => {\n      return ar.reduce((accum, n, k) => {\n        return reduceChildren(n, fn, accum, addressWith(address, k))\n      }, init)\n    },\n    [OBJECT]: obj => {\n      return reduceValues(obj, (accum, n, k) => {\n        return reduceChildren(n, fn, accum, addressWith(address, k))\n      }, init)\n    },\n  }, constant(init))\n}\n\n/**\n * Run signalSetup with the component.\n * @param {Object} component -\n * @param {Array} address -\n * @param {Object} stateCallers -\n * @return {Object} Object with keys signalsAPI and childSignalsAPI.\n */\nfunction runSignalSetup (component, address, stateCallers) {\n  const signalsAPI = makeSignalsAPI(component.signalNames, false)\n  const childSignalsAPI = makeChildSignalsAPI(component.model)\n  const reducers = patchReducersWithState(address, component, stateCallers.callReducer)\n  const signals = patchSignals(address, component, stateCallers.callSignal)\n  const methods = patchMethods(address, component, stateCallers.callMethod,\n                               reducers, signals)\n  // cannot call signalSetup any earlier because it needs a reference to\n  // `methods`, which must know the address\n  component.signalSetup({\n    methods,\n    reducers,\n    signals: signalsAPI,\n    childSignals: childSignalsAPI,\n  })\n  return { signalsAPI, childSignalsAPI }\n}\n\n/**\n * Merge a signals object with signal callbacks from signalSetup.\n * @param {Object} node - A model node.\n * @param {Array} address - The address.\n * @param {Object} diffNode - A node in the diff tree.\n * @param {Object|null} signalNode - A node in the existing signals tree.\n * @param {Object} stateCallers - The object with 3 functions to modify global\n *                                state.\n * @param {Object|null} upChild - The childSignalsAPI object for the parent\n *                                Component.\n * @param {Array|null} upAddress - A local address specifying the location\n *                                 relative to the parent Component.\n * @return {Object} The new signals tree.\n */\nexport function mergeSignals (node, address, diffNode, signalNode, stateCallers,\n                              upChild = null, upAddress = null) {\n  const updateRecurse = ([ d, s ], k) => {\n    const component = k !== null ? node.component : node\n    const newAddress = k !== null ? addressWith(address, k) : address\n    const diffVal = d.data\n    if (diffVal === CREATE) {\n      // For create, apply the callbacks\n      const { signalsAPI, childSignalsAPI } = runSignalSetup(component,\n                                                             newAddress,\n                                                             stateCallers)\n      const newUpAddress = upAddress === null ? null : addressWith(upAddress, k)\n      const signals = mapValues(\n        zipObjects([ signalsAPI, upChild ]),\n        ([ callbackObj, upCallbackObj ], key) => {\n          const signal = makeSignal()\n\n          // For each callback, add each onFn to the signal,\n          // and set the callFn to the signal dispatch. Only\n          // on, not onEach, so execute the fn with no\n          // argument.\n          callbackObj._onFns.map(fn => signal.on(fn()))\n          callbackObj._callFns = [ { fn: signal.call, address: null } ]\n\n          // For the childSignalCallbacks from the parent\n          if (upCallbackObj !== null) {\n            upCallbackObj._onFns.map(fn => signal.on(fn(k)))\n            upCallbackObj._callFns = [\n              ...upCallbackObj._callFns,\n              { fn: signal.call, address: newUpAddress }\n            ]\n          }\n\n          return signal\n        }\n      )\n      const data = { signals, signalsAPI, childSignalsAPI }\n\n      // loop through the children of signals and node\n      const children = mergeSignals(component.model, newAddress, d.children,\n                                    get(s, 'children'), stateCallers,\n                                    childSignalsAPI, [])\n\n      return tagType(NODE, { data, children })\n    } else if (diffVal === DESTROY) {\n      // In the case of destroy, this leaf in the signals object will be null.\n      return null\n    } else {\n      // update\n      const { hasCreated, destroyed } = reduceChildren(\n        d.children, (accum, diffVal, address) => {\n          const hasCreated = accum.hasCreated || diffVal === CREATE\n          const destroyed = (diffVal === DESTROY ?\n                             [ ...accum.destroyed, address ] :\n                             accum.destroyed)\n          return { hasCreated, destroyed }\n        }, { hasCreated: false, destroyed: [] }\n      )\n\n      // if there are deleted children, delete references to them\n      destroyed.map(childAddress => {\n        // get the right child within childSignalsAPI\n        const childSignalsAPINode = childAddress.reduce((accum, k, i) => {\n          if (k in accum) {\n            return accum[k]\n          } else if (i === childAddress.length - 1) {\n            return accum\n          } else {\n            throw new Error('Bad address ' + childAddress + ' for object ' +\n                            s.data.childSignalsAPI)\n          }\n        }, s.data.childSignalsAPI)\n        mapValues(childSignalsAPINode, obj => {\n          // remove the matching callFns\n          obj._callFns = obj._callFns.filter(({ address }) => {\n            return !addressEqual(address, childAddress)\n          })\n        })\n      })\n\n      const newUpChild = hasCreated ? s.data.childSignalsAPI : null\n      const newUpAddress = hasCreated ? [] : null\n      const children = mergeSignals(component.model, newAddress, d.children,\n                                    get(s, 'children'), stateCallers,\n                                    newUpChild, newUpAddress)\n      return tagType(NODE, { data: get(s, 'data'), children })\n    }\n  }\n\n  const recurse = ([ n, d, s, u ], k) => {\n    const newAddress = addressWith(address, k)\n    const newUpAddress = upAddress === null ? null : addressWith(upAddress, k)\n    return mergeSignals(n, newAddress, d, s, stateCallers, u, newUpAddress)\n  }\n\n  return match(node, {\n    [OBJECT_OF]: objOf => {\n      return filterValues(mapValues(zipObjects([ diffNode, signalNode ]), updateRecurse), notNull)\n    },\n    [ARRAY_OF]: arOf => {\n      return zipArrays([ diffNode, signalNode ]).map(updateRecurse).filter(notNull)\n    },\n    [COMPONENT]: component => updateRecurse([ diffNode, signalNode ], null),\n    [ARRAY]: ar => zipArrays([ ar, diffNode, signalNode, upChild ]).map(recurse),\n    [OBJECT]: obj => mapValues(zipObjects([ obj, diffNode, signalNode, upChild ]), recurse),\n  }, constant(null))\n}\n\n// -------------------------------------------------------------------\n// Component & run functions\n// -------------------------------------------------------------------\n\n/**\n * Create an object representing many instances of this component, for use in a\n * tinier model.\n * @param {Object} component - Tinier component.\n * @return {Object}\n */\nexport function objectOf (component) {\n  return tagType(OBJECT_OF, { component })\n}\n\n/**\n * Create an array representing many instances of this component, for use in a\n * tinier model.\n * @param {Object} component - Tinier component.\n * @return {Object}\n */\nexport function arrayOf (component) {\n  return tagType(ARRAY_OF, { component })\n}\n\nfunction defaultShouldUpdate ({ state, lastState }) {\n  return state !== lastState\n}\n\nfunction checkInputs (options, defaults) {\n  mapValues(options, (_, k) => {\n    if (!(k in defaults)) {\n      console.error('Unexpected argument ' + k)\n    }\n  })\n}\n\nfunction patchInitNoArg (init) {\n  return (...args) => {\n    if (args.length === 0) {\n      return init({})\n    } else if (args.length > 1 || !isObject(args[0])) {\n      throw new Error('Reducers can only take 1 or 0 arguments, and the ' +\n                      'argument should be an object.')\n    } else {\n      return init(args[0])\n    }\n  }\n}\n\nfunction patchReducersOneArg (reducers) {\n  return mapValues(reducers, (reducer, name) => {\n    return (...args) => {\n      if (args.length !== 1 || !isObject(args[0])) {\n        throw new Error('Reducers can only take 1 arguments, and the ' +\n                        'argument should be an object.')\n      } else if (!('state' in args[0])) {\n        throw new Error('The argument to the reducer must have a \"state\" ' +\n                        'attribute.')\n      } else {\n        return reducer(args[0])\n      }\n    }\n  })\n}\n\n/**\n * Create a tinier component.\n * @param {Object} componentArgs - Functions defining the Tinier component.\n * @param {str} componentArgs.displayName - A name for the component.\n * @param {[str]} componentArgs.signals - An array of signal names.\n * @param {Object} componentArgs.model - The model object.\n * @param {Function} componentArgs.init - A function to initialize the state.\n * @param {Object} componentArgs.reducers -\n * @param {Object} componentArgs.methods -\n * @param {Function} componentArgs.willMount -\n * @param {Function} componentArgs.didMount -\n * @param {Function} componentArgs.shouldUpdate - Return true if the component\n *                                                should update, false if it\n *                                                should not, or null to use to\n *                                                default behavior (update when\n *                                                state changes).\n * @param {Function} componentArgs.willUpdate -\n * @param {Function} componentArgs.didUpdate -\n * @param {Function} componentArgs.willUnmount -\n * @param {Function} componentArgs.render -\n * @returns {Object} A tinier component.\n */\nexport function createComponent (options = {}) {\n  // default attributes\n  const defaults = {\n    displayName:  '',\n    signalNames:  [],\n    signalSetup:  noop,\n    model:        {},\n    init:         constant({}),\n    reducers:     {},\n    methods:      {},\n    willMount:    noop,\n    didMount:     noop,\n    shouldUpdate: defaultShouldUpdate,\n    willUpdate:   noop,\n    didUpdate:    noop,\n    willUnmount:  noop,\n    render:       noop,\n  }\n  // check inputs\n  checkInputs(options, defaults)\n\n  if ('init' in options) {\n    options.init = patchInitNoArg(options.init)\n  }\n\n  if ('reducers' in options) {\n    options.reducersRaw = options.reducers\n    options.reducers = patchReducersOneArg(options.reducers)\n  }\n\n  // check model\n  if (options.model && checkType(COMPONENT, options.model)) {\n    throw new Error('The model cannot be another Component. The top level of ' +\n                    'the model should be an array or an object literal')\n  }\n  // set defaults & tag\n  return tagType(COMPONENT, { ...defaults, ...options })\n}\n\nfunction patchReducersWithState (address, component, callReducer) {\n  return mapValues(component.reducersRaw, (reducer, name) => {\n    return function (...args) {\n      if (args.length === 0) {\n        callReducer(address, component, reducer, {}, name)\n      } else if (args.length > 1 || !isObject(args[0])) {\n        throw new Error('Reducers can only take 1 or 0 arguments, and the ' +\n                        'argument should be an object.')\n      } else {\n        callReducer(address, component, reducer, args[0], name)\n      }\n    }\n  })\n}\n\nfunction patchSignals (address, component, callSignal) {\n  return fromPairs(component.signalNames.map(signalName => {\n    return [\n      signalName,\n      { call: arg => callSignal(address, signalName, arg) }\n    ]\n  }))\n}\n\n/**\n * Return an object of functions that call the methods with component-specific\n * arguments.\n */\nexport function patchMethods (address, component, callMethod, reducers, signals) {\n  const methods = mapValues(component.methods, method => {\n    return function (arg) {\n      if (typeof Event !== 'undefined' && arg instanceof Event) {\n        callMethod(address, method, signals, methods, reducers, this, arg, {})\n      } else {\n        callMethod(address, method, signals, methods, reducers, null, null, arg)\n      }\n    }\n  })\n  return methods\n}\n\nexport function makeCallMethod (stateTree, opts) {\n  /**\n   * Call a method on the local stateTree\n   * @param address\n   * @param method\n   * @param signals\n   * @param methods - Patched method functions.\n   * @param reducers - Patched reducer functions.\n   * @param target - The value of this in the called function.\n   * @param event - The event at the time of the function call.\n   * @param arg - An argument object.\n   */\n  return (address, method, signals, methods, reducers, target, event, arg) => {\n    // check for uninitialized stateTree\n    if (stateTree.get([]) === null) {\n      throw new Error('Cannot call method before the app is initialized (e.g. ' +\n                      'in signalSetup).')\n    }\n    // get the local state\n    const localState = stateTree.get(address)\n    // run the method\n    method({ state: localState, signals, methods, reducers, target, event,\n             ...arg })\n  }\n}\n\n/**\n * Return a callSignal function.\n */\nfunction makeCallSignal (signals, opts) {\n  return (address, signalName, arg) => {\n    if (opts.verbose) {\n      console.log('Called signal ' + signalName + ' at [' + address.join(', ') +\n                  '].')\n    }\n    signals.get(address).data.signals[signalName].call(arg)\n  }\n}\n\n/**\n * Return a new callReducer function.\n * @param {Object} topComponent - The top-level component.\n * @param {Object} stateTree - The global stateTree.\n * @param {Object} bindingTree - The global bindingTree.\n * @param {Object} signalTree - The global signalTree.\n * @param {Object} stateCallers - An object with functions callMethod,\n *                                callSignal, and callReducer.\n * @param {Object} opts - Options from `run`.\n * @returns {Function} - Call a reducer on the local state\n *   @param {Array} address - A location, as an array of keys (strings and\n *                            integers).\n *   @param {Object} triggeringComponent -\n *   @param {Function} reducer - A reducer.\n *   @param {Object} arg - An argument object.\n *   @param {String} name - The name of the reducer (for logging).\n */\nexport function makeCallReducer (topComponent, stateTree, bindingTree,\n                                 signalTree, stateCallers, opts) {\n  return (address, triggeringComponent, reducer, arg, name) => {\n    if (!isFunction(reducer)) {\n      throw new Error('Reducer ' + name + ' is not a function')\n    }\n    // Run the reducer, and optionally log the result.\n    const localState = stateTree.get(address)\n    const newLocalState = reducer({ ...arg, state: localState })\n    if (opts.verbose) {\n      console.log('Called reducer ' + name + ' for ' +\n                  triggeringComponent.displayName + ' at [' + address.join(', ')\n                  + '].')\n      console.log(localState)\n      console.log(newLocalState)\n    }\n\n    // Check that the new state is valid. If not, throw an Error, and the new\n    // state will be thrown out.\n    checkState(triggeringComponent.model, newLocalState)\n\n    // Set the state with immutable objects and arrays. A reference to oldState\n    // will used for diffing.\n    const lastState = stateTree.get([])\n    stateTree.set(address, newLocalState)\n\n    // Run diffWithModelMin, which will do a few things:\n    // 1. Run shouldUpdate for every component in the tree.\n    // 2. Return the information about the minimal tree to update with\n    //    updateComponents (whenever shouldUpdate is true) as minUpdate.\n    // 3. Return the information about the minimal tree to update with\n    //    mergeSignals (whenever nodes are added or deleted) as minSignals.\n    // The output objects have the attributes diff, modelNode, and address.\n    // TODO might be best to go back to returning just one full diff here\n    const { minSignals, minUpdate } = diffWithModelMin(topComponent,\n                                                       stateTree.get([]),\n                                                       lastState, [], address)\n\n    // Update the signals.\n    const localSignals = signalTree.get(minSignals.address)\n    const newSignals = mergeSignals(minSignals.modelNode, minSignals.address,\n                                    minSignals.diff, localSignals, stateCallers)\n    signalTree.set(minSignals.address, newSignals)\n\n    // Update the components.\n    const minUpdateBindings = bindingTree.get(minUpdate.address)\n    const minUpdateEl = minUpdateBindings.data\n    const minUpdateState = stateTree.get(minUpdate.address)\n    const newBindings = updateComponents(minUpdate.address, minUpdate.modelNode,\n                                         minUpdateState, minUpdate.diff,\n                                         minUpdateBindings, minUpdateEl,\n                                         stateCallers, opts)\n    bindingTree.set(minUpdate.address, newBindings)\n  }\n}\n\n/**\n * Return an object with functions callMethod, callSignal, and callReducer.\n * @param {Object} component - The top-level component.\n * @param {Object} stateTree - The global stateTree.\n * @param {Object} bindingTree - The global bindings.\n * @param {Object} signalTree - The global signalTree.\n * @return {Object} An object with functions callMethod, callSignal, and\n *                  callReducer.\n */\nexport function makeStateCallers (component, stateTree, bindingTree,\n                                  signalTree, opts) {\n  const stateCallers = {}\n  stateCallers.callMethod = makeCallMethod(stateTree, opts)\n  stateCallers.callSignal = makeCallSignal(signalTree, opts)\n  stateCallers.callReducer = makeCallReducer(component, stateTree, bindingTree,\n                                             signalTree, stateCallers, opts)\n  return stateCallers\n}\n\n/**\n * Run a tinier component.\n * @param {Object} component - A tinier component.\n * @param {*} appEl - An element to pass to the component's create, update, and\n *                    destroy methods.\n * @param {Object|null} initialState - The initial state. If null, then init()\n *                                     will be called to initialize the state.\n * @return {Object} The API functions, incuding getState, signals, and methods.\n */\nexport function run (component, appEl, opts = {}) {\n  // Create variables that will store the state for the whole lifetime of the\n  // application. Similar to the redux model.\n  let stateTree = makeTree(null, false)\n  const topBinding = tagType(NODE, { data: appEl, children: null })\n  let bindingTree = makeTree(topBinding, true)\n  let signalTree = makeTree(null, true)\n\n  // functions that access state, signals, and bindings\n  const stateCallers = makeStateCallers(component, stateTree, bindingTree,\n                                        signalTree, opts)\n\n  // make sure initial state is valid\n  // TODO LEFT OFF ... does this work?\n  // Q: Does the state for a child component need to be defined? Are we checking\n  // all the way down the line?\n  const initialState = ('initialState' in opts ? opts.initialState :\n                        component.init())\n\n  // first draw\n  const setStateReducer = ({ newState }) => newState\n  const setState = newState => {\n    return stateCallers.callReducer([], component, setStateReducer,\n                                    { newState }, 'setState')\n  }\n  setState(initialState)\n\n  // return API\n  const getState = () => stateTree.get([])\n  // TODO check state\n  const setStateNoRender = newState => stateTree.set([], newState)\n  const reducers = patchReducersWithState([], component,\n                                          stateCallers.callReducer)\n  const signalsCall = patchSignals([], component, stateCallers.callSignal)\n  const methods = patchMethods([], component, stateCallers.callMethod, reducers,\n                               signalsCall)\n  // if state is null, then data will be null\n  const signals = get(signalTree.get([]).data, 'signals')\n\n  return { setState, setStateNoRender, getState, reducers, methods, signals }\n}\n\n// -------------------------------------------------------------------\n// DOM\n// -------------------------------------------------------------------\n\n// constants\nexport const BINDING = '@TINIER_BINDING'\nexport const ELEMENT = '@TINIER_ELEMENT'\nconst LISTENER_OBJECT = '@TINIER_LISTENERS'\n\nfunction reverseObject (obj) {\n  const newObj = {}\n  for (let k in obj) {\n    newObj[obj[k]] = k\n  }\n  return newObj\n}\n\n// some attribute renaming as seen in React\nconst ATTRIBUTE_RENAME = {}\nconst ATTRIBUTE_RENAME_REV = reverseObject(ATTRIBUTE_RENAME)\nconst ATTRIBUTE_APPLY = {\n  checked: (el, name, val = false) => {\n    if (name !== 'input') {\n      throw new Error('\"checked\" attribute is only supported on input elements.')\n    }\n    el.checked = val\n  },\n  value: (el, name, val = false) => {\n    if ([ 'input', 'textarea' ].indexOf(name) === -1) {\n      throw new Error('\"value\" attribute is only supported on input and ' +\n                      'textarea elements.')\n    }\n    el.value = val\n  },\n}\n\n// namespace management inspired by of D3.js, Mike Bostock, BSD license\nconst NAMESPACES = {\n  svg: 'http://www.w3.org/2000/svg',\n  xhtml: 'http://www.w3.org/1999/xhtml',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n}\n\n/**\n * Turn an array of objects into a new object of objects where the keys are\n * given by the value of `key` in each child object.\n * @param {[Object]} arr - The array of objects.\n * @param {String} key - The key to look for.\n */\nfunction keyBy (arr, key) {\n  var obj = {}\n  arr.map(x => obj[x[key]] = x)\n  return obj\n}\n\n/**\n *\n */\nexport function addressToObj (address, val) {\n  // If address is []\n  if (isUndefined(address[0])) {\n    return val\n  }\n  const f = address[0]\n  if (isString(f)) {\n    return { [f]: addressToObj(address.slice(1), val) }\n  } else {\n    const ar = Array(f + 1)\n    ar[f] = addressToObj(address.slice(1), val)\n    return ar\n  }\n}\n\nfunction objectForBindingsArray (bindings) {\n  // Check arrays and find longest internal array.\n  let longest = 0\n  for (let j = 0, l = bindings.length; j < l; j++) {\n    const binding = bindings[j]\n    if (!isArray(binding)) {\n      throw Error('Incompatible bindings: mix of types')\n    }\n    const len = binding.length\n    if (len > longest) {\n      longest = len\n    }\n  }\n  const acc = []\n  for (let i = 0; i < longest; i++) {\n    for (let j = 0, l = bindings.length; j < l; j++) {\n      const binding = bindings[j]\n      if (binding[i] != null) { // not null or undefined\n        if (acc[i] != null) { // not null or undefined\n          acc[i] = objectForBindings([ binding[i], acc[i] ])\n        } else {\n          acc[i] = binding[i]\n        }\n      }\n    }\n  }\n  return acc\n}\n\nfunction objectForBindingsObject (bindings) {\n  return bindings.reduce((acc, binding) => {\n    if (isArray(binding))\n      throw Error('Incompatible bindings: mix of types')\n    for (let k in binding) {\n      if (binding[k]) {\n        if (acc[k]) {\n          acc[k] = objectForBindings([ binding[k], acc[k] ])\n        } else {\n          acc[k] = binding[k]\n        }\n      }\n    }\n    return acc\n  }, {})\n}\n\nexport function objectForBindings (bindings) {\n  return isArray(bindings[0]) ?\n    objectForBindingsArray(bindings) :\n    objectForBindingsObject(bindings)\n}\n\n// Make sure default is null so undefined type constant do not match\nconst isTinierBinding = obj => checkType(BINDING, obj)\nconst isTinierElement = obj => checkType(ELEMENT, obj)\n\n/**\n * Returns true if it is a DOM element.\n * http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n */\nfunction isElement (o) {\n  return (o && typeof o === 'object' && o !== null &&\n          o.nodeType === 1 && typeof o.nodeName === 'string')\n}\n\n/**\n * Returns true if it is a DOM text element.\n */\nfunction isText (o) {\n  return (o && typeof o === 'object' && o !== null &&\n          o.nodeType === 3 && typeof o.nodeName === 'string')\n}\n\n/**\n * Create a new TinierDOM element.\n * @param {String} tagName - The name for the element.\n * @param {Object|null} attributesIn - The attributes. Note that JSX will pass\n *                                     null in when there are no attributes. In\n *                                     the resulting object, this will be an\n *                                     empty object {}.\n * @param {Object[]|Object|String} ...children - A single binding or a mix of\n *                                               elements and strings.\n * @return {Object} A TinierDOM element.\n */\nexport function createElement (tagName, attributesIn, ...children) {\n  const attributes = attributesIn == null ? {} : attributesIn\n  return tagType(ELEMENT, { tagName, attributes, children })\n}\n\n/**\n * Create a new TinierDOM binding.\n * @param {Array|String|Number} addressIn - An address array, or single key or\n *                                          index.\n * @return {Object} A TinierDOM binding.\n */\nexport function bind (addressIn) {\n  const address = isArray(addressIn) ? addressIn : [ addressIn ]\n  return tagType(BINDING, { address })\n}\n\nfunction explicitNamespace (name) {\n  const i = name.indexOf(':')\n  if (i !== -1) {\n    const prefix = name.slice(0, i)\n    if (prefix in NAMESPACES) {\n      // for xmlns, treat the whole name (e.g. xmlns:xlink) as the name\n      const newName = prefix === 'xmlns' ? name : name.slice(i + 1)\n      return { name: newName, explicit: NAMESPACES[prefix] }\n    } else {\n      return { name, explicit: null }\n    }\n  } else {\n    return { name, explicit: null }\n  }\n}\n\n/**\n * Create a DOM element, inheriting namespace or choosing one based on tag.\n * @param {Object} tinierEl - A TinierDOM element.\n * @param {Object} parent - The parent el.\n * @return {Object} The DOM element.\n */\nexport function createDOMElement (tinierEl, parent) {\n  const tag = tinierEl.tagName\n  const { name, explicit } = explicitNamespace(tag)\n  const ns = (explicit !== null ? explicit :\n              (tag in NAMESPACES ? NAMESPACES[tag] : parent.namespaceURI))\n  const el = (ns === NAMESPACES.xhtml ?\n              document.createElement(name) :\n              document.createElementNS(ns, name))\n  return updateDOMElement(el, tinierEl)\n}\n\nexport function getStyles (cssText) {\n  const reg = /([^:; ]+):/g\n  const res = []\n  let ar\n  while ((ar = reg.exec(cssText)) !== null) {\n    res.push(ar[1])\n  }\n  return res\n}\n\nfunction toCamelCase (name) {\n  return name\n  // Uppercase the first character in each group immediately following a dash\n    .replace(/-(.)/g, m => m.toUpperCase())\n  // Remove dashes\n    .replace(/-/g, '')\n}\n\nfunction stripOn (name) {\n  return name.slice(2).toLowerCase()\n}\n\nfunction setAttributeCheckBool (namespace, el, name, val) {\n  // set boolean appropriately\n  const valToSet = val === true ? name : val\n  if (namespace === NAMESPACES.xhtml) {\n    el.setAttribute(name, valToSet)\n  } else {\n    el.setAttributeNS(namespace, name, valToSet)\n  }\n}\n\n/**\n * Update the DOM element to match a TinierDOM element.\n * @param {Element} el - An existing DOM element.\n * @param {Object} tinierEl - A TinierDOM element.\n */\nexport function updateDOMElement (el, tinierEl) {\n  let thenFn = null\n  const parentNamespace = el.namespaceURI\n\n  // remove event listeners first, because they cannot simply be replaced\n  if (el.hasOwnProperty(LISTENER_OBJECT)) {\n    mapValues(el[LISTENER_OBJECT], (onFn, name) => {\n      el.removeEventListener(name, onFn)\n    })\n    delete el[LISTENER_OBJECT]\n  }\n\n  // Update the attributes.\n  // TODO is it faster to check first, or set first?\n  mapValues(tinierEl.attributes, (v, k) => {\n    if (k === 'id') {\n      // ID is set directly\n      el.id = v\n    } else if (k === 'style' && !isString(v)) {\n      // For a style object. For a style string, use setAttribute below.\n      mapValues(v, (sv, sk) => {\n        el.style.setProperty(sk, sv)\n      })\n    } else if (k.indexOf('on') === 0) {\n      // Special handling for listeners\n      if (!el.hasOwnProperty(LISTENER_OBJECT)) {\n        el[LISTENER_OBJECT] = {}\n      }\n      // allow null\n      if (v !== null) {\n        const name = stripOn(k)\n        if (!isFunction(v) && v !== null) {\n          throw new Error(v + ' is not a function.')\n        }\n        el[LISTENER_OBJECT][name] = v\n        el.addEventListener(name, v)\n      }\n    } else if (k in ATTRIBUTE_RENAME) {\n      // By default, set the attribute.\n      const { name, explicit } = explicitNamespace(k)\n      setAttributeCheckBool(explicit !== null ? explicit : parentNamespace,\n                            el, ATTRIBUTE_RENAME[explicit], v)\n    } else if (k in ATTRIBUTE_APPLY) {\n      ATTRIBUTE_APPLY[k](el, tinierEl.tagName, v)\n\n    } else if (k === 'then') {\n      if (v !== null) {\n        if (!isFunction(v)) {\n          throw new Error(v + ' is not a function or null.')\n        }\n        thenFn = v\n      }\n    } else {\n      // By default, set the attribute.\n      const { name, explicit } = explicitNamespace(k)\n      setAttributeCheckBool(explicit !== null ? explicit : parentNamespace,\n                            el, name, v)\n    }\n  })\n  // Delete attributes if not provided. First, loop through this attributes\n  // object to get a nice array.\n  let attributeNames = []\n  for (let i = 0, l = el.attributes.length; i < l; i++) {\n    attributeNames.push(el.attributes[i].name)\n  }\n  attributeNames\n    .filter(k => !(k in tinierEl.attributes) || tinierEl.attributes[k] === false)\n    .map(k => {\n      if (k in ATTRIBUTE_RENAME_REV) {\n        el.removeAttribute(ATTRIBUTE_RENAME_REV[k])\n      } else if (k in ATTRIBUTE_APPLY) {\n        ATTRIBUTE_APPLY[k](el, tinierEl.tagName)\n      } else {\n        el.removeAttribute(k)\n      }\n    })\n  // Delete styles if not provided.\n  const tStyle = tinierEl.attributes.style\n  if (tStyle && !isString(tStyle)) {\n    getStyles(el.style.cssText)\n      .filter(a => !(a in tStyle || toCamelCase(a) in tStyle))\n      .map(a => el.style.removeProperty(a))\n  }\n\n  // call the callback\n  if (thenFn) {\n    defer(() => thenFn(el))\n  }\n\n  return el\n}\n\n/**\n* flatten the elements array\n*/\nfunction flattenElementsAr (ar) {\n  return ar.reduce((acc, el) => {\n    return isArray(el) ? [ ...acc, ...el ] : [ ...acc, el ]\n  }, []).filter(notNull) // null means ignore\n}\n\nfunction removeExtraNodes (container, length) {\n  for (let i = container.childNodes.length - 1; i >= length; i--) {\n    container.removeChild(container.childNodes[i])\n  }\n}\n\n/**\n * Render the given element tree into the container.\n * @param {Element} container - A DOM element that will be the container for\n *                              the renedered element tree.\n * @param {...[Object|String]|Object|String} tinierElementsAr -\n *   Any number of TinierDOM elements or strings that will be rendered.\n * @return {Object} A nested data structure of bindings for use in Tinier.\n */\nexport function render (container, ...tinierElementsAr) {\n  // check arguments\n  if (!isElement(container)) {\n    throw new Error('First argument must be a DOM Element.')\n  }\n\n  const tinierElements = flattenElementsAr(tinierElementsAr)\n\n  const first = get(tinierElements, 0)\n  if (isTinierBinding(first)) {\n    if (tinierElements.length !== 1) {\n      throw new Error('A binding cannot have siblings in TinierDOM. ' +\n                      'At binding: [ ' + first.address.join(', ') + ' ].')\n    }\n    return objectForBindings([ addressToObj(first.address, container) ])\n  }\n\n  // get the children with IDs\n  const childrenWithKeys = Array.from(container.children).filter(c => c.id)\n  const elementsByID = keyBy(childrenWithKeys, 'id')\n\n  // render each element\n  const bindingsAr = tinierElements.map((tinierEl, i) => {\n    // If an element if a binding, then there can only be one child.\n    if (isUndefined(tinierEl)) {\n      // cannot be undefined\n      throw new Error('Children in Tinier Elements cannot be undefined.')\n    } else if (isTinierElement(tinierEl)) {\n      // container.childNodes is a live collection, so get the current node at\n      // this index.\n      const el = container.childNodes[i]\n      // tinierEl is a TinierDOM element.\n      if (tinierEl.attributes.id in elementsByID) {\n        // el exist, then check for a matching node by ID\n        const movedEl = elementsByID[tinierEl.attributes.id]\n        if (el) {\n          // if match and existing el, then replace the element\n          container.replaceChild(movedEl, el)\n        } else {\n          // if match and el is undefined, then append the element\n          container.appendChild(movedEl)\n        }\n        // then render children\n        return render(movedEl, ...tinierEl.children)\n      } else if (el) {\n        // both defined, check type and id\n        if (el.tagName && el.tagName.toLowerCase() ===\n            tinierEl.tagName.toLowerCase()) {\n          // matching tag, then update the node to match. Be aware that existing\n          // nodes with IDs might get moved, so we should clone them?\n          const elToUpdate = el.id ? el.cloneNode(true) : el\n          updateDOMElement(elToUpdate, tinierEl)\n          if (el.id) container.replaceChild(elToUpdate, el)\n          return render(elToUpdate, ...tinierEl.children)\n        } else {\n          // not a matching tag, then replace the element with a new one\n          const newEl = createDOMElement(tinierEl, container)\n          container.replaceChild(newEl, el)\n          return render(newEl, ...tinierEl.children)\n        }\n      } else {\n        // no el and no ID match, then add a new Element or string node\n        const newEl2 = createDOMElement(tinierEl, container)\n        container.appendChild(newEl2)\n        return render(newEl2, ...tinierEl.children)\n      }\n      // There should not be any bindings here\n    } else if (isTinierBinding(tinierEl)) {\n      throw new Error('A binding cannot have siblings in TinierDOM. ' +\n                      'At binding: [ ' + tinierEl.address.join(', ') + ' ].')\n    } else {\n      const el = container.childNodes[i]\n      const s = String(tinierEl)\n      // This should be a text node.\n      if (isText(el)) {\n        // If already a text node, then set the text content.\n        el.textContent = s\n      } else if (el) {\n        // If not a text node, then replace it.\n        container.replaceChild(document.createTextNode(s), el)\n      } else {\n        // If no existing node, then add a new one.\n        container.appendChild(document.createTextNode(s))\n      }\n      // No binding here.\n      return null\n    }\n  })\n\n  // remove extra nodes\n  // TODO This should not run if the child is a binding. Make a test for\n  // this. When else should it not run?\n  removeExtraNodes(container, tinierElements.length)\n\n  // bindings array to object\n  return objectForBindings(bindingsAr.filter(b => b !== null))\n}\n\n// export API\nexport default {\n  arrayOf, objectOf, createComponent, run, bind, createElement, render,\n}\n"]}