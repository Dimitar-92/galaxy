require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * This component uses the D3 library and specifically its implementation of the force algorithm to 
 * represent a network of protein interactions.  
 * 
 * @class
 * @extends Biojs
 * 
 * @author <a href="mailto:gustavoadolfo.salazar@gmail.com">Gustavo A. Salazar</a>
 * @version 0.9.1_beta
 * @category 1
 * 
 * @requires <a href='http://code.jquery.com/query-1.7.2.min.js'>jQuery Core 1.7.2</a>
 * @dependency <script language="JavaScript" type="text/javascript" src="../biojs/dependencies/jquery/jquery-1.7.2.min.js"></script>
 * 
 * @requires <a href='http://d3js.org/'>D3</a>
 * @dependency <script src="http://d3js.org/d3.v2.min.js" type="text/javascript"></script>
 *
 * @requires <a href='http://www.ebi.ac.uk/~jgomez/biojs/biojs/css/biojs.InteractionsD3.css'>InteractionsD3 CSS</a>
 * @dependency <link rel="stylesheet" href="../biojs/css/biojs.InteractionsD3.css" />
 * 
 * @param {Object} options An object with the options for the InteractionsD3 component.
 * 
 * @option {string} target
 *    Identifier of the DIV tag where the component should be displayed.
 * @option {string} width
 *    Width of the SVG element, if given in percentage it will use it on proportion of the container 
 * @option {string} height
 *    Height of the SVG element, if given in percentage it will use it on proportion of the container 
 * @option {string} radius
 *    Radius of the nodes representing the proteins
 * @option {string} enableEdges
 * 	  Force the proteins to stay in the defined area of the SVG
 * 
 * @example
 * 			var instance = new Biojs.InteractionsD3({
 * 				target: "YourOwnDivId",
 * 			});	
 * 			for (var pid=1;pid<=15;pid++)
 *				instance.addProtein({ "id":pid,"name":pid,"showLegend":false,"typeLegend":"id","organism":"human"+pid%3,"features":{"f1":"val1","f2":"val2","f3":"val3"}});
 *			
 * 			for (var pid=1;pid<=30;pid++)
 *				instance.addInteraction(Math.floor((Math.random()*15)+1),Math.floor((Math.random()*15)+1) ,{score:Math.random()});
 * 			instance.restart();
 */

var Class = require("js-class");
var InteractionsD3;
module.exports = InteractionsD3 = Class(
	/** @lends Biojs.InteractionsD3# */
	{
		force:null,
		vis:null,
		interactions:[],
		interactionsA:{},
		proteins:[],
		proteinsA:{},
		node_drag:null,
		color: null,
		foci: [],
		organisms: {},
		
		//Transformation values
		tTranslate:null,
		tScale:null,
		
		constructor: function (options) {
			var self 	= this;
			self.force	=null;
			self.vis	=null;
			self.interactions=[];
			self.interactionsA={};
			self.proteins=[];
			self.proteinsA={};
			self.node_drag=null;
			self.color= null;
			self.foci=[];
			self.organisms={};

      require('js-extend').extend(this.opt, options)

			this._container = $("#"+self.opt.target);
			this._container.empty();
			$(this._container).addClass("graphNetwork");
			
			var	width = $(this._container).width(),
				height = $(this._container).height();

			if (self.opt.width.indexOf("%")!=-1)
				width = width*(self.opt.width.substring(0, self.opt.width.length-1)*1)/100.0;
			else
				width=self.opt.width*1;
			self.opt.width=width;
			
			if (self.opt.height.indexOf("%")!=-1)
				height = height*(self.opt.height.substring(0, self.opt.height.length-1)*1)/100.0;
			else
				height=self.opt.height*1;
			self.opt.height=height;
			
			this._container.width(width);
			this._container.height(height);
			
			self.color = function() {
			    return d3.scale.ordinal().range(self.colors);
			}();

			self.zoom=d3.behavior.zoom().
    		scaleExtent([(self.opt.enableEdges)?1:0.1, 10])
    		.on("zoom", redraw);
			self.vis = d3.select("#"+self.opt.target).append("svg")
			    .attr("width", width)
			    .attr("height", height)
			    .attr("pointer-events", "all")
			    .call(self.zoom)
			    .append('svg:g');
			
			self.vis.append('svg:rect')
			    .attr('width', width*20)
			    .attr('height', height*20)
			    .attr('x', -width*10)
			    .attr('y', -height*10)
			    .attr('fill', 'white')
			    .attr('stroke','white');

			self.rect= self.vis.append('svg:rect')
				.attr("class", "frame")
			    .attr('width', width)
			    .attr('height', height)
			    .attr('fill', 'white')
			    .attr('stroke','white')
			    .attr("stroke-dasharray","5,5");


			self.perspective=d3.select("#"+self.opt.target + " svg").append('svg:g');
			
			 
			
			function redraw(x,y,scaleP) {
				var trans=null,scale=null;
				if (typeof x!="undefined" && typeof y!="undefined"){
					trans=[x,y];
					scale = scaleP;
				}else{
					trans=d3.event.translate;
					scale = d3.event.scale;
				}
				self.tTranslate=trans;
				self.tScale=scale;
				if (self.opt.enableEdges) {
					if(scale<1)scale=1;
					d3.behavior.zoom().scaleExtent([1, Infinity]);
					  if (trans[0]>0)trans[0]=0;
					  if (trans[1]>0)trans[1]=0;
	
					  var W = self.rect[0][0].width.animVal.value, H= self.rect[0][0].height.animVal.value;
					  var Ws = W*scale, Hs = H*scale;
					  if (Ws<W-trans[0]) trans[0]=W-Ws;
					  if (Hs<H-trans[1]) trans[1]=H-Hs;
				}
				  self.vis.attr("transform",
				      "translate(" + trans + ")"
				      + " scale(" + scale + ")");
			};
			self.redraw=redraw;
			
			self.force = d3.layout.force()
			    .nodes(self.proteins)
			    .links(self.interactions)
			    .size([width, height]);
			
			
			self.node_drag = d3.behavior.drag()
				.on("dragstart", dragstart)
				.on("drag", dragmove)
				.on("dragend", dragend);

			function dragstart(d, i) {
				self.force.stop(); // stops the force auto positioning before you start dragging
			}

			function dragmove(d, i) {
				d.px += d3.event.dx;
				d.py += d3.event.dy;
				d.x += d3.event.dx;
				d.y += d3.event.dy; 
				tick(d3.event); // this is the key to make it work together with updating both px,py,x,y on d !
			}

			function dragend(d, i) {
				d.fixed = true; // of course set the node to fixed so the force doesn't include the node in its auto positioning stuff
				tick(d3.event);
				self.force.resume();
			}
			self.force.on("tick", tick);
			function tick(e) {
				if (e.type=="tick"){
					var k = .1 * e.alpha;
					self.proteins.forEach(function(o, i) {
						o.y += (self.foci[self.organisms[o.organism]].y - o.y) * k;
						o.x += (self.foci[self.organisms[o.organism]].x - o.x) * k;
					});
				}
				self.vis.selectAll("path.figure")
						.attr("transform", function(d) { 
							if (self.opt.enableEdges)
								return "translate(" + Math.max(r, Math.min(self.opt.width , d.x+r)) + "," + Math.max(r, Math.min(self.opt.height, d.y+r)) + ")";
							else
								return "translate(" + d.x + "," +  d.y + ")"; 
						});

				if (self.opt.enableEdges) 
					self.vis.selectAll(".legend")
						.attr("x", function(d) { return d.x = Math.max(r, Math.min(self.opt.width - r, d.x)); })
						.attr("y", function(d) { return d.y = Math.max(r, Math.min(self.opt.height - r, d.y)); });
				else
					self.vis.selectAll(".legend")
						.attr("x", function(d) { return d.x; })
						.attr("y", function(d) { return d.y; });
				if (self.opt.enableEdges) 
					self.vis.selectAll("line.link")
						.attr("x1", function(d) { return d.source.x+r; })
						.attr("y1", function(d) { return d.source.y+r; })
						.attr("x2", function(d) { return d.target.x+r; })
						.attr("y2", function(d) { return d.target.y+r; });
				else
					self.vis.selectAll("line.link")
						.attr("x1", function(d) { return d.source.x; })
						.attr("y1", function(d) { return d.source.y; })
						.attr("x2", function(d) { return d.target.x; })
						.attr("y2", function(d) { return d.target.y; });
			};
			self.tick=tick;
			//Binding the _resize method when resizing the window! 
			//d3.select(window).on("resize", function(){self._resize(self);});
			
			self.restart();
		},
		/**
		 *  Default values for the options
		 *  @name Biojs.InteractionsD3-opt
		 */
		opt: {
			target: "YourOwnDivId",
			width: "100%",
			height: "500", 
			radius: 10,
			enableEdges:false
		},

		/**
		 * Array containing the supported event names
		 * @name Biojs.InteractionsD3-eventTypes
		 */
		eventTypes : [
			/**
			 * @name Biojs.InteractionsD3#proteinClick
			 * @event
			 * @param {function} actionPerformed It is triggered when the user clicks on a protein
			 * @eventData {@link Biojs.Event} objEvent Object containing the information of the event
			 * @eventData {Object} objEvent.source The component which did triggered the event.
			 * @eventData {Object} objEvent.protein the information of the protein that has been clicked.
			 * @example 
			 * instance.proteinClick(
			 *    function( objEvent ) {
			 *       alert("The protein " + objEvent.protein.id + " was clicked.");
			 *    }
			 * ); 
			 * 
			 * */
			"proteinClick",
			/**
			 * @name Biojs.InteractionsD3#proteinMouseOver
			 * @event
			 * @param {function} actionPerformed It is triggered when the mouse pointer is over a protein
			 * @eventData {@link Biojs.Event} objEvent Object containing the information of the event
			 * @eventData {Object} objEvent.source The component which did triggered the event.
			 * @eventData {Object} objEvent.protein the information of the protein that has been mouseover.
			 * @example 
			 * instance.proteinMouseOver(
			 *    function( objEvent ) {
			 *       alert("The mouse is over the protein " + objEvent.protein.id);
			 *    }
			 * ); 
			 * 
			 * */
			"proteinMouseOver",
			/**
			 * @name Biojs.InteractionsD3#proteinMouseOut
			 * @event
			 * @param {function} actionPerformed It is triggered when the mouse pointer leave the area of a protein
			 * @eventData {@link Biojs.Event} objEvent Object containing the information of the event
			 * @eventData {Object} objEvent.source The component which did triggered the event.
			 * @eventData {Object} objEvent.protein the information of the protein that has been mouseout.
			 * @example 
			 * instance.proteinMouseOut(
			 *    function( objEvent ) {
			 *       alert("The mouse is out the protein " + objEvent.protein.id);
			 *    }
			 * ); 
			 * 
			 * */
			"proteinMouseOut",
			/**
			 * @name Biojs.InteractionsD3#interactionClick
			 * @event
			 * @param {function} actionPerformed A function which receives an {@link Biojs.Event} object as argument.
			 * @eventData {Object} source The component which did triggered the event.
			 * @eventData {Object} interaction the information of the interaction that has been clicked.
			 * @example 
			 * instance.interactionClick(
			 *    function( objEvent ) {
			 *       alert("Click on the interaction " + objEvent.interaction.source.id +" - "+ objEvent.interaction.target.id);
			 *    }
			 * ); 
			 * 
			 * */
			"interactionClick",
			/**
			 * @name Biojs.InteractionsD3#interactionMouseOver
			 * @event
			 * @param {function} actionPerformed A function which receives an {@link Biojs.Event} object as argument.
			 * @eventData {Object} source The component which did triggered the event.
			 * @eventData {Object} interaction the information of the interaction that has been mouseover.
			 * @example 
			 * instance.interactionMouseOver(
			 *    function( objEvent ) {
			 *       alert("The mouse is over the interaction " + objEvent.interaction.source.id +" - "+ objEvent.interaction.target.id);
			 *    }
			 * ); 
			 * 
			 * */
			"interactionMouseOver",
			/**
			 * @name Biojs.InteractionsD3#interactionMouseOut
			 * @event
			 * @param {function} actionPerformed It is triggered when the mouse pointer leave an interaction
			 * @eventData {@link Biojs.Event} objEvent Object containing the information of the event
			 * @eventData {Object} source The component which did triggered the event.
			 * @eventData {Object} interaction the information of the interaction that has been mouseout.
			 * @example 
			 * instance.interactionMouseOut(
			 *    function( objEvent ) {
			 *      alert("The mouse is out of the interaction " + objEvent.interaction.source.id +" - "+ objEvent.interaction.target.id);
			 *    }
			 * ); 
			 * 
			 * */
			"interactionMouseOut",
			/**
			 * @name Biojs.InteractionsD3#sizeChanged
			 * @event
			 * @param {function} actionPerformed It is triggered when the size of the SVG element has been changed. 
			 * @eventData {@link Biojs.Event} objEvent Object containing the information of the event
			 * @eventData {Object} source The component which did triggered the event.
			 * @eventData {Object} width The width of the new size
			 * @eventData {Object} height The height of the new size
			 * @example 
			 * instance.sizeChanged(
			 *    function( objEvent ) {
			 *      alert("The size has changed: ("+objEvent.width+","+objEvent.height+")" );
			 *    }
			 * ); 
			 * 
			 * */
			"sizeChanged"
		], 
		/**
		 * 
		 * allows to resize the SVG element updating the gravity points
		 * @param {string} width value of width to be assign to the SVG
		 * @param {string} height value of height to be assign to the SVG
		 *
		 * @example 
		 * instance.setSize(400,400);
		 * instance.restart();
		 */
		setSize:function(width,height){
			var self =this;
			self.opt.width=width;
			self.opt.height=height;
			d3.select("#"+self.opt.target+" svg")
			    .attr('width', width)
			    .attr('height', height);
			d3.select("#"+self.opt.target+" .frame")
			    .attr('width', width)
			    .attr('height', height);

			self._container.width(width);
			self._container.height(height);
			var numberOfOrganism =Object.keys(self.organisms).length;
			self.foci=[];
			for (var i=0; i<numberOfOrganism; i++){
				self.foci.push({x: (self.opt.width/(numberOfOrganism+1))*(i+1), y:self.opt.height/2});
			}
			if (self.tTranslate!=null) self.redraw(self.tTranslate[0], self.tTranslate[1], self.tScale);
			self.restart();
			self.trigger('sizeChanged', {
				width:width,
				height:height
			});
		},
		/**
		 * Adds an interaction between 2 proteins that are already in the graphic using their IDs
		 * 
		 * @param {string} proteinId1 Id of the first protein in the interaction
		 * @param {string} proteinId2 Id of the second protein in the interaction
		 * @param {Object} [extraAtributes={}] An object containing meta information of the interaction 
		 * 					to be stored in the interaction itself. useful for triggered events
		 *
		 * @example 
		 * instance.addInteraction(Math.floor((Math.random()*15)+1),Math.floor((Math.random()*15)+1) ,{score:Math.random()});
		 * instance.restart();
		 */
		addInteraction: function(proteinId1,proteinId2,extraAtributes) {
			var self=this;

			// Getting the protein with the first id and checking exists in the graphic
			var protein1= self.getProtein(proteinId1);
			if (typeof protein1=="undefined")return false;
			
			// Getting the protein with the second id and checking exists in the graphic
			var protein2= self.getProtein(proteinId2);
			if (typeof protein2=="undefined")return false;
			
			//Checking there is not an interaction between those proteins already in the graphic
			if (typeof self.interactionsA[proteinId1]!="undefined" && self.interactionsA[proteinId1].indexOf(protein2)!=-1)
				return self.interactionsA[proteinId1].indexOf(protein2);
				
			//creating and adding an interaction
			var interaction = {source:protein1,target:protein2};
			//adding any parameters from the object extraAtributes to the interaction object
			if (typeof extraAtributes!="undefined")
				for (var key in extraAtributes)
					interaction[key]=extraAtributes[key];

			var n= self.interactions.push(interaction);
			
			//Saving the interaction in the associative array
			if (typeof self.interactionsA[interaction.source.id] == "undefined")
				self.interactionsA[interaction.source.id]=[interaction.target];
			else
				self.interactionsA[interaction.source.id].push(interaction.target);
			if (typeof self.interactionsA[interaction.target.id] == "undefined")
				self.interactionsA[interaction.target.id]=[interaction.source];
			else
				self.interactionsA[interaction.target.id].push(interaction.source);

			return n;
		},
		/**
		 * Adds a protein to the graphic
		 * 
		 * @param {Object} protein An object containing information of the protein 
		 *
		 * @example 
		 *  instance.addProtein({ "id":"new","name":"new","showLegend":true,"typeLegend":"id","organism":"human"+pid%3,"features":{"f1":"val1","f2":"val2","f3":"val3"}});
		 * instance.restart();
		 */
		addProtein: function(protein) {
			var self=this;
			var n = self.proteins.indexOf(self.proteinsA[protein.id]);
			if (n!=-1)
				return n;
			if (typeof self.fixedProteins[protein.id]=="undefined"){
				protein.x=Math.floor((Math.random()*self.opt.width));
				protein.y=Math.floor((Math.random()*self.opt.width));
			}else{
				protein.x=self.fixedProteins[protein.id][0];
				protein.y=self.fixedProteins[protein.id][1];
				protein.fixed=true;
			}
			if(typeof protein.size == "undefined") protein.size=1;
			n= self.proteins.push(protein);
			self.proteinsA[protein.id]=protein;
			if (typeof self.interactionsA[protein.id] == "undefined")
				self.interactionsA[protein.id]=[];
			if (typeof self.organisms[protein.organism] == 'undefined'){
				var numberOfOrganism =Object.keys(self.organisms).length;
				self.organisms[protein.organism] = numberOfOrganism++;
				self.foci=[];
				for (var i=0; i<numberOfOrganism; i++){
					self.foci.push({x: (self.opt.width/(numberOfOrganism+1))*(i+1), y:self.opt.height/2});
				}
			}
			return n;
		},
		/**
		 * Gets the protein object by its id
		 * 
		 * @param {string} proteinId The id of the protein
		 *  
		 * @return {Object} protein An object containing information of the protein 
		 *
		 * @example 
		 * alert(instance.getProtein('3'));
		 */
		getProtein: function(proteinId) {
			var self=this;
			return self.proteinsA[proteinId];
		},
		/**
		 * Gets the array index of the interaction object by the ids of the interactors
		 * 
		 * @param {string} proteinId1 The id of the first protein interacting
		 * @param {string} proteinId2 The id of the second protein interacting
		 *  
		 * @return {Integer} An int value indicating the index of the interaction in the array this.interactions 
		 *
		 * @example 
		 * alert(instance.getInteractionIndex('3','5'));
		 */
		getInteractionIndex: function(proteinId1,proteinId2){
			var self =this;
			for (var i=0; i<self.interactions.length; i++){
				var sourceId=self.interactions[i].source.id;
				var targetId=self.interactions[i].target.id;
				if ((sourceId==proteinId1 && targetId==proteinId2)||(sourceId==proteinId2 && targetId==proteinId1))
					return i;
			}
			return null;
		},
		/**
		 * gets the interaction object by the id of its proteins
		 * 
		 * @param {string} proteinId1 The id of the first protein
		 * @param {string} proteinId2 The id of the second protein
		 *  
		 * @return {Object} An object containing information of the interaction 
		 *
		 * @example 
		 * alert(instance.getInteraction('1','3'));
		 */
		getInteraction: function(proteinId1,proteinId2){
			var self =this;
			return self.getInteractionIndex(proteinId1,proteinId2);
		},
		/**
		 * Removes from the graphic the interaction by the id of its proteins
		 * 
		 * @param {string} proteinId1 The id of the first protein
		 * @param {string} proteinId2 The id of the second protein
		 *  
		 * @example 
		 * instance.removeInteraction('2','3');
		 */
		removeInteraction: function(proteinId1,proteinId2){
			var self = this;
			var intIndex = self.getInteractionIndex(proteinId1,proteinId2);
			self.interactions.splice(intIndex--, 1);
			
			var p1=self.getProtein(proteinId1),
				p2=self.getProtein(proteinId2);
			
			intIndex = self.interactionsA[proteinId1].indexOf(p2);
			if (intIndex!=-1) self.interactionsA[proteinId1].splice(intIndex--, 1);

			intIndex = self.interactionsA[proteinId2].indexOf(p1);
			if (intIndex!=-1) self.interactionsA[proteinId2].splice(intIndex--, 1);
		},
		/**
		 * removes a protein from the graphic with all the interactions unless the interactor 
		 * is also interacting with another protein that is visible. 
		 * 
		 * @param {string} proteinId The id of the protein to delete
		 *  
		 * @example 
		 * instance.removeProtein('2');
		 */
		removeProtein: function(proteinId, excludelist){
			var self=this;
			excludelist = (typeof excludelist == "undefined")?[]:excludelist;

			if (typeof self.interactionsA[proteinId] != "undefined"){
				for (var i=0;i<self.interactionsA[proteinId].length;i++){
					var targetid=self.interactionsA[proteinId][i].id;
					if (excludelist.indexOf(targetid) == -1){
						self.removeInteraction(proteinId,targetid);
						i--;
						if (self.interactionsA[targetid].length==0)
							self.removeProtein(targetid);
					}
				}
				if (self.interactionsA[proteinId].length==0){
					delete self.interactionsA[proteinId];
					for(var i=0; i<self.proteins.length; i++) {
						if(self.proteins[i].id == proteinId) {
							self.proteins.splice(i, 1);
							break;
						}
					}
					delete self.proteinsA[proteinId];
				}else{
					self.proteinsA[proteinId].fixed=false;
				}
			}
		},
		/**
		 * 
		 * Resets the graphic to zero proteins - zero interactions
		 * 
		 * @example 
		 * instance.resetGraphic();
		 */
		resetGraphic: function(){
			var self=this;
			self.proteins=[];
			self.proteinsA={};
			self.interactions=[];
			self.restart();
		},
		_figuresOrder:[0,3,2,5,4,1],
		/**
		 * Restart the graphic to materialize the changes done on it(e.g. add/remove proteins)
		 * It is here where the SVG elemnts are created.
		 * 
		 * @example 
		 * instance.restart();
		 */
		restart: function(){
			var self = this;
			
			self.force
			    .nodes(self.proteins)
			    .links(self.interactions)
				.charge(-self.opt.radius*(3+self.proteins.length))
				.linkDistance(self.opt.radius*(3+self.proteins.length*0.05)).start();

			var link =self.vis.selectAll(".graphNetwork line.link")
				.data(self.interactions, function(d) { return d.source.id + "-" + d.target.id; });
			
			link.enter().insert("line" , ".node") //insert before the .node so lines won't hide the nodes
				.attr("class", "link")
				.attr("id", function(d) { return "link_"+d.source.id+"_"+d.target.id; })
				.on("mouseover", function(d){ 
					self.trigger('interactionMouseOver', {
						interaction: d
					});
				})
				.on("mouseout",  function(d){ 
					self.trigger('interactionMouseOut', {
						interaction: d
					});
				})
				.on("click", function(d){ 
					self.trigger('interactionClick', {
						interaction: d
					});
				})
				.attr("x1", function(d) { return d.source.x; })
				.attr("y1", function(d) { return d.source.y; })
				.attr("x2", function(d) { return d.target.x; })
				.attr("y2", function(d) { return d.target.y; });
			
			link.exit().remove();
	
			var nodes= self.vis.selectAll(".graphNetwork .node")
				.data(self.proteins, function(d) { return d.id;});
			
			var node=nodes
				.enter().append("g")
				.attr("class", "node")
				.attr("id", function(d) { return "node_"+d.id; })
				.attr("organism", function(d) { return d.organism; })
				.call(self.node_drag);
			
			node.append("path")
				.attr("class", "figure")
				.attr("d", d3.svg.symbol()
						.size(function(d) {
							return (2*self.opt.radius)*(2*self.opt.radius)*d.size*d.size;
						})
						.type(function(d) {
							return d3.svg.symbolTypes[self._figuresOrder[self.organisms[d.organism]]];
						})
					)
				.attr("id", function(d) { return "figure_"+d.id; })
				.on("click", function(d){ 
					self.trigger('proteinClick', {
						protein: d
					});
				})
				.on("mouseover", function(d){ 
					self.trigger('proteinMouseOver', {
						protein: d
					});
				})
				.on("mouseout",  function(d){ 
					self.trigger('proteinMouseOut', {
						protein: d
					});
				})
				.attr("stroke-width",self.opt.radius*0.3);
			

			node
				.append("svg:text")
				.attr("class", "legend")
				.attr("id", function(d) { return "legend_"+d.id; })
				.text(function(d) { 
					if (d.typeLegend=="id") 
						return d.id;
					else if (d.typeLegend.indexOf("features.")==0)
						return d.features[d.typeLegend.substr(9)];
					else
						return d[d.typeLegend];
					})
				.attr("visibility",function(d) { return (d.showLegend)?"visible":"hidden";})
				.attr("transform",function(d) {
					return (self.organisms[d.organism] == 0)?"translate(-"+(self.opt.radius*1.9)+","+(self.opt.radius*0.4)+")":"translate(-"+(self.opt.radius*0.9)+","+(self.opt.radius*1.3)+")";
				});

			nodes.exit().remove();
			
			self.perspective.selectAll(".legendBlock").remove();
			if (typeof self.legends!="undefined" && self.legends!=null)
				self._paintLegends();
		},
		_sortLegends:function(){
			var self = this;
			self.legends.sort(function(a,b){
				if (a[1]==b[1]){
					if (a[0]=="label") return -1;
					if (b[0]=="label") return 1;
				}else if (a[1]>b[1]){
					return -1;
				}else
					return 1;
				return 0;
			});
		},
		_paintLegend:function(legend,type){
			var self = this;
			legend.filter(function(d) { return d[0]== "label" && d[1]==type; }).append("text")
				.attr("x", self.opt.width - 6)
				.attr("y", 7)
				.attr("dy", ".35em")
				.style("text-anchor", "end")
				.style("font-size", "1.2em")
				.text(type+":");
			if (type.indexOf("Resize By")==0){

				legend.filter(function(d) { return d[0]!="label" && d[1]==type; }).append("path")
					.attr("class", "figure")
					.attr("d", function(d) {
							var h=2*self.opt.radius*Math.sqrt(d[0][2]);
							return "M0,0L0,10M0,5L"+h+",5M"+h+",0L"+h+",10 ";
					})
					.attr("transform", function(d) { 
						return "translate(" +  (self.opt.width - 18 - 2*self.opt.radius*Math.sqrt(d[0][2])) + "," +  0 + ")"; 
					})
					.style("fill", "transparent")
					.style("stroke", "black");
				legend.filter(function(d) { return d[0]!="label" && d[1]== type; }).append("text")
					.attr("x", function(d) { 
						return (self.opt.width - 22 - 5*self.opt.radius); 
					})
					.attr("y", 7)
					.attr("dy", ".35em")
					.style("text-anchor", "end")
					.text(function(d) { return (d[0][1]*1.0).toFixed(2); });
				
			}else{
				legend.filter(function(d) { return d[0]!="label" && d[1]==type; }).append("rect")
					.attr("x", self.opt.width - 18) 
					.attr("width", 13)
					.attr("height", 13)
					.style("fill", function(d,i) {
						if (typeof d[2]== "undefined")
							return self.color(i);
						return d[2];
					});
				legend.filter(function(d) { return d[0]!="label" && d[1]== type; }).append("text")
					.attr("x", self.opt.width - 24)
					.attr("y", 7)
					.attr("dy", ".35em")
					.style("text-anchor", "end")
					.text(function(d) { return d[0]; });
			}
		},
		_paintLegends: function(){
			var self = this;
			var w=18 + self.longestLegend*7 + 10;
			var legendBlock = self.perspective.insert("g",".link")
				.attr("class", "legendBlock");
			self._sortLegends();
			legendBlock.append("rect")
				.attr("x", self.opt.width -w)
				.attr("height", 6 + self.legends.length *16)
				.attr("width", w)
				.style("fill", "#ddd")
				.style("fill-opacity","0.4");

			var legend = legendBlock.selectAll(".mainLegend") 
				.data(self.legends)
				.enter().insert("g")
				.attr("class", "mainLegend")
				.attr("transform", function(d, i) { 
					return "translate(0," + (3 + i * 16) + ")"; 
				});
			for (var i=0; i< self.legendTypes.length; i++)
				self._paintLegend(legend,self.legendTypes[i]);

		},
		longestLegend:4,
		legendTypes:[],
		/**
		 * Adds a legend to the graphic
		 * 
		 * @example 						
		 * instance.addLegends(["Legend red"],"Color","#FF0000");
		 * instance.restart();
		 */
		addLegends:function(legends,type,color){
			var self = this;
			if (self.legends==null) self.legends=[],self.legendTypes=[];
			
			if (legends==null) {
				self.legends = null;
				self.legendTypes=[];
				self.longestLegend=4;
				return;
			}
			if (type=="Resize By") 
				type = type+ " "+legends[0];
			if (self.legendTypes.indexOf(type)==-1) {
				self.legends.push(["label",type]);
				self.legendTypes.push(type);
				if (type.length>self.longestLegend)
					self.longestLegend=type.length;
			}
			
			if (type.indexOf("Resize By")==0){ //is a size label
				self.legends.push([legends,type]);
			} else //is a color label
				for (var i=0;i<legends.length;i++){
					if (typeof color=="undefined")
						self.legends.push([legends[i],type]);
					else
						self.legends.push([legends[i],type,color]);
					
					if (legends[i].length>self.longestLegend)
						self.longestLegend=legends[i].length;
				}
		},
		/**
		 * Hides the elements on the graphic that match the selector. 
		 * Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string 
		 * 
		 * @param {string} selector a string to represent a set of elements. Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string
		 *  
		 * @example 
		 * instance.hide("[id = node_10]");
		 */
		hide: function(selector){
			var self=this;
			self.vis.selectAll(selector).attr("visibility", 'hidden');
			self.vis.selectAll(selector).selectAll(" .legend").attr("visibility", 'hidden');
		},
		/**
		 * Shows the elements on the graphic that match the selector. 
		 * Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string 
		 * 
		 * @param {string} selector a string to represent a set of elements. Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string
		 *  
		 * @example 
		 * instance.show("[id = node_10]");
		 */
		show: function(selector){
			var self=this;
			self.vis.selectAll(selector).attr("visibility", 'visible');
			self.vis.selectAll(selector).selectAll(" .legend").attr("visibility",function(d) { return (d.showLegend)?"visible":"hidden";});
		},
		/**
		 * Highlight the elements on the graphic that match the selector. 
		 * Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string 
		 * 
		 * @param {string} selector a string to represent a set of elements. Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string
		 *  
		 * @example 
		 * instance.highlight("[id *= node_1]");
		 */
		highlight: function(selector){
			var self=this;
			self.vis.selectAll(selector).style("stroke", '#3d6');
		},
		/**
		 * Set the fill's color of the elements on the graphic that match the selector. 
		 * Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string 
		 * 
		 * @param {string} selector a string to represent a set of elements. Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string
		 * @param {string} color a color in web format eg. #FF0000
		 *  
		 * @example 
		 * instance.setFillColor(".figure","#FF0000");
		 */
		setFillColor: function(selector,color){
			var self=this;
			self.vis.selectAll(selector).style("fill", color);
		},
		/**
		 * Set the stroke's color of the elements on the graphic that match the selector. 
		 * Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string 
		 * 
		 * @param {string} selector a string to represent a set of elements. Check the <a href="http://www.w3.org/TR/css3-selectors/">CSS3 selectors documentation</a> to build a selector string
		 * @param {string} color a color in web format eg. #FF0000
		 *  
		 * @example 
		 * instance.setColor("[id *= node_2]","#FF0000");
		 */
		setColor: function(selector,color){
			var self=this;
			self.vis.selectAll(selector).style("stroke", color);
		},
		/**
		 * If the protein has a fixed position in the graphic it gets released, or viceversa other wise
		 * 
		 * @param {string} protein the id of the protein to swap is position on the graphic
		 *  
		 * @example 
		 * instance.swapFixed("3");
		 */
		swapFixed: function(protein){
			var self=this;
			var nodes=self.force.nodes();
			nodes.forEach(function(d, i) {
			  if (d.id==protein)
				  d.fixed = !d.fixed;
			});
		},
		/**
		 * Shows the legend(id) of the protein
		 * 
		 * @param {string} protein the id of the protein to swap the visibility of the legend
		 *  
		 * @example 
		 * instance.swapShowLegend("#node_5 .legend");
		 */
		showLegend: function(selector,typeLegend){
			var self=this;
			self.vis.selectAll(selector).selectAll(".legend").attr("visibility", "visible").text(function(d) {
				d.typeLegend=typeLegend;
				if (d.typeLegend=="id") 
					return d.id;
				else //if (d.typeLegend.indexOf("features.")==0)
					return d.features[d.typeLegend];
//				else
//					return d[d.typeLegend];
				});
//			self.restart();
		}, 
		/**
		 * Scales the area of a protein
		 * 
		 * @param {string} protein the id of the protein to scale
		 * @param {integer} scale value to scale a node
		 *  
		 * @example 
		 * instance.setSizeScale("#figure_1",4);
		 */
		setSizeScale: function(selector,scale){
			var self=this;
			self.vis.selectAll(selector).attr("d", d3.svg.symbol()
					.size(function(d) {
						d.size=scale;
						return (2*self.opt.radius)*(2*self.opt.radius)*scale;
					})
					.type(function(d) {
						return d3.svg.symbolTypes[self._figuresOrder[self.organisms[d.organism]]];
					})
				);
		}, 
		/**
		 * Scales the size of the proteins which value has been modify by other means
		 * 
		 * @param {string} selector a CSS3 selector to choose the nodes to resize
		 *  
		 * @example 
		 * for (var i=0;i<instance.proteins.length;i++)
		 * 	instance.proteins[i].size=1+i%4;
		 * instance.refreshSizeScale(".figure");
		 */
		refreshSizeScale: function(selector){
			var self=this;
			self.vis.selectAll(selector).attr("d", d3.svg.symbol()
					.size(function(d) {
						return (2*self.opt.radius)*(2*self.opt.radius)*d.size;
					})
					.type(function(d) {
						return d3.svg.symbolTypes[self._figuresOrder[self.organisms[d.organism]]];
					})
				);
		}, 
		/**
		 * Hide the legend(id) of the protein
		 * 
		 * @param {string} selector a CSS3 selector to choose the nodes to hide its legend
		 *  
		 * @example 
		 * instance.hideLegend("#node_5 .legend");
		 */
		hideLegend: function(selector){
			var self=this;
			self.vis.selectAll(selector).selectAll(".legend").attr("visibility", "hidden");
		},
		/**
		 * Shows/Hide the legend(id) of the protein
		 * 
		 * @param {string} protein the id of the protein to swap the visibility of the legend
		 *  
		 * @example 
		 * instance.swapShowLegend("#node_5 .legend");
		 */
		swapShowLegend: function(selector){
			var self=this;
			self.vis.selectAll(selector).attr("visibility", function(d) {
				d.showLegend = !d.showLegend;
				return (d.showLegend)?"visible":"hidden";
			});
		},
		/**
		 * gets an array of objects with the list of proteins which poition has been fixed into the graphic
		 * 
		 * @example 
		 * alert(instance.getFixedProteins());
		 */
		getFixedProteins:function(){
			var self = this;
			var prots=[];
			for (var prot in self.proteinsA){
				if (self.proteinsA[prot].fixed){
					prots.push({
						"protein":prot,
						"x":self.proteinsA[prot].x,
						"y":self.proteinsA[prot].y });
				}
			}
			return prots;
		},
		fixedProteins:{},
		/**
		 * fix into the graphic a protein in a determined position
		 * 
		 * @example 
		 * instance.fixProteinAt("7",10,10);
		 * instance.restart();
		 */
		fixProteinAt:function(protein,x,y){
			var self = this;
			if (typeof self.proteinsA[protein] == "undefined") {
				self.fixedProteins[protein]=[x,y];
				return;
			}
			self.proteinsA[protein].x=x;
			self.proteinsA[protein].y=y;
			self.proteinsA[protein].px=x;
			self.proteinsA[protein].py=y;
			self.proteinsA[protein].fixed=true;
		//	self.tick();
		},

		colors: [ "#1f77b4", "#aec7e8", "#ff7f0e", "#ffbb78", "#2ca02c", "#98df8a", "#d62728", "#ff9896", "#9467bd", "#c5b0d5", 
		          "#8c564b", "#c49c94", "#e377c2", "#f7b6d2", "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5",
		          '#3399FF', '#99FF66', '#66FF99', '#CCFF00', '#6699CC', '#99CC00', '#99FFCC', '#993399', '#33FFFF', '#33CC33', 
		         '#66CCFF', '#009999', '#00FFFF', '#CC66CC', '#FF9966', '#CC3300', '#009966', '#660000', '#99FF33', '#330066', 
		         '#FFFF00', '#0099FF', '#FF6699', '#33FF00', '#FFFFCC', '#990000', '#99CC33', '#0033CC', '#006699', '#6699FF', 
		         '#FFCC00', '#330099', '#999999', '#666633', '#FFCC99', '#00CCCC', '#006633', '#CCCC99', '#3300FF', '#33CC66', 
		         '#339999', '#6666FF', '#33FF66', '#990033', '#33CC99', '#993300', '#00FF00', '#666699', '#00CC00', '#FF66CC', 
		         '#00FFCC', '#FF9999', '#66FF00', '#003366', '#CCFF33', '#660066', '#6633CC', '#FF3366', '#99FF00', '#FF33CC', 
		         '#CCFFCC', '#99CCCC', '#3300CC', '#0066FF', '#66CC33', '#3366CC', '#CCCCCC', '#FF0000', '#6666CC', '#336699', 
		         '#999966', '#FFFF99', '#66CC99', '#FF0033', '#999933', '#CC99FF', '#FF0099', '#6600CC', '#CC9966', '#00CC66', 
		         '#33CC00', '#666666', '#33CCCC', '#FF0066', '#00CC33', '#FFCC66', '#FF6600', '#9999FF', '#CC66FF', '#9933FF', 
		         '#FF00CC', '#CC3399', '#CC6633', '#33FFCC', '#FF33FF', '#009900', '#660099', '#669999', '#CC3366', '#0099CC', 
		         '#9900FF', '#669933', '#FFFFFF', '#CCCCFF', '#66CCCC', '#669966', '#0066CC', '#CC9900', '#663300', '#33FF99', 
		         '#996666', '#3399CC', '#99FF99', '#66CC66', '#CC0066', '#CCFF66', '#663366', '#99CC66', '#000033', '#003333', 
		         '#FF6666', '#009933', '#FFFF66', '#996699', '#FFCCCC', '#00CCFF', '#339966', '#3366FF', '#00CC99', '#336633', 
		         '#FF99FF', '#663333', '#CCFF99', '#CC99CC', '#339933', '#33CCFF', '#333366', '#006666', '#CC6600', '#333300', 
		         '#FFCC33', '#9966CC', '#003300', '#9966FF', '#996600', '#CC9933', '#9999CC', '#FF9933', '#006600', '#6633FF', 
		         '#CC6699', '#FF3399', '#993333', '#CCFFFF', '#330033', '#FFCCFF', '#FFFF33', '#990066', '#CCCC66', '#CC0099', 
		         '#CCCC00', '#339900', '#660033', '#FF00FF', '#333333', '#99CC99', '#66FFCC', '#003399', '#999900', '#99FFFF', 
		         '#990099', '#3333FF', '#CC33CC', '#CC6666', '#3333CC', '#9900CC', '#9933CC', '#CC0033', '#CC00FF', '#FF99CC', 
		         '#FF66FF', '#66FFFF', '#6600FF', '#66FF66', '#996633', '#669900', '#00FF99', '#CC9999', '#993366', '#CC33FF', 
		         '#336666', '#0033FF', '#336600', '#CC0000', '#FF9900', '#33FF33', '#000000', '#99CCFF', '#000066', '#0000CC', 
		         '#000099', '#00FF33', '#666600', '#66FF33', '#CCCC33', '#66CC00', '#FF3333', '#CC3333', '#663399', '#333399', 
		         '#FF3300', '#0000FF', '#CC00CC', '#00FF66', '#330000', '#FF6633']

	});


var Events = require('biojs-events');
Events.mixin(InteractionsD3.prototype);

},{"biojs-events":2,"js-class":5,"js-extend":6}],2:[function(require,module,exports){
var events = require("backbone-events-standalone");

events.onAll = function(callback,context){
  this.on("all", callback,context);
  return this;
};

// Mixin utility
events.oldMixin = events.mixin;
events.mixin = function(proto) {
  events.oldMixin(proto);
  // add custom onAll
  var exports = ['onAll'];
  for(var i=0; i < exports.length;i++){
    var name = exports[i];
    proto[name] = this[name];
  }
  return proto;
};

module.exports = events;

},{"backbone-events-standalone":4}],3:[function(require,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      breaker = {},
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) return;
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof define === "function") {
    define(function() {
      return Events;
    });
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],4:[function(require,module,exports){
module.exports = require('./backbone-events-standalone');

},{"./backbone-events-standalone":3}],5:[function(require,module,exports){
(function (global){
/** @preserve http://github.com/easeway/js-class */

// Class Definition using ECMA5 prototype chain

function inherit(dest, src, noParent) {
    while (src && src !== Object.prototype) {
        Object.getOwnPropertyNames(src).forEach(function (name) {
            if (name != '.class' && !dest.hasOwnProperty(name)) {
                var desc = Object.getOwnPropertyDescriptor(src, name);
                Object.defineProperty(dest, name, desc);
            }
        });
        if (noParent) {
            break;
        }
        src = src.__proto__;
    }
    return dest;
}

var Class = function (base, proto, options) {
    if (typeof(base) != 'function') {
        options = proto;
        proto = base;
        base = Object;
    }
    if (!proto) {
        proto = {};
    }
    if (!options) {
        options = {};
    }
    
    var meta = {
        name: options.name,
        base: base,
        implements: []
    }
    var classProto = Class.clone(proto);
    if (options.implements) {
        (Array.isArray(options.implements) ? options.implements : [options.implements])
            .forEach(function (implementedType) {
                if (typeof(implementedType) == 'function' && implementedType.prototype) {
                    meta.implements.push(implementedType);
                    Class.extend(classProto, implementedType.prototype);
                }
            });
    }
    classProto.__proto__ = base.prototype;
    var theClass = function () {
        if (typeof(this.constructor) == 'function') {
            this.constructor.apply(this, arguments);
        }
    };
    meta.type = theClass;
    theClass.prototype = classProto;
    Object.defineProperty(theClass, '.class.meta', { value: meta, enumerable: false, configurable: false, writable: false });
    Object.defineProperty(classProto, '.class', { value: theClass, enumerable: false, configurable: false, writable: false });
    if (options.statics) {
        Class.extend(theClass, options.statics);
    }
    return theClass;
};

Class.extend = inherit;

Class.clone = function (object) {
    return inherit({}, object);
};

function findType(meta, type) {
    while (meta) {
        if (meta.type.prototype === type.prototype) {
            return true;
        }
        for (var i in meta.implements) {
            var implType = meta.implements[i];
            var implMeta = implType['.class.meta'];
            if (implMeta) {
                if (findType(implMeta, type)) {
                    return true;
                }
            } else {
                for (var proto = implType.prototype; proto; proto = proto.__proto__) {
                    if (proto === type.prototype) {
                        return true;
                    }
                }
            }
        }
        meta = meta.base ? meta.base['.class.meta'] : undefined;
    }
    return false;
}

var Checker = Class({
    constructor: function (object) {
        this.object = object;
    },
    
    typeOf: function (type) {
        if (this.object instanceof type) {
            return true;
        }
        var meta = Class.typeInfo(this.object);
        return meta && findType(meta, type);
    }
});

// aliases
Checker.prototype.a = Checker.prototype.typeOf;
Checker.prototype.an = Checker.prototype.typeOf;

Class.is = function (object) {
    return new Checker(object);
};

Class.typeInfo = function (object) {
    var theClass = object.__proto__['.class'];
    return theClass ? theClass['.class.meta'] : undefined;
};

Class.VERSION = [0, 0, 2];

if (module) {
    module.exports = Class;
} else {
    global.Class = Class;   // for browser
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],6:[function(require,module,exports){
(function() { 

  var slice   = Array.prototype.slice,
      each    = Array.prototype.forEach;

  var extend = function(obj) {
    if(typeof obj !== 'object') throw obj + ' is not an object' ;

    var sources = slice.call(arguments, 1); 

    each.call(sources, function(source) {
      if(source) {
        for(var prop in source) {
          if(typeof source[prop] === 'object' && obj[prop]) {
            extend.call(obj, obj[prop], source[prop]);
          } else {
            obj[prop] = source[prop];
          }
        } 
      }
    });

    return obj;
  }

  this.extend = extend;

}).call(this);
},{}],"biojs-vis-interactions-d3":[function(require,module,exports){
module.exports = require("./lib/Biojs.InteractionsD3");

},{"./lib/Biojs.InteractionsD3":1}]},{},["biojs-vis-interactions-d3"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvaG9tZS94c2ViaS9vd25DbG91ZC9wcm9qZWN0cy9iaW9qcy5iYWsvcGFja2FnZXMvYmlvanMtdmlzLWludGVyYWN0aW9ucy1kMy9saWIvQmlvanMuSW50ZXJhY3Rpb25zRDMuanMiLCIvaG9tZS94c2ViaS9vd25DbG91ZC9wcm9qZWN0cy9iaW9qcy5iYWsvcGFja2FnZXMvYmlvanMtdmlzLWludGVyYWN0aW9ucy1kMy9ub2RlX21vZHVsZXMvYmlvanMtZXZlbnRzL2luZGV4LmpzIiwiL2hvbWUveHNlYmkvb3duQ2xvdWQvcHJvamVjdHMvYmlvanMuYmFrL3BhY2thZ2VzL2Jpb2pzLXZpcy1pbnRlcmFjdGlvbnMtZDMvbm9kZV9tb2R1bGVzL2Jpb2pzLWV2ZW50cy9ub2RlX21vZHVsZXMvYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUvYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUuanMiLCIvaG9tZS94c2ViaS9vd25DbG91ZC9wcm9qZWN0cy9iaW9qcy5iYWsvcGFja2FnZXMvYmlvanMtdmlzLWludGVyYWN0aW9ucy1kMy9ub2RlX21vZHVsZXMvYmlvanMtZXZlbnRzL25vZGVfbW9kdWxlcy9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZS9pbmRleC5qcyIsIi9ob21lL3hzZWJpL293bkNsb3VkL3Byb2plY3RzL2Jpb2pzLmJhay9wYWNrYWdlcy9iaW9qcy12aXMtaW50ZXJhY3Rpb25zLWQzL25vZGVfbW9kdWxlcy9qcy1jbGFzcy9jbGFzcy5qcyIsIi9ob21lL3hzZWJpL293bkNsb3VkL3Byb2plY3RzL2Jpb2pzLmJhay9wYWNrYWdlcy9iaW9qcy12aXMtaW50ZXJhY3Rpb25zLWQzL25vZGVfbW9kdWxlcy9qcy1leHRlbmQvZXh0ZW5kLmpzIiwiLi9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIFRoaXMgY29tcG9uZW50IHVzZXMgdGhlIEQzIGxpYnJhcnkgYW5kIHNwZWNpZmljYWxseSBpdHMgaW1wbGVtZW50YXRpb24gb2YgdGhlIGZvcmNlIGFsZ29yaXRobSB0byBcbiAqIHJlcHJlc2VudCBhIG5ldHdvcmsgb2YgcHJvdGVpbiBpbnRlcmFjdGlvbnMuICBcbiAqIFxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBCaW9qc1xuICogXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86Z3VzdGF2b2Fkb2xmby5zYWxhemFyQGdtYWlsLmNvbVwiPkd1c3Rhdm8gQS4gU2FsYXphcjwvYT5cbiAqIEB2ZXJzaW9uIDAuOS4xX2JldGFcbiAqIEBjYXRlZ29yeSAxXG4gKiBcbiAqIEByZXF1aXJlcyA8YSBocmVmPSdodHRwOi8vY29kZS5qcXVlcnkuY29tL3F1ZXJ5LTEuNy4yLm1pbi5qcyc+alF1ZXJ5IENvcmUgMS43LjI8L2E+XG4gKiBAZGVwZW5kZW5jeSA8c2NyaXB0IGxhbmd1YWdlPVwiSmF2YVNjcmlwdFwiIHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCIuLi9iaW9qcy9kZXBlbmRlbmNpZXMvanF1ZXJ5L2pxdWVyeS0xLjcuMi5taW4uanNcIj48L3NjcmlwdD5cbiAqIFxuICogQHJlcXVpcmVzIDxhIGhyZWY9J2h0dHA6Ly9kM2pzLm9yZy8nPkQzPC9hPlxuICogQGRlcGVuZGVuY3kgPHNjcmlwdCBzcmM9XCJodHRwOi8vZDNqcy5vcmcvZDMudjIubWluLmpzXCIgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPjwvc2NyaXB0PlxuICpcbiAqIEByZXF1aXJlcyA8YSBocmVmPSdodHRwOi8vd3d3LmViaS5hYy51ay9+amdvbWV6L2Jpb2pzL2Jpb2pzL2Nzcy9iaW9qcy5JbnRlcmFjdGlvbnNEMy5jc3MnPkludGVyYWN0aW9uc0QzIENTUzwvYT5cbiAqIEBkZXBlbmRlbmN5IDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiLi4vYmlvanMvY3NzL2Jpb2pzLkludGVyYWN0aW9uc0QzLmNzc1wiIC8+XG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGZvciB0aGUgSW50ZXJhY3Rpb25zRDMgY29tcG9uZW50LlxuICogXG4gKiBAb3B0aW9uIHtzdHJpbmd9IHRhcmdldFxuICogICAgSWRlbnRpZmllciBvZiB0aGUgRElWIHRhZyB3aGVyZSB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gKiBAb3B0aW9uIHtzdHJpbmd9IHdpZHRoXG4gKiAgICBXaWR0aCBvZiB0aGUgU1ZHIGVsZW1lbnQsIGlmIGdpdmVuIGluIHBlcmNlbnRhZ2UgaXQgd2lsbCB1c2UgaXQgb24gcHJvcG9ydGlvbiBvZiB0aGUgY29udGFpbmVyIFxuICogQG9wdGlvbiB7c3RyaW5nfSBoZWlnaHRcbiAqICAgIEhlaWdodCBvZiB0aGUgU1ZHIGVsZW1lbnQsIGlmIGdpdmVuIGluIHBlcmNlbnRhZ2UgaXQgd2lsbCB1c2UgaXQgb24gcHJvcG9ydGlvbiBvZiB0aGUgY29udGFpbmVyIFxuICogQG9wdGlvbiB7c3RyaW5nfSByYWRpdXNcbiAqICAgIFJhZGl1cyBvZiB0aGUgbm9kZXMgcmVwcmVzZW50aW5nIHRoZSBwcm90ZWluc1xuICogQG9wdGlvbiB7c3RyaW5nfSBlbmFibGVFZGdlc1xuICogXHQgIEZvcmNlIHRoZSBwcm90ZWlucyB0byBzdGF5IGluIHRoZSBkZWZpbmVkIGFyZWEgb2YgdGhlIFNWR1xuICogXG4gKiBAZXhhbXBsZVxuICogXHRcdFx0dmFyIGluc3RhbmNlID0gbmV3IEJpb2pzLkludGVyYWN0aW9uc0QzKHtcbiAqIFx0XHRcdFx0dGFyZ2V0OiBcIllvdXJPd25EaXZJZFwiLFxuICogXHRcdFx0fSk7XHRcbiAqIFx0XHRcdGZvciAodmFyIHBpZD0xO3BpZDw9MTU7cGlkKyspXG4gKlx0XHRcdFx0aW5zdGFuY2UuYWRkUHJvdGVpbih7IFwiaWRcIjpwaWQsXCJuYW1lXCI6cGlkLFwic2hvd0xlZ2VuZFwiOmZhbHNlLFwidHlwZUxlZ2VuZFwiOlwiaWRcIixcIm9yZ2FuaXNtXCI6XCJodW1hblwiK3BpZCUzLFwiZmVhdHVyZXNcIjp7XCJmMVwiOlwidmFsMVwiLFwiZjJcIjpcInZhbDJcIixcImYzXCI6XCJ2YWwzXCJ9fSk7XG4gKlx0XHRcdFxuICogXHRcdFx0Zm9yICh2YXIgcGlkPTE7cGlkPD0zMDtwaWQrKylcbiAqXHRcdFx0XHRpbnN0YW5jZS5hZGRJbnRlcmFjdGlvbihNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpKjE1KSsxKSxNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpKjE1KSsxKSAse3Njb3JlOk1hdGgucmFuZG9tKCl9KTtcbiAqIFx0XHRcdGluc3RhbmNlLnJlc3RhcnQoKTtcbiAqL1xuXG52YXIgQ2xhc3MgPSByZXF1aXJlKFwianMtY2xhc3NcIik7XG52YXIgSW50ZXJhY3Rpb25zRDM7XG5tb2R1bGUuZXhwb3J0cyA9IEludGVyYWN0aW9uc0QzID0gQ2xhc3MoXG5cdC8qKiBAbGVuZHMgQmlvanMuSW50ZXJhY3Rpb25zRDMjICovXG5cdHtcblx0XHRmb3JjZTpudWxsLFxuXHRcdHZpczpudWxsLFxuXHRcdGludGVyYWN0aW9uczpbXSxcblx0XHRpbnRlcmFjdGlvbnNBOnt9LFxuXHRcdHByb3RlaW5zOltdLFxuXHRcdHByb3RlaW5zQTp7fSxcblx0XHRub2RlX2RyYWc6bnVsbCxcblx0XHRjb2xvcjogbnVsbCxcblx0XHRmb2NpOiBbXSxcblx0XHRvcmdhbmlzbXM6IHt9LFxuXHRcdFxuXHRcdC8vVHJhbnNmb3JtYXRpb24gdmFsdWVzXG5cdFx0dFRyYW5zbGF0ZTpudWxsLFxuXHRcdHRTY2FsZTpudWxsLFxuXHRcdFxuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0dmFyIHNlbGYgXHQ9IHRoaXM7XG5cdFx0XHRzZWxmLmZvcmNlXHQ9bnVsbDtcblx0XHRcdHNlbGYudmlzXHQ9bnVsbDtcblx0XHRcdHNlbGYuaW50ZXJhY3Rpb25zPVtdO1xuXHRcdFx0c2VsZi5pbnRlcmFjdGlvbnNBPXt9O1xuXHRcdFx0c2VsZi5wcm90ZWlucz1bXTtcblx0XHRcdHNlbGYucHJvdGVpbnNBPXt9O1xuXHRcdFx0c2VsZi5ub2RlX2RyYWc9bnVsbDtcblx0XHRcdHNlbGYuY29sb3I9IG51bGw7XG5cdFx0XHRzZWxmLmZvY2k9W107XG5cdFx0XHRzZWxmLm9yZ2FuaXNtcz17fTtcblxuICAgICAgcmVxdWlyZSgnanMtZXh0ZW5kJykuZXh0ZW5kKHRoaXMub3B0LCBvcHRpb25zKVxuXG5cdFx0XHR0aGlzLl9jb250YWluZXIgPSAkKFwiI1wiK3NlbGYub3B0LnRhcmdldCk7XG5cdFx0XHR0aGlzLl9jb250YWluZXIuZW1wdHkoKTtcblx0XHRcdCQodGhpcy5fY29udGFpbmVyKS5hZGRDbGFzcyhcImdyYXBoTmV0d29ya1wiKTtcblx0XHRcdFxuXHRcdFx0dmFyXHR3aWR0aCA9ICQodGhpcy5fY29udGFpbmVyKS53aWR0aCgpLFxuXHRcdFx0XHRoZWlnaHQgPSAkKHRoaXMuX2NvbnRhaW5lcikuaGVpZ2h0KCk7XG5cblx0XHRcdGlmIChzZWxmLm9wdC53aWR0aC5pbmRleE9mKFwiJVwiKSE9LTEpXG5cdFx0XHRcdHdpZHRoID0gd2lkdGgqKHNlbGYub3B0LndpZHRoLnN1YnN0cmluZygwLCBzZWxmLm9wdC53aWR0aC5sZW5ndGgtMSkqMSkvMTAwLjA7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHdpZHRoPXNlbGYub3B0LndpZHRoKjE7XG5cdFx0XHRzZWxmLm9wdC53aWR0aD13aWR0aDtcblx0XHRcdFxuXHRcdFx0aWYgKHNlbGYub3B0LmhlaWdodC5pbmRleE9mKFwiJVwiKSE9LTEpXG5cdFx0XHRcdGhlaWdodCA9IGhlaWdodCooc2VsZi5vcHQuaGVpZ2h0LnN1YnN0cmluZygwLCBzZWxmLm9wdC5oZWlnaHQubGVuZ3RoLTEpKjEpLzEwMC4wO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRoZWlnaHQ9c2VsZi5vcHQuaGVpZ2h0KjE7XG5cdFx0XHRzZWxmLm9wdC5oZWlnaHQ9aGVpZ2h0O1xuXHRcdFx0XG5cdFx0XHR0aGlzLl9jb250YWluZXIud2lkdGgod2lkdGgpO1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLmhlaWdodChoZWlnaHQpO1xuXHRcdFx0XG5cdFx0XHRzZWxmLmNvbG9yID0gZnVuY3Rpb24oKSB7XG5cdFx0XHQgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShzZWxmLmNvbG9ycyk7XG5cdFx0XHR9KCk7XG5cblx0XHRcdHNlbGYuem9vbT1kMy5iZWhhdmlvci56b29tKCkuXG4gICAgXHRcdHNjYWxlRXh0ZW50KFsoc2VsZi5vcHQuZW5hYmxlRWRnZXMpPzE6MC4xLCAxMF0pXG4gICAgXHRcdC5vbihcInpvb21cIiwgcmVkcmF3KTtcblx0XHRcdHNlbGYudmlzID0gZDMuc2VsZWN0KFwiI1wiK3NlbGYub3B0LnRhcmdldCkuYXBwZW5kKFwic3ZnXCIpXG5cdFx0XHQgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcblx0XHRcdCAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXG5cdFx0XHQgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKVxuXHRcdFx0ICAgIC5jYWxsKHNlbGYuem9vbSlcblx0XHRcdCAgICAuYXBwZW5kKCdzdmc6ZycpO1xuXHRcdFx0XG5cdFx0XHRzZWxmLnZpcy5hcHBlbmQoJ3N2ZzpyZWN0Jylcblx0XHRcdCAgICAuYXR0cignd2lkdGgnLCB3aWR0aCoyMClcblx0XHRcdCAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KjIwKVxuXHRcdFx0ICAgIC5hdHRyKCd4JywgLXdpZHRoKjEwKVxuXHRcdFx0ICAgIC5hdHRyKCd5JywgLWhlaWdodCoxMClcblx0XHRcdCAgICAuYXR0cignZmlsbCcsICd3aGl0ZScpXG5cdFx0XHQgICAgLmF0dHIoJ3N0cm9rZScsJ3doaXRlJyk7XG5cblx0XHRcdHNlbGYucmVjdD0gc2VsZi52aXMuYXBwZW5kKCdzdmc6cmVjdCcpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJmcmFtZVwiKVxuXHRcdFx0ICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuXHRcdFx0ICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG5cdFx0XHQgICAgLmF0dHIoJ2ZpbGwnLCAnd2hpdGUnKVxuXHRcdFx0ICAgIC5hdHRyKCdzdHJva2UnLCd3aGl0ZScpXG5cdFx0XHQgICAgLmF0dHIoXCJzdHJva2UtZGFzaGFycmF5XCIsXCI1LDVcIik7XG5cblxuXHRcdFx0c2VsZi5wZXJzcGVjdGl2ZT1kMy5zZWxlY3QoXCIjXCIrc2VsZi5vcHQudGFyZ2V0ICsgXCIgc3ZnXCIpLmFwcGVuZCgnc3ZnOmcnKTtcblx0XHRcdFxuXHRcdFx0IFxuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbiByZWRyYXcoeCx5LHNjYWxlUCkge1xuXHRcdFx0XHR2YXIgdHJhbnM9bnVsbCxzY2FsZT1udWxsO1xuXHRcdFx0XHRpZiAodHlwZW9mIHghPVwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHkhPVwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRcdHRyYW5zPVt4LHldO1xuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGVQO1xuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR0cmFucz1kMy5ldmVudC50cmFuc2xhdGU7XG5cdFx0XHRcdFx0c2NhbGUgPSBkMy5ldmVudC5zY2FsZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnRUcmFuc2xhdGU9dHJhbnM7XG5cdFx0XHRcdHNlbGYudFNjYWxlPXNjYWxlO1xuXHRcdFx0XHRpZiAoc2VsZi5vcHQuZW5hYmxlRWRnZXMpIHtcblx0XHRcdFx0XHRpZihzY2FsZTwxKXNjYWxlPTE7XG5cdFx0XHRcdFx0ZDMuYmVoYXZpb3Iuem9vbSgpLnNjYWxlRXh0ZW50KFsxLCBJbmZpbml0eV0pO1xuXHRcdFx0XHRcdCAgaWYgKHRyYW5zWzBdPjApdHJhbnNbMF09MDtcblx0XHRcdFx0XHQgIGlmICh0cmFuc1sxXT4wKXRyYW5zWzFdPTA7XG5cdFxuXHRcdFx0XHRcdCAgdmFyIFcgPSBzZWxmLnJlY3RbMF1bMF0ud2lkdGguYW5pbVZhbC52YWx1ZSwgSD0gc2VsZi5yZWN0WzBdWzBdLmhlaWdodC5hbmltVmFsLnZhbHVlO1xuXHRcdFx0XHRcdCAgdmFyIFdzID0gVypzY2FsZSwgSHMgPSBIKnNjYWxlO1xuXHRcdFx0XHRcdCAgaWYgKFdzPFctdHJhbnNbMF0pIHRyYW5zWzBdPVctV3M7XG5cdFx0XHRcdFx0ICBpZiAoSHM8SC10cmFuc1sxXSkgdHJhbnNbMV09SC1Icztcblx0XHRcdFx0fVxuXHRcdFx0XHQgIHNlbGYudmlzLmF0dHIoXCJ0cmFuc2Zvcm1cIixcblx0XHRcdFx0ICAgICAgXCJ0cmFuc2xhdGUoXCIgKyB0cmFucyArIFwiKVwiXG5cdFx0XHRcdCAgICAgICsgXCIgc2NhbGUoXCIgKyBzY2FsZSArIFwiKVwiKTtcblx0XHRcdH07XG5cdFx0XHRzZWxmLnJlZHJhdz1yZWRyYXc7XG5cdFx0XHRcblx0XHRcdHNlbGYuZm9yY2UgPSBkMy5sYXlvdXQuZm9yY2UoKVxuXHRcdFx0ICAgIC5ub2RlcyhzZWxmLnByb3RlaW5zKVxuXHRcdFx0ICAgIC5saW5rcyhzZWxmLmludGVyYWN0aW9ucylcblx0XHRcdCAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pO1xuXHRcdFx0XG5cdFx0XHRcblx0XHRcdHNlbGYubm9kZV9kcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpXG5cdFx0XHRcdC5vbihcImRyYWdzdGFydFwiLCBkcmFnc3RhcnQpXG5cdFx0XHRcdC5vbihcImRyYWdcIiwgZHJhZ21vdmUpXG5cdFx0XHRcdC5vbihcImRyYWdlbmRcIiwgZHJhZ2VuZCk7XG5cblx0XHRcdGZ1bmN0aW9uIGRyYWdzdGFydChkLCBpKSB7XG5cdFx0XHRcdHNlbGYuZm9yY2Uuc3RvcCgpOyAvLyBzdG9wcyB0aGUgZm9yY2UgYXV0byBwb3NpdGlvbmluZyBiZWZvcmUgeW91IHN0YXJ0IGRyYWdnaW5nXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGRyYWdtb3ZlKGQsIGkpIHtcblx0XHRcdFx0ZC5weCArPSBkMy5ldmVudC5keDtcblx0XHRcdFx0ZC5weSArPSBkMy5ldmVudC5keTtcblx0XHRcdFx0ZC54ICs9IGQzLmV2ZW50LmR4O1xuXHRcdFx0XHRkLnkgKz0gZDMuZXZlbnQuZHk7IFxuXHRcdFx0XHR0aWNrKGQzLmV2ZW50KTsgLy8gdGhpcyBpcyB0aGUga2V5IHRvIG1ha2UgaXQgd29yayB0b2dldGhlciB3aXRoIHVwZGF0aW5nIGJvdGggcHgscHkseCx5IG9uIGQgIVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBkcmFnZW5kKGQsIGkpIHtcblx0XHRcdFx0ZC5maXhlZCA9IHRydWU7IC8vIG9mIGNvdXJzZSBzZXQgdGhlIG5vZGUgdG8gZml4ZWQgc28gdGhlIGZvcmNlIGRvZXNuJ3QgaW5jbHVkZSB0aGUgbm9kZSBpbiBpdHMgYXV0byBwb3NpdGlvbmluZyBzdHVmZlxuXHRcdFx0XHR0aWNrKGQzLmV2ZW50KTtcblx0XHRcdFx0c2VsZi5mb3JjZS5yZXN1bWUoKTtcblx0XHRcdH1cblx0XHRcdHNlbGYuZm9yY2Uub24oXCJ0aWNrXCIsIHRpY2spO1xuXHRcdFx0ZnVuY3Rpb24gdGljayhlKSB7XG5cdFx0XHRcdGlmIChlLnR5cGU9PVwidGlja1wiKXtcblx0XHRcdFx0XHR2YXIgayA9IC4xICogZS5hbHBoYTtcblx0XHRcdFx0XHRzZWxmLnByb3RlaW5zLmZvckVhY2goZnVuY3Rpb24obywgaSkge1xuXHRcdFx0XHRcdFx0by55ICs9IChzZWxmLmZvY2lbc2VsZi5vcmdhbmlzbXNbby5vcmdhbmlzbV1dLnkgLSBvLnkpICogaztcblx0XHRcdFx0XHRcdG8ueCArPSAoc2VsZi5mb2NpW3NlbGYub3JnYW5pc21zW28ub3JnYW5pc21dXS54IC0gby54KSAqIGs7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi52aXMuc2VsZWN0QWxsKFwicGF0aC5maWd1cmVcIilcblx0XHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgXG5cdFx0XHRcdFx0XHRcdGlmIChzZWxmLm9wdC5lbmFibGVFZGdlcylcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBNYXRoLm1heChyLCBNYXRoLm1pbihzZWxmLm9wdC53aWR0aCAsIGQueCtyKSkgKyBcIixcIiArIE1hdGgubWF4KHIsIE1hdGgubWluKHNlbGYub3B0LmhlaWdodCwgZC55K3IpKSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwidHJhbnNsYXRlKFwiICsgZC54ICsgXCIsXCIgKyAgZC55ICsgXCIpXCI7IFxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0aWYgKHNlbGYub3B0LmVuYWJsZUVkZ2VzKSBcblx0XHRcdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoXCIubGVnZW5kXCIpXG5cdFx0XHRcdFx0XHQuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54ID0gTWF0aC5tYXgociwgTWF0aC5taW4oc2VsZi5vcHQud2lkdGggLSByLCBkLngpKTsgfSlcblx0XHRcdFx0XHRcdC5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgPSBNYXRoLm1heChyLCBNYXRoLm1pbihzZWxmLm9wdC5oZWlnaHQgLSByLCBkLnkpKTsgfSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoXCIubGVnZW5kXCIpXG5cdFx0XHRcdFx0XHQuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54OyB9KVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueTsgfSk7XG5cdFx0XHRcdGlmIChzZWxmLm9wdC5lbmFibGVFZGdlcykgXG5cdFx0XHRcdFx0c2VsZi52aXMuc2VsZWN0QWxsKFwibGluZS5saW5rXCIpXG5cdFx0XHRcdFx0XHQuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc291cmNlLngrcjsgfSlcblx0XHRcdFx0XHRcdC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2UueStyOyB9KVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnRhcmdldC54K3I7IH0pXG5cdFx0XHRcdFx0XHQuYXR0cihcInkyXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudGFyZ2V0LnkrcjsgfSk7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoXCJsaW5lLmxpbmtcIilcblx0XHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2UueDsgfSlcblx0XHRcdFx0XHRcdC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2UueTsgfSlcblx0XHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50YXJnZXQueDsgfSlcblx0XHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50YXJnZXQueTsgfSk7XG5cdFx0XHR9O1xuXHRcdFx0c2VsZi50aWNrPXRpY2s7XG5cdFx0XHQvL0JpbmRpbmcgdGhlIF9yZXNpemUgbWV0aG9kIHdoZW4gcmVzaXppbmcgdGhlIHdpbmRvdyEgXG5cdFx0XHQvL2QzLnNlbGVjdCh3aW5kb3cpLm9uKFwicmVzaXplXCIsIGZ1bmN0aW9uKCl7c2VsZi5fcmVzaXplKHNlbGYpO30pO1xuXHRcdFx0XG5cdFx0XHRzZWxmLnJlc3RhcnQoKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqICBEZWZhdWx0IHZhbHVlcyBmb3IgdGhlIG9wdGlvbnNcblx0XHQgKiAgQG5hbWUgQmlvanMuSW50ZXJhY3Rpb25zRDMtb3B0XG5cdFx0ICovXG5cdFx0b3B0OiB7XG5cdFx0XHR0YXJnZXQ6IFwiWW91ck93bkRpdklkXCIsXG5cdFx0XHR3aWR0aDogXCIxMDAlXCIsXG5cdFx0XHRoZWlnaHQ6IFwiNTAwXCIsIFxuXHRcdFx0cmFkaXVzOiAxMCxcblx0XHRcdGVuYWJsZUVkZ2VzOmZhbHNlXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFycmF5IGNvbnRhaW5pbmcgdGhlIHN1cHBvcnRlZCBldmVudCBuYW1lc1xuXHRcdCAqIEBuYW1lIEJpb2pzLkludGVyYWN0aW9uc0QzLWV2ZW50VHlwZXNcblx0XHQgKi9cblx0XHRldmVudFR5cGVzIDogW1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBAbmFtZSBCaW9qcy5JbnRlcmFjdGlvbnNEMyNwcm90ZWluQ2xpY2tcblx0XHRcdCAqIEBldmVudFxuXHRcdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gYWN0aW9uUGVyZm9ybWVkIEl0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIHByb3RlaW5cblx0XHRcdCAqIEBldmVudERhdGEge0BsaW5rIEJpb2pzLkV2ZW50fSBvYmpFdmVudCBPYmplY3QgY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gb2YgdGhlIGV2ZW50XG5cdFx0XHQgKiBAZXZlbnREYXRhIHtPYmplY3R9IG9iakV2ZW50LnNvdXJjZSBUaGUgY29tcG9uZW50IHdoaWNoIGRpZCB0cmlnZ2VyZWQgdGhlIGV2ZW50LlxuXHRcdFx0ICogQGV2ZW50RGF0YSB7T2JqZWN0fSBvYmpFdmVudC5wcm90ZWluIHRoZSBpbmZvcm1hdGlvbiBvZiB0aGUgcHJvdGVpbiB0aGF0IGhhcyBiZWVuIGNsaWNrZWQuXG5cdFx0XHQgKiBAZXhhbXBsZSBcblx0XHRcdCAqIGluc3RhbmNlLnByb3RlaW5DbGljayhcblx0XHRcdCAqICAgIGZ1bmN0aW9uKCBvYmpFdmVudCApIHtcblx0XHRcdCAqICAgICAgIGFsZXJ0KFwiVGhlIHByb3RlaW4gXCIgKyBvYmpFdmVudC5wcm90ZWluLmlkICsgXCIgd2FzIGNsaWNrZWQuXCIpO1xuXHRcdFx0ICogICAgfVxuXHRcdFx0ICogKTsgXG5cdFx0XHQgKiBcblx0XHRcdCAqICovXG5cdFx0XHRcInByb3RlaW5DbGlja1wiLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAbmFtZSBCaW9qcy5JbnRlcmFjdGlvbnNEMyNwcm90ZWluTW91c2VPdmVyXG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGFjdGlvblBlcmZvcm1lZCBJdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgbW91c2UgcG9pbnRlciBpcyBvdmVyIGEgcHJvdGVpblxuXHRcdFx0ICogQGV2ZW50RGF0YSB7QGxpbmsgQmlvanMuRXZlbnR9IG9iakV2ZW50IE9iamVjdCBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBvZiB0aGUgZXZlbnRcblx0XHRcdCAqIEBldmVudERhdGEge09iamVjdH0gb2JqRXZlbnQuc291cmNlIFRoZSBjb21wb25lbnQgd2hpY2ggZGlkIHRyaWdnZXJlZCB0aGUgZXZlbnQuXG5cdFx0XHQgKiBAZXZlbnREYXRhIHtPYmplY3R9IG9iakV2ZW50LnByb3RlaW4gdGhlIGluZm9ybWF0aW9uIG9mIHRoZSBwcm90ZWluIHRoYXQgaGFzIGJlZW4gbW91c2VvdmVyLlxuXHRcdFx0ICogQGV4YW1wbGUgXG5cdFx0XHQgKiBpbnN0YW5jZS5wcm90ZWluTW91c2VPdmVyKFxuXHRcdFx0ICogICAgZnVuY3Rpb24oIG9iakV2ZW50ICkge1xuXHRcdFx0ICogICAgICAgYWxlcnQoXCJUaGUgbW91c2UgaXMgb3ZlciB0aGUgcHJvdGVpbiBcIiArIG9iakV2ZW50LnByb3RlaW4uaWQpO1xuXHRcdFx0ICogICAgfVxuXHRcdFx0ICogKTsgXG5cdFx0XHQgKiBcblx0XHRcdCAqICovXG5cdFx0XHRcInByb3RlaW5Nb3VzZU92ZXJcIixcblx0XHRcdC8qKlxuXHRcdFx0ICogQG5hbWUgQmlvanMuSW50ZXJhY3Rpb25zRDMjcHJvdGVpbk1vdXNlT3V0XG5cdFx0XHQgKiBAZXZlbnRcblx0XHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGFjdGlvblBlcmZvcm1lZCBJdCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgbW91c2UgcG9pbnRlciBsZWF2ZSB0aGUgYXJlYSBvZiBhIHByb3RlaW5cblx0XHRcdCAqIEBldmVudERhdGEge0BsaW5rIEJpb2pzLkV2ZW50fSBvYmpFdmVudCBPYmplY3QgY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gb2YgdGhlIGV2ZW50XG5cdFx0XHQgKiBAZXZlbnREYXRhIHtPYmplY3R9IG9iakV2ZW50LnNvdXJjZSBUaGUgY29tcG9uZW50IHdoaWNoIGRpZCB0cmlnZ2VyZWQgdGhlIGV2ZW50LlxuXHRcdFx0ICogQGV2ZW50RGF0YSB7T2JqZWN0fSBvYmpFdmVudC5wcm90ZWluIHRoZSBpbmZvcm1hdGlvbiBvZiB0aGUgcHJvdGVpbiB0aGF0IGhhcyBiZWVuIG1vdXNlb3V0LlxuXHRcdFx0ICogQGV4YW1wbGUgXG5cdFx0XHQgKiBpbnN0YW5jZS5wcm90ZWluTW91c2VPdXQoXG5cdFx0XHQgKiAgICBmdW5jdGlvbiggb2JqRXZlbnQgKSB7XG5cdFx0XHQgKiAgICAgICBhbGVydChcIlRoZSBtb3VzZSBpcyBvdXQgdGhlIHByb3RlaW4gXCIgKyBvYmpFdmVudC5wcm90ZWluLmlkKTtcblx0XHRcdCAqICAgIH1cblx0XHRcdCAqICk7IFxuXHRcdFx0ICogXG5cdFx0XHQgKiAqL1xuXHRcdFx0XCJwcm90ZWluTW91c2VPdXRcIixcblx0XHRcdC8qKlxuXHRcdFx0ICogQG5hbWUgQmlvanMuSW50ZXJhY3Rpb25zRDMjaW50ZXJhY3Rpb25DbGlja1xuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhY3Rpb25QZXJmb3JtZWQgQSBmdW5jdGlvbiB3aGljaCByZWNlaXZlcyBhbiB7QGxpbmsgQmlvanMuRXZlbnR9IG9iamVjdCBhcyBhcmd1bWVudC5cblx0XHRcdCAqIEBldmVudERhdGEge09iamVjdH0gc291cmNlIFRoZSBjb21wb25lbnQgd2hpY2ggZGlkIHRyaWdnZXJlZCB0aGUgZXZlbnQuXG5cdFx0XHQgKiBAZXZlbnREYXRhIHtPYmplY3R9IGludGVyYWN0aW9uIHRoZSBpbmZvcm1hdGlvbiBvZiB0aGUgaW50ZXJhY3Rpb24gdGhhdCBoYXMgYmVlbiBjbGlja2VkLlxuXHRcdFx0ICogQGV4YW1wbGUgXG5cdFx0XHQgKiBpbnN0YW5jZS5pbnRlcmFjdGlvbkNsaWNrKFxuXHRcdFx0ICogICAgZnVuY3Rpb24oIG9iakV2ZW50ICkge1xuXHRcdFx0ICogICAgICAgYWxlcnQoXCJDbGljayBvbiB0aGUgaW50ZXJhY3Rpb24gXCIgKyBvYmpFdmVudC5pbnRlcmFjdGlvbi5zb3VyY2UuaWQgK1wiIC0gXCIrIG9iakV2ZW50LmludGVyYWN0aW9uLnRhcmdldC5pZCk7XG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiApOyBcblx0XHRcdCAqIFxuXHRcdFx0ICogKi9cblx0XHRcdFwiaW50ZXJhY3Rpb25DbGlja1wiLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAbmFtZSBCaW9qcy5JbnRlcmFjdGlvbnNEMyNpbnRlcmFjdGlvbk1vdXNlT3ZlclxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhY3Rpb25QZXJmb3JtZWQgQSBmdW5jdGlvbiB3aGljaCByZWNlaXZlcyBhbiB7QGxpbmsgQmlvanMuRXZlbnR9IG9iamVjdCBhcyBhcmd1bWVudC5cblx0XHRcdCAqIEBldmVudERhdGEge09iamVjdH0gc291cmNlIFRoZSBjb21wb25lbnQgd2hpY2ggZGlkIHRyaWdnZXJlZCB0aGUgZXZlbnQuXG5cdFx0XHQgKiBAZXZlbnREYXRhIHtPYmplY3R9IGludGVyYWN0aW9uIHRoZSBpbmZvcm1hdGlvbiBvZiB0aGUgaW50ZXJhY3Rpb24gdGhhdCBoYXMgYmVlbiBtb3VzZW92ZXIuXG5cdFx0XHQgKiBAZXhhbXBsZSBcblx0XHRcdCAqIGluc3RhbmNlLmludGVyYWN0aW9uTW91c2VPdmVyKFxuXHRcdFx0ICogICAgZnVuY3Rpb24oIG9iakV2ZW50ICkge1xuXHRcdFx0ICogICAgICAgYWxlcnQoXCJUaGUgbW91c2UgaXMgb3ZlciB0aGUgaW50ZXJhY3Rpb24gXCIgKyBvYmpFdmVudC5pbnRlcmFjdGlvbi5zb3VyY2UuaWQgK1wiIC0gXCIrIG9iakV2ZW50LmludGVyYWN0aW9uLnRhcmdldC5pZCk7XG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiApOyBcblx0XHRcdCAqIFxuXHRcdFx0ICogKi9cblx0XHRcdFwiaW50ZXJhY3Rpb25Nb3VzZU92ZXJcIixcblx0XHRcdC8qKlxuXHRcdFx0ICogQG5hbWUgQmlvanMuSW50ZXJhY3Rpb25zRDMjaW50ZXJhY3Rpb25Nb3VzZU91dFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhY3Rpb25QZXJmb3JtZWQgSXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIG1vdXNlIHBvaW50ZXIgbGVhdmUgYW4gaW50ZXJhY3Rpb25cblx0XHRcdCAqIEBldmVudERhdGEge0BsaW5rIEJpb2pzLkV2ZW50fSBvYmpFdmVudCBPYmplY3QgY29udGFpbmluZyB0aGUgaW5mb3JtYXRpb24gb2YgdGhlIGV2ZW50XG5cdFx0XHQgKiBAZXZlbnREYXRhIHtPYmplY3R9IHNvdXJjZSBUaGUgY29tcG9uZW50IHdoaWNoIGRpZCB0cmlnZ2VyZWQgdGhlIGV2ZW50LlxuXHRcdFx0ICogQGV2ZW50RGF0YSB7T2JqZWN0fSBpbnRlcmFjdGlvbiB0aGUgaW5mb3JtYXRpb24gb2YgdGhlIGludGVyYWN0aW9uIHRoYXQgaGFzIGJlZW4gbW91c2VvdXQuXG5cdFx0XHQgKiBAZXhhbXBsZSBcblx0XHRcdCAqIGluc3RhbmNlLmludGVyYWN0aW9uTW91c2VPdXQoXG5cdFx0XHQgKiAgICBmdW5jdGlvbiggb2JqRXZlbnQgKSB7XG5cdFx0XHQgKiAgICAgIGFsZXJ0KFwiVGhlIG1vdXNlIGlzIG91dCBvZiB0aGUgaW50ZXJhY3Rpb24gXCIgKyBvYmpFdmVudC5pbnRlcmFjdGlvbi5zb3VyY2UuaWQgK1wiIC0gXCIrIG9iakV2ZW50LmludGVyYWN0aW9uLnRhcmdldC5pZCk7XG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiApOyBcblx0XHRcdCAqIFxuXHRcdFx0ICogKi9cblx0XHRcdFwiaW50ZXJhY3Rpb25Nb3VzZU91dFwiLFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBAbmFtZSBCaW9qcy5JbnRlcmFjdGlvbnNEMyNzaXplQ2hhbmdlZFxuXHRcdFx0ICogQGV2ZW50XG5cdFx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhY3Rpb25QZXJmb3JtZWQgSXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHNpemUgb2YgdGhlIFNWRyBlbGVtZW50IGhhcyBiZWVuIGNoYW5nZWQuIFxuXHRcdFx0ICogQGV2ZW50RGF0YSB7QGxpbmsgQmlvanMuRXZlbnR9IG9iakV2ZW50IE9iamVjdCBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbiBvZiB0aGUgZXZlbnRcblx0XHRcdCAqIEBldmVudERhdGEge09iamVjdH0gc291cmNlIFRoZSBjb21wb25lbnQgd2hpY2ggZGlkIHRyaWdnZXJlZCB0aGUgZXZlbnQuXG5cdFx0XHQgKiBAZXZlbnREYXRhIHtPYmplY3R9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgbmV3IHNpemVcblx0XHRcdCAqIEBldmVudERhdGEge09iamVjdH0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIG5ldyBzaXplXG5cdFx0XHQgKiBAZXhhbXBsZSBcblx0XHRcdCAqIGluc3RhbmNlLnNpemVDaGFuZ2VkKFxuXHRcdFx0ICogICAgZnVuY3Rpb24oIG9iakV2ZW50ICkge1xuXHRcdFx0ICogICAgICBhbGVydChcIlRoZSBzaXplIGhhcyBjaGFuZ2VkOiAoXCIrb2JqRXZlbnQud2lkdGgrXCIsXCIrb2JqRXZlbnQuaGVpZ2h0K1wiKVwiICk7XG5cdFx0XHQgKiAgICB9XG5cdFx0XHQgKiApOyBcblx0XHRcdCAqIFxuXHRcdFx0ICogKi9cblx0XHRcdFwic2l6ZUNoYW5nZWRcIlxuXHRcdF0sIFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqIGFsbG93cyB0byByZXNpemUgdGhlIFNWRyBlbGVtZW50IHVwZGF0aW5nIHRoZSBncmF2aXR5IHBvaW50c1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCB2YWx1ZSBvZiB3aWR0aCB0byBiZSBhc3NpZ24gdG8gdGhlIFNWR1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBoZWlnaHQgdmFsdWUgb2YgaGVpZ2h0IHRvIGJlIGFzc2lnbiB0byB0aGUgU1ZHXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5zZXRTaXplKDQwMCw0MDApO1xuXHRcdCAqIGluc3RhbmNlLnJlc3RhcnQoKTtcblx0XHQgKi9cblx0XHRzZXRTaXplOmZ1bmN0aW9uKHdpZHRoLGhlaWdodCl7XG5cdFx0XHR2YXIgc2VsZiA9dGhpcztcblx0XHRcdHNlbGYub3B0LndpZHRoPXdpZHRoO1xuXHRcdFx0c2VsZi5vcHQuaGVpZ2h0PWhlaWdodDtcblx0XHRcdGQzLnNlbGVjdChcIiNcIitzZWxmLm9wdC50YXJnZXQrXCIgc3ZnXCIpXG5cdFx0XHQgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpXG5cdFx0XHQgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCk7XG5cdFx0XHRkMy5zZWxlY3QoXCIjXCIrc2VsZi5vcHQudGFyZ2V0K1wiIC5mcmFtZVwiKVxuXHRcdFx0ICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuXHRcdFx0ICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuXG5cdFx0XHRzZWxmLl9jb250YWluZXIud2lkdGgod2lkdGgpO1xuXHRcdFx0c2VsZi5fY29udGFpbmVyLmhlaWdodChoZWlnaHQpO1xuXHRcdFx0dmFyIG51bWJlck9mT3JnYW5pc20gPU9iamVjdC5rZXlzKHNlbGYub3JnYW5pc21zKS5sZW5ndGg7XG5cdFx0XHRzZWxmLmZvY2k9W107XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bnVtYmVyT2ZPcmdhbmlzbTsgaSsrKXtcblx0XHRcdFx0c2VsZi5mb2NpLnB1c2goe3g6IChzZWxmLm9wdC53aWR0aC8obnVtYmVyT2ZPcmdhbmlzbSsxKSkqKGkrMSksIHk6c2VsZi5vcHQuaGVpZ2h0LzJ9KTtcblx0XHRcdH1cblx0XHRcdGlmIChzZWxmLnRUcmFuc2xhdGUhPW51bGwpIHNlbGYucmVkcmF3KHNlbGYudFRyYW5zbGF0ZVswXSwgc2VsZi50VHJhbnNsYXRlWzFdLCBzZWxmLnRTY2FsZSk7XG5cdFx0XHRzZWxmLnJlc3RhcnQoKTtcblx0XHRcdHNlbGYudHJpZ2dlcignc2l6ZUNoYW5nZWQnLCB7XG5cdFx0XHRcdHdpZHRoOndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6aGVpZ2h0XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYW4gaW50ZXJhY3Rpb24gYmV0d2VlbiAyIHByb3RlaW5zIHRoYXQgYXJlIGFscmVhZHkgaW4gdGhlIGdyYXBoaWMgdXNpbmcgdGhlaXIgSURzXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3RlaW5JZDEgSWQgb2YgdGhlIGZpcnN0IHByb3RlaW4gaW4gdGhlIGludGVyYWN0aW9uXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3RlaW5JZDIgSWQgb2YgdGhlIHNlY29uZCBwcm90ZWluIGluIHRoZSBpbnRlcmFjdGlvblxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFBdHJpYnV0ZXM9e31dIEFuIG9iamVjdCBjb250YWluaW5nIG1ldGEgaW5mb3JtYXRpb24gb2YgdGhlIGludGVyYWN0aW9uIFxuXHRcdCAqIFx0XHRcdFx0XHR0byBiZSBzdG9yZWQgaW4gdGhlIGludGVyYWN0aW9uIGl0c2VsZi4gdXNlZnVsIGZvciB0cmlnZ2VyZWQgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5hZGRJbnRlcmFjdGlvbihNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpKjE1KSsxKSxNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpKjE1KSsxKSAse3Njb3JlOk1hdGgucmFuZG9tKCl9KTtcblx0XHQgKiBpbnN0YW5jZS5yZXN0YXJ0KCk7XG5cdFx0ICovXG5cdFx0YWRkSW50ZXJhY3Rpb246IGZ1bmN0aW9uKHByb3RlaW5JZDEscHJvdGVpbklkMixleHRyYUF0cmlidXRlcykge1xuXHRcdFx0dmFyIHNlbGY9dGhpcztcblxuXHRcdFx0Ly8gR2V0dGluZyB0aGUgcHJvdGVpbiB3aXRoIHRoZSBmaXJzdCBpZCBhbmQgY2hlY2tpbmcgZXhpc3RzIGluIHRoZSBncmFwaGljXG5cdFx0XHR2YXIgcHJvdGVpbjE9IHNlbGYuZ2V0UHJvdGVpbihwcm90ZWluSWQxKTtcblx0XHRcdGlmICh0eXBlb2YgcHJvdGVpbjE9PVwidW5kZWZpbmVkXCIpcmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHQvLyBHZXR0aW5nIHRoZSBwcm90ZWluIHdpdGggdGhlIHNlY29uZCBpZCBhbmQgY2hlY2tpbmcgZXhpc3RzIGluIHRoZSBncmFwaGljXG5cdFx0XHR2YXIgcHJvdGVpbjI9IHNlbGYuZ2V0UHJvdGVpbihwcm90ZWluSWQyKTtcblx0XHRcdGlmICh0eXBlb2YgcHJvdGVpbjI9PVwidW5kZWZpbmVkXCIpcmV0dXJuIGZhbHNlO1xuXHRcdFx0XG5cdFx0XHQvL0NoZWNraW5nIHRoZXJlIGlzIG5vdCBhbiBpbnRlcmFjdGlvbiBiZXR3ZWVuIHRob3NlIHByb3RlaW5zIGFscmVhZHkgaW4gdGhlIGdyYXBoaWNcblx0XHRcdGlmICh0eXBlb2Ygc2VsZi5pbnRlcmFjdGlvbnNBW3Byb3RlaW5JZDFdIT1cInVuZGVmaW5lZFwiICYmIHNlbGYuaW50ZXJhY3Rpb25zQVtwcm90ZWluSWQxXS5pbmRleE9mKHByb3RlaW4yKSE9LTEpXG5cdFx0XHRcdHJldHVybiBzZWxmLmludGVyYWN0aW9uc0FbcHJvdGVpbklkMV0uaW5kZXhPZihwcm90ZWluMik7XG5cdFx0XHRcdFxuXHRcdFx0Ly9jcmVhdGluZyBhbmQgYWRkaW5nIGFuIGludGVyYWN0aW9uXG5cdFx0XHR2YXIgaW50ZXJhY3Rpb24gPSB7c291cmNlOnByb3RlaW4xLHRhcmdldDpwcm90ZWluMn07XG5cdFx0XHQvL2FkZGluZyBhbnkgcGFyYW1ldGVycyBmcm9tIHRoZSBvYmplY3QgZXh0cmFBdHJpYnV0ZXMgdG8gdGhlIGludGVyYWN0aW9uIG9iamVjdFxuXHRcdFx0aWYgKHR5cGVvZiBleHRyYUF0cmlidXRlcyE9XCJ1bmRlZmluZWRcIilcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGV4dHJhQXRyaWJ1dGVzKVxuXHRcdFx0XHRcdGludGVyYWN0aW9uW2tleV09ZXh0cmFBdHJpYnV0ZXNba2V5XTtcblxuXHRcdFx0dmFyIG49IHNlbGYuaW50ZXJhY3Rpb25zLnB1c2goaW50ZXJhY3Rpb24pO1xuXHRcdFx0XG5cdFx0XHQvL1NhdmluZyB0aGUgaW50ZXJhY3Rpb24gaW4gdGhlIGFzc29jaWF0aXZlIGFycmF5XG5cdFx0XHRpZiAodHlwZW9mIHNlbGYuaW50ZXJhY3Rpb25zQVtpbnRlcmFjdGlvbi5zb3VyY2UuaWRdID09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHRcdHNlbGYuaW50ZXJhY3Rpb25zQVtpbnRlcmFjdGlvbi5zb3VyY2UuaWRdPVtpbnRlcmFjdGlvbi50YXJnZXRdO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzZWxmLmludGVyYWN0aW9uc0FbaW50ZXJhY3Rpb24uc291cmNlLmlkXS5wdXNoKGludGVyYWN0aW9uLnRhcmdldCk7XG5cdFx0XHRpZiAodHlwZW9mIHNlbGYuaW50ZXJhY3Rpb25zQVtpbnRlcmFjdGlvbi50YXJnZXQuaWRdID09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHRcdHNlbGYuaW50ZXJhY3Rpb25zQVtpbnRlcmFjdGlvbi50YXJnZXQuaWRdPVtpbnRlcmFjdGlvbi5zb3VyY2VdO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRzZWxmLmludGVyYWN0aW9uc0FbaW50ZXJhY3Rpb24udGFyZ2V0LmlkXS5wdXNoKGludGVyYWN0aW9uLnNvdXJjZSk7XG5cblx0XHRcdHJldHVybiBuO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQWRkcyBhIHByb3RlaW4gdG8gdGhlIGdyYXBoaWNcblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcHJvdGVpbiBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvZiB0aGUgcHJvdGVpbiBcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqICBpbnN0YW5jZS5hZGRQcm90ZWluKHsgXCJpZFwiOlwibmV3XCIsXCJuYW1lXCI6XCJuZXdcIixcInNob3dMZWdlbmRcIjp0cnVlLFwidHlwZUxlZ2VuZFwiOlwiaWRcIixcIm9yZ2FuaXNtXCI6XCJodW1hblwiK3BpZCUzLFwiZmVhdHVyZXNcIjp7XCJmMVwiOlwidmFsMVwiLFwiZjJcIjpcInZhbDJcIixcImYzXCI6XCJ2YWwzXCJ9fSk7XG5cdFx0ICogaW5zdGFuY2UucmVzdGFydCgpO1xuXHRcdCAqL1xuXHRcdGFkZFByb3RlaW46IGZ1bmN0aW9uKHByb3RlaW4pIHtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHR2YXIgbiA9IHNlbGYucHJvdGVpbnMuaW5kZXhPZihzZWxmLnByb3RlaW5zQVtwcm90ZWluLmlkXSk7XG5cdFx0XHRpZiAobiE9LTEpXG5cdFx0XHRcdHJldHVybiBuO1xuXHRcdFx0aWYgKHR5cGVvZiBzZWxmLmZpeGVkUHJvdGVpbnNbcHJvdGVpbi5pZF09PVwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRwcm90ZWluLng9TWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSpzZWxmLm9wdC53aWR0aCkpO1xuXHRcdFx0XHRwcm90ZWluLnk9TWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSpzZWxmLm9wdC53aWR0aCkpO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdHByb3RlaW4ueD1zZWxmLmZpeGVkUHJvdGVpbnNbcHJvdGVpbi5pZF1bMF07XG5cdFx0XHRcdHByb3RlaW4ueT1zZWxmLmZpeGVkUHJvdGVpbnNbcHJvdGVpbi5pZF1bMV07XG5cdFx0XHRcdHByb3RlaW4uZml4ZWQ9dHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmKHR5cGVvZiBwcm90ZWluLnNpemUgPT0gXCJ1bmRlZmluZWRcIikgcHJvdGVpbi5zaXplPTE7XG5cdFx0XHRuPSBzZWxmLnByb3RlaW5zLnB1c2gocHJvdGVpbik7XG5cdFx0XHRzZWxmLnByb3RlaW5zQVtwcm90ZWluLmlkXT1wcm90ZWluO1xuXHRcdFx0aWYgKHR5cGVvZiBzZWxmLmludGVyYWN0aW9uc0FbcHJvdGVpbi5pZF0gPT0gXCJ1bmRlZmluZWRcIilcblx0XHRcdFx0c2VsZi5pbnRlcmFjdGlvbnNBW3Byb3RlaW4uaWRdPVtdO1xuXHRcdFx0aWYgKHR5cGVvZiBzZWxmLm9yZ2FuaXNtc1twcm90ZWluLm9yZ2FuaXNtXSA9PSAndW5kZWZpbmVkJyl7XG5cdFx0XHRcdHZhciBudW1iZXJPZk9yZ2FuaXNtID1PYmplY3Qua2V5cyhzZWxmLm9yZ2FuaXNtcykubGVuZ3RoO1xuXHRcdFx0XHRzZWxmLm9yZ2FuaXNtc1twcm90ZWluLm9yZ2FuaXNtXSA9IG51bWJlck9mT3JnYW5pc20rKztcblx0XHRcdFx0c2VsZi5mb2NpPVtdO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8bnVtYmVyT2ZPcmdhbmlzbTsgaSsrKXtcblx0XHRcdFx0XHRzZWxmLmZvY2kucHVzaCh7eDogKHNlbGYub3B0LndpZHRoLyhudW1iZXJPZk9yZ2FuaXNtKzEpKSooaSsxKSwgeTpzZWxmLm9wdC5oZWlnaHQvMn0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbjtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEdldHMgdGhlIHByb3RlaW4gb2JqZWN0IGJ5IGl0cyBpZFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90ZWluSWQgVGhlIGlkIG9mIHRoZSBwcm90ZWluXG5cdFx0ICogIFxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gcHJvdGVpbiBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvZiB0aGUgcHJvdGVpbiBcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGFsZXJ0KGluc3RhbmNlLmdldFByb3RlaW4oJzMnKSk7XG5cdFx0ICovXG5cdFx0Z2V0UHJvdGVpbjogZnVuY3Rpb24ocHJvdGVpbklkKSB7XG5cdFx0XHR2YXIgc2VsZj10aGlzO1xuXHRcdFx0cmV0dXJuIHNlbGYucHJvdGVpbnNBW3Byb3RlaW5JZF07XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBHZXRzIHRoZSBhcnJheSBpbmRleCBvZiB0aGUgaW50ZXJhY3Rpb24gb2JqZWN0IGJ5IHRoZSBpZHMgb2YgdGhlIGludGVyYWN0b3JzXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3RlaW5JZDEgVGhlIGlkIG9mIHRoZSBmaXJzdCBwcm90ZWluIGludGVyYWN0aW5nXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3RlaW5JZDIgVGhlIGlkIG9mIHRoZSBzZWNvbmQgcHJvdGVpbiBpbnRlcmFjdGluZ1xuXHRcdCAqICBcblx0XHQgKiBAcmV0dXJuIHtJbnRlZ2VyfSBBbiBpbnQgdmFsdWUgaW5kaWNhdGluZyB0aGUgaW5kZXggb2YgdGhlIGludGVyYWN0aW9uIGluIHRoZSBhcnJheSB0aGlzLmludGVyYWN0aW9ucyBcblx0XHQgKlxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGFsZXJ0KGluc3RhbmNlLmdldEludGVyYWN0aW9uSW5kZXgoJzMnLCc1JykpO1xuXHRcdCAqL1xuXHRcdGdldEludGVyYWN0aW9uSW5kZXg6IGZ1bmN0aW9uKHByb3RlaW5JZDEscHJvdGVpbklkMil7XG5cdFx0XHR2YXIgc2VsZiA9dGhpcztcblx0XHRcdGZvciAodmFyIGk9MDsgaTxzZWxmLmludGVyYWN0aW9ucy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHZhciBzb3VyY2VJZD1zZWxmLmludGVyYWN0aW9uc1tpXS5zb3VyY2UuaWQ7XG5cdFx0XHRcdHZhciB0YXJnZXRJZD1zZWxmLmludGVyYWN0aW9uc1tpXS50YXJnZXQuaWQ7XG5cdFx0XHRcdGlmICgoc291cmNlSWQ9PXByb3RlaW5JZDEgJiYgdGFyZ2V0SWQ9PXByb3RlaW5JZDIpfHwoc291cmNlSWQ9PXByb3RlaW5JZDIgJiYgdGFyZ2V0SWQ9PXByb3RlaW5JZDEpKVxuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIHRoZSBpbnRlcmFjdGlvbiBvYmplY3QgYnkgdGhlIGlkIG9mIGl0cyBwcm90ZWluc1xuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90ZWluSWQxIFRoZSBpZCBvZiB0aGUgZmlyc3QgcHJvdGVpblxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90ZWluSWQyIFRoZSBpZCBvZiB0aGUgc2Vjb25kIHByb3RlaW5cblx0XHQgKiAgXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBvZiB0aGUgaW50ZXJhY3Rpb24gXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBhbGVydChpbnN0YW5jZS5nZXRJbnRlcmFjdGlvbignMScsJzMnKSk7XG5cdFx0ICovXG5cdFx0Z2V0SW50ZXJhY3Rpb246IGZ1bmN0aW9uKHByb3RlaW5JZDEscHJvdGVpbklkMil7XG5cdFx0XHR2YXIgc2VsZiA9dGhpcztcblx0XHRcdHJldHVybiBzZWxmLmdldEludGVyYWN0aW9uSW5kZXgocHJvdGVpbklkMSxwcm90ZWluSWQyKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgZnJvbSB0aGUgZ3JhcGhpYyB0aGUgaW50ZXJhY3Rpb24gYnkgdGhlIGlkIG9mIGl0cyBwcm90ZWluc1xuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90ZWluSWQxIFRoZSBpZCBvZiB0aGUgZmlyc3QgcHJvdGVpblxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90ZWluSWQyIFRoZSBpZCBvZiB0aGUgc2Vjb25kIHByb3RlaW5cblx0XHQgKiAgXG5cdFx0ICogQGV4YW1wbGUgXG5cdFx0ICogaW5zdGFuY2UucmVtb3ZlSW50ZXJhY3Rpb24oJzInLCczJyk7XG5cdFx0ICovXG5cdFx0cmVtb3ZlSW50ZXJhY3Rpb246IGZ1bmN0aW9uKHByb3RlaW5JZDEscHJvdGVpbklkMil7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHR2YXIgaW50SW5kZXggPSBzZWxmLmdldEludGVyYWN0aW9uSW5kZXgocHJvdGVpbklkMSxwcm90ZWluSWQyKTtcblx0XHRcdHNlbGYuaW50ZXJhY3Rpb25zLnNwbGljZShpbnRJbmRleC0tLCAxKTtcblx0XHRcdFxuXHRcdFx0dmFyIHAxPXNlbGYuZ2V0UHJvdGVpbihwcm90ZWluSWQxKSxcblx0XHRcdFx0cDI9c2VsZi5nZXRQcm90ZWluKHByb3RlaW5JZDIpO1xuXHRcdFx0XG5cdFx0XHRpbnRJbmRleCA9IHNlbGYuaW50ZXJhY3Rpb25zQVtwcm90ZWluSWQxXS5pbmRleE9mKHAyKTtcblx0XHRcdGlmIChpbnRJbmRleCE9LTEpIHNlbGYuaW50ZXJhY3Rpb25zQVtwcm90ZWluSWQxXS5zcGxpY2UoaW50SW5kZXgtLSwgMSk7XG5cblx0XHRcdGludEluZGV4ID0gc2VsZi5pbnRlcmFjdGlvbnNBW3Byb3RlaW5JZDJdLmluZGV4T2YocDEpO1xuXHRcdFx0aWYgKGludEluZGV4IT0tMSkgc2VsZi5pbnRlcmFjdGlvbnNBW3Byb3RlaW5JZDJdLnNwbGljZShpbnRJbmRleC0tLCAxKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIHJlbW92ZXMgYSBwcm90ZWluIGZyb20gdGhlIGdyYXBoaWMgd2l0aCBhbGwgdGhlIGludGVyYWN0aW9ucyB1bmxlc3MgdGhlIGludGVyYWN0b3IgXG5cdFx0ICogaXMgYWxzbyBpbnRlcmFjdGluZyB3aXRoIGFub3RoZXIgcHJvdGVpbiB0aGF0IGlzIHZpc2libGUuIFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90ZWluSWQgVGhlIGlkIG9mIHRoZSBwcm90ZWluIHRvIGRlbGV0ZVxuXHRcdCAqICBcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5yZW1vdmVQcm90ZWluKCcyJyk7XG5cdFx0ICovXG5cdFx0cmVtb3ZlUHJvdGVpbjogZnVuY3Rpb24ocHJvdGVpbklkLCBleGNsdWRlbGlzdCl7XG5cdFx0XHR2YXIgc2VsZj10aGlzO1xuXHRcdFx0ZXhjbHVkZWxpc3QgPSAodHlwZW9mIGV4Y2x1ZGVsaXN0ID09IFwidW5kZWZpbmVkXCIpP1tdOmV4Y2x1ZGVsaXN0O1xuXG5cdFx0XHRpZiAodHlwZW9mIHNlbGYuaW50ZXJhY3Rpb25zQVtwcm90ZWluSWRdICE9IFwidW5kZWZpbmVkXCIpe1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7aTxzZWxmLmludGVyYWN0aW9uc0FbcHJvdGVpbklkXS5sZW5ndGg7aSsrKXtcblx0XHRcdFx0XHR2YXIgdGFyZ2V0aWQ9c2VsZi5pbnRlcmFjdGlvbnNBW3Byb3RlaW5JZF1baV0uaWQ7XG5cdFx0XHRcdFx0aWYgKGV4Y2x1ZGVsaXN0LmluZGV4T2YodGFyZ2V0aWQpID09IC0xKXtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlSW50ZXJhY3Rpb24ocHJvdGVpbklkLHRhcmdldGlkKTtcblx0XHRcdFx0XHRcdGktLTtcblx0XHRcdFx0XHRcdGlmIChzZWxmLmludGVyYWN0aW9uc0FbdGFyZ2V0aWRdLmxlbmd0aD09MClcblx0XHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVQcm90ZWluKHRhcmdldGlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNlbGYuaW50ZXJhY3Rpb25zQVtwcm90ZWluSWRdLmxlbmd0aD09MCl7XG5cdFx0XHRcdFx0ZGVsZXRlIHNlbGYuaW50ZXJhY3Rpb25zQVtwcm90ZWluSWRdO1xuXHRcdFx0XHRcdGZvcih2YXIgaT0wOyBpPHNlbGYucHJvdGVpbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmKHNlbGYucHJvdGVpbnNbaV0uaWQgPT0gcHJvdGVpbklkKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYucHJvdGVpbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVsZXRlIHNlbGYucHJvdGVpbnNBW3Byb3RlaW5JZF07XG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHNlbGYucHJvdGVpbnNBW3Byb3RlaW5JZF0uZml4ZWQ9ZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqIFJlc2V0cyB0aGUgZ3JhcGhpYyB0byB6ZXJvIHByb3RlaW5zIC0gemVybyBpbnRlcmFjdGlvbnNcblx0XHQgKiBcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5yZXNldEdyYXBoaWMoKTtcblx0XHQgKi9cblx0XHRyZXNldEdyYXBoaWM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgc2VsZj10aGlzO1xuXHRcdFx0c2VsZi5wcm90ZWlucz1bXTtcblx0XHRcdHNlbGYucHJvdGVpbnNBPXt9O1xuXHRcdFx0c2VsZi5pbnRlcmFjdGlvbnM9W107XG5cdFx0XHRzZWxmLnJlc3RhcnQoKTtcblx0XHR9LFxuXHRcdF9maWd1cmVzT3JkZXI6WzAsMywyLDUsNCwxXSxcblx0XHQvKipcblx0XHQgKiBSZXN0YXJ0IHRoZSBncmFwaGljIHRvIG1hdGVyaWFsaXplIHRoZSBjaGFuZ2VzIGRvbmUgb24gaXQoZS5nLiBhZGQvcmVtb3ZlIHByb3RlaW5zKVxuXHRcdCAqIEl0IGlzIGhlcmUgd2hlcmUgdGhlIFNWRyBlbGVtbnRzIGFyZSBjcmVhdGVkLlxuXHRcdCAqIFxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGluc3RhbmNlLnJlc3RhcnQoKTtcblx0XHQgKi9cblx0XHRyZXN0YXJ0OiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHRzZWxmLmZvcmNlXG5cdFx0XHQgICAgLm5vZGVzKHNlbGYucHJvdGVpbnMpXG5cdFx0XHQgICAgLmxpbmtzKHNlbGYuaW50ZXJhY3Rpb25zKVxuXHRcdFx0XHQuY2hhcmdlKC1zZWxmLm9wdC5yYWRpdXMqKDMrc2VsZi5wcm90ZWlucy5sZW5ndGgpKVxuXHRcdFx0XHQubGlua0Rpc3RhbmNlKHNlbGYub3B0LnJhZGl1cyooMytzZWxmLnByb3RlaW5zLmxlbmd0aCowLjA1KSkuc3RhcnQoKTtcblxuXHRcdFx0dmFyIGxpbmsgPXNlbGYudmlzLnNlbGVjdEFsbChcIi5ncmFwaE5ldHdvcmsgbGluZS5saW5rXCIpXG5cdFx0XHRcdC5kYXRhKHNlbGYuaW50ZXJhY3Rpb25zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnNvdXJjZS5pZCArIFwiLVwiICsgZC50YXJnZXQuaWQ7IH0pO1xuXHRcdFx0XG5cdFx0XHRsaW5rLmVudGVyKCkuaW5zZXJ0KFwibGluZVwiICwgXCIubm9kZVwiKSAvL2luc2VydCBiZWZvcmUgdGhlIC5ub2RlIHNvIGxpbmVzIHdvbid0IGhpZGUgdGhlIG5vZGVzXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJsaW5rXCIpXG5cdFx0XHRcdC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJsaW5rX1wiK2Quc291cmNlLmlkK1wiX1wiK2QudGFyZ2V0LmlkOyB9KVxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCl7IFxuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcignaW50ZXJhY3Rpb25Nb3VzZU92ZXInLCB7XG5cdFx0XHRcdFx0XHRpbnRlcmFjdGlvbjogZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCAgZnVuY3Rpb24oZCl7IFxuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcignaW50ZXJhY3Rpb25Nb3VzZU91dCcsIHtcblx0XHRcdFx0XHRcdGludGVyYWN0aW9uOiBkXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpeyBcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ2ludGVyYWN0aW9uQ2xpY2snLCB7XG5cdFx0XHRcdFx0XHRpbnRlcmFjdGlvbjogZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc291cmNlLng7IH0pXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2UueTsgfSlcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnRhcmdldC54OyB9KVxuXHRcdFx0XHQuYXR0cihcInkyXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudGFyZ2V0Lnk7IH0pO1xuXHRcdFx0XG5cdFx0XHRsaW5rLmV4aXQoKS5yZW1vdmUoKTtcblx0XG5cdFx0XHR2YXIgbm9kZXM9IHNlbGYudmlzLnNlbGVjdEFsbChcIi5ncmFwaE5ldHdvcmsgLm5vZGVcIilcblx0XHRcdFx0LmRhdGEoc2VsZi5wcm90ZWlucywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5pZDt9KTtcblx0XHRcdFxuXHRcdFx0dmFyIG5vZGU9bm9kZXNcblx0XHRcdFx0LmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwibm9kZVwiKVxuXHRcdFx0XHQuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwibm9kZV9cIitkLmlkOyB9KVxuXHRcdFx0XHQuYXR0cihcIm9yZ2FuaXNtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQub3JnYW5pc207IH0pXG5cdFx0XHRcdC5jYWxsKHNlbGYubm9kZV9kcmFnKTtcblx0XHRcdFxuXHRcdFx0bm9kZS5hcHBlbmQoXCJwYXRoXCIpXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJmaWd1cmVcIilcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGQzLnN2Zy5zeW1ib2woKVxuXHRcdFx0XHRcdFx0LnNpemUoZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKDIqc2VsZi5vcHQucmFkaXVzKSooMipzZWxmLm9wdC5yYWRpdXMpKmQuc2l6ZSpkLnNpemU7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LnR5cGUoZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZDMuc3ZnLnN5bWJvbFR5cGVzW3NlbGYuX2ZpZ3VyZXNPcmRlcltzZWxmLm9yZ2FuaXNtc1tkLm9yZ2FuaXNtXV1dO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQpXG5cdFx0XHRcdC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJmaWd1cmVfXCIrZC5pZDsgfSlcblx0XHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCl7IFxuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcigncHJvdGVpbkNsaWNrJywge1xuXHRcdFx0XHRcdFx0cHJvdGVpbjogZFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCl7IFxuXHRcdFx0XHRcdHNlbGYudHJpZ2dlcigncHJvdGVpbk1vdXNlT3ZlcicsIHtcblx0XHRcdFx0XHRcdHByb3RlaW46IGRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgIGZ1bmN0aW9uKGQpeyBcblx0XHRcdFx0XHRzZWxmLnRyaWdnZXIoJ3Byb3RlaW5Nb3VzZU91dCcsIHtcblx0XHRcdFx0XHRcdHByb3RlaW46IGRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LmF0dHIoXCJzdHJva2Utd2lkdGhcIixzZWxmLm9wdC5yYWRpdXMqMC4zKTtcblx0XHRcdFxuXG5cdFx0XHRub2RlXG5cdFx0XHRcdC5hcHBlbmQoXCJzdmc6dGV4dFwiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpXG5cdFx0XHRcdC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJsZWdlbmRfXCIrZC5pZDsgfSlcblx0XHRcdFx0LnRleHQoZnVuY3Rpb24oZCkgeyBcblx0XHRcdFx0XHRpZiAoZC50eXBlTGVnZW5kPT1cImlkXCIpIFxuXHRcdFx0XHRcdFx0cmV0dXJuIGQuaWQ7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoZC50eXBlTGVnZW5kLmluZGV4T2YoXCJmZWF0dXJlcy5cIik9PTApXG5cdFx0XHRcdFx0XHRyZXR1cm4gZC5mZWF0dXJlc1tkLnR5cGVMZWdlbmQuc3Vic3RyKDkpXTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXR1cm4gZFtkLnR5cGVMZWdlbmRdO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdC5hdHRyKFwidmlzaWJpbGl0eVwiLGZ1bmN0aW9uKGQpIHsgcmV0dXJuIChkLnNob3dMZWdlbmQpP1widmlzaWJsZVwiOlwiaGlkZGVuXCI7fSlcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIixmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChzZWxmLm9yZ2FuaXNtc1tkLm9yZ2FuaXNtXSA9PSAwKT9cInRyYW5zbGF0ZSgtXCIrKHNlbGYub3B0LnJhZGl1cyoxLjkpK1wiLFwiKyhzZWxmLm9wdC5yYWRpdXMqMC40KStcIilcIjpcInRyYW5zbGF0ZSgtXCIrKHNlbGYub3B0LnJhZGl1cyowLjkpK1wiLFwiKyhzZWxmLm9wdC5yYWRpdXMqMS4zKStcIilcIjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdG5vZGVzLmV4aXQoKS5yZW1vdmUoKTtcblx0XHRcdFxuXHRcdFx0c2VsZi5wZXJzcGVjdGl2ZS5zZWxlY3RBbGwoXCIubGVnZW5kQmxvY2tcIikucmVtb3ZlKCk7XG5cdFx0XHRpZiAodHlwZW9mIHNlbGYubGVnZW5kcyE9XCJ1bmRlZmluZWRcIiAmJiBzZWxmLmxlZ2VuZHMhPW51bGwpXG5cdFx0XHRcdHNlbGYuX3BhaW50TGVnZW5kcygpO1xuXHRcdH0sXG5cdFx0X3NvcnRMZWdlbmRzOmZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZWxmLmxlZ2VuZHMuc29ydChmdW5jdGlvbihhLGIpe1xuXHRcdFx0XHRpZiAoYVsxXT09YlsxXSl7XG5cdFx0XHRcdFx0aWYgKGFbMF09PVwibGFiZWxcIikgcmV0dXJuIC0xO1xuXHRcdFx0XHRcdGlmIChiWzBdPT1cImxhYmVsXCIpIHJldHVybiAxO1xuXHRcdFx0XHR9ZWxzZSBpZiAoYVsxXT5iWzFdKXtcblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdH1lbHNlXG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRfcGFpbnRMZWdlbmQ6ZnVuY3Rpb24obGVnZW5kLHR5cGUpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0bGVnZW5kLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdPT0gXCJsYWJlbFwiICYmIGRbMV09PXR5cGU7IH0pLmFwcGVuZChcInRleHRcIilcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIHNlbGYub3B0LndpZHRoIC0gNilcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIDcpXG5cdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxLjJlbVwiKVxuXHRcdFx0XHQudGV4dCh0eXBlK1wiOlwiKTtcblx0XHRcdGlmICh0eXBlLmluZGV4T2YoXCJSZXNpemUgQnlcIik9PTApe1xuXG5cdFx0XHRcdGxlZ2VuZC5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXSE9XCJsYWJlbFwiICYmIGRbMV09PXR5cGU7IH0pLmFwcGVuZChcInBhdGhcIilcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiZmlndXJlXCIpXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGg9MipzZWxmLm9wdC5yYWRpdXMqTWF0aC5zcXJ0KGRbMF1bMl0pO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJNMCwwTDAsMTBNMCw1TFwiK2grXCIsNU1cIitoK1wiLDBMXCIraCtcIiwxMCBcIjtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgXG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAgKHNlbGYub3B0LndpZHRoIC0gMTggLSAyKnNlbGYub3B0LnJhZGl1cypNYXRoLnNxcnQoZFswXVsyXSkpICsgXCIsXCIgKyAgMCArIFwiKVwiOyBcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKVxuXHRcdFx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBcImJsYWNrXCIpO1xuXHRcdFx0XHRsZWdlbmQuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF0hPVwibGFiZWxcIiAmJiBkWzFdPT0gdHlwZTsgfSkuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7IFxuXHRcdFx0XHRcdFx0cmV0dXJuIChzZWxmLm9wdC53aWR0aCAtIDIyIC0gNSpzZWxmLm9wdC5yYWRpdXMpOyBcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCA3KVxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG5cdFx0XHRcdFx0LnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gKGRbMF1bMV0qMS4wKS50b0ZpeGVkKDIpOyB9KTtcblx0XHRcdFx0XG5cdFx0XHR9ZWxzZXtcblx0XHRcdFx0bGVnZW5kLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdIT1cImxhYmVsXCIgJiYgZFsxXT09dHlwZTsgfSkuYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBzZWxmLm9wdC53aWR0aCAtIDE4KSBcblx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIDEzKVxuXHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIDEzKVxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCxpKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIGRbMl09PSBcInVuZGVmaW5lZFwiKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2VsZi5jb2xvcihpKTtcblx0XHRcdFx0XHRcdHJldHVybiBkWzJdO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRsZWdlbmQuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF0hPVwibGFiZWxcIiAmJiBkWzFdPT0gdHlwZTsgfSkuYXBwZW5kKFwidGV4dFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBzZWxmLm9wdC53aWR0aCAtIDI0KVxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCA3KVxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuMzVlbVwiKVxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG5cdFx0XHRcdFx0LnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZFswXTsgfSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfcGFpbnRMZWdlbmRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0dmFyIHc9MTggKyBzZWxmLmxvbmdlc3RMZWdlbmQqNyArIDEwO1xuXHRcdFx0dmFyIGxlZ2VuZEJsb2NrID0gc2VsZi5wZXJzcGVjdGl2ZS5pbnNlcnQoXCJnXCIsXCIubGlua1wiKVxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kQmxvY2tcIik7XG5cdFx0XHRzZWxmLl9zb3J0TGVnZW5kcygpO1xuXHRcdFx0bGVnZW5kQmxvY2suYXBwZW5kKFwicmVjdFwiKVxuXHRcdFx0XHQuYXR0cihcInhcIiwgc2VsZi5vcHQud2lkdGggLXcpXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIDYgKyBzZWxmLmxlZ2VuZHMubGVuZ3RoICoxNilcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3KVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIFwiI2RkZFwiKVxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIixcIjAuNFwiKTtcblxuXHRcdFx0dmFyIGxlZ2VuZCA9IGxlZ2VuZEJsb2NrLnNlbGVjdEFsbChcIi5tYWluTGVnZW5kXCIpIFxuXHRcdFx0XHQuZGF0YShzZWxmLmxlZ2VuZHMpXG5cdFx0XHRcdC5lbnRlcigpLmluc2VydChcImdcIilcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcIm1haW5MZWdlbmRcIilcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCwgaSkgeyBcblx0XHRcdFx0XHRyZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArICgzICsgaSAqIDE2KSArIFwiKVwiOyBcblx0XHRcdFx0fSk7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8IHNlbGYubGVnZW5kVHlwZXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHNlbGYuX3BhaW50TGVnZW5kKGxlZ2VuZCxzZWxmLmxlZ2VuZFR5cGVzW2ldKTtcblxuXHRcdH0sXG5cdFx0bG9uZ2VzdExlZ2VuZDo0LFxuXHRcdGxlZ2VuZFR5cGVzOltdLFxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYSBsZWdlbmQgdG8gdGhlIGdyYXBoaWNcblx0XHQgKiBcblx0XHQgKiBAZXhhbXBsZSBcdFx0XHRcdFx0XHRcblx0XHQgKiBpbnN0YW5jZS5hZGRMZWdlbmRzKFtcIkxlZ2VuZCByZWRcIl0sXCJDb2xvclwiLFwiI0ZGMDAwMFwiKTtcblx0XHQgKiBpbnN0YW5jZS5yZXN0YXJ0KCk7XG5cdFx0ICovXG5cdFx0YWRkTGVnZW5kczpmdW5jdGlvbihsZWdlbmRzLHR5cGUsY29sb3Ipe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKHNlbGYubGVnZW5kcz09bnVsbCkgc2VsZi5sZWdlbmRzPVtdLHNlbGYubGVnZW5kVHlwZXM9W107XG5cdFx0XHRcblx0XHRcdGlmIChsZWdlbmRzPT1udWxsKSB7XG5cdFx0XHRcdHNlbGYubGVnZW5kcyA9IG51bGw7XG5cdFx0XHRcdHNlbGYubGVnZW5kVHlwZXM9W107XG5cdFx0XHRcdHNlbGYubG9uZ2VzdExlZ2VuZD00O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZT09XCJSZXNpemUgQnlcIikgXG5cdFx0XHRcdHR5cGUgPSB0eXBlKyBcIiBcIitsZWdlbmRzWzBdO1xuXHRcdFx0aWYgKHNlbGYubGVnZW5kVHlwZXMuaW5kZXhPZih0eXBlKT09LTEpIHtcblx0XHRcdFx0c2VsZi5sZWdlbmRzLnB1c2goW1wibGFiZWxcIix0eXBlXSk7XG5cdFx0XHRcdHNlbGYubGVnZW5kVHlwZXMucHVzaCh0eXBlKTtcblx0XHRcdFx0aWYgKHR5cGUubGVuZ3RoPnNlbGYubG9uZ2VzdExlZ2VuZClcblx0XHRcdFx0XHRzZWxmLmxvbmdlc3RMZWdlbmQ9dHlwZS5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlLmluZGV4T2YoXCJSZXNpemUgQnlcIik9PTApeyAvL2lzIGEgc2l6ZSBsYWJlbFxuXHRcdFx0XHRzZWxmLmxlZ2VuZHMucHVzaChbbGVnZW5kcyx0eXBlXSk7XG5cdFx0XHR9IGVsc2UgLy9pcyBhIGNvbG9yIGxhYmVsXG5cdFx0XHRcdGZvciAodmFyIGk9MDtpPGxlZ2VuZHMubGVuZ3RoO2krKyl7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjb2xvcj09XCJ1bmRlZmluZWRcIilcblx0XHRcdFx0XHRcdHNlbGYubGVnZW5kcy5wdXNoKFtsZWdlbmRzW2ldLHR5cGVdKTtcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRzZWxmLmxlZ2VuZHMucHVzaChbbGVnZW5kc1tpXSx0eXBlLGNvbG9yXSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGxlZ2VuZHNbaV0ubGVuZ3RoPnNlbGYubG9uZ2VzdExlZ2VuZClcblx0XHRcdFx0XHRcdHNlbGYubG9uZ2VzdExlZ2VuZD1sZWdlbmRzW2ldLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogSGlkZXMgdGhlIGVsZW1lbnRzIG9uIHRoZSBncmFwaGljIHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yLiBcblx0XHQgKiBDaGVjayB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzL1wiPkNTUzMgc2VsZWN0b3JzIGRvY3VtZW50YXRpb248L2E+IHRvIGJ1aWxkIGEgc2VsZWN0b3Igc3RyaW5nIFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBhIHN0cmluZyB0byByZXByZXNlbnQgYSBzZXQgb2YgZWxlbWVudHMuIENoZWNrIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvXCI+Q1NTMyBzZWxlY3RvcnMgZG9jdW1lbnRhdGlvbjwvYT4gdG8gYnVpbGQgYSBzZWxlY3RvciBzdHJpbmdcblx0XHQgKiAgXG5cdFx0ICogQGV4YW1wbGUgXG5cdFx0ICogaW5zdGFuY2UuaGlkZShcIltpZCA9IG5vZGVfMTBdXCIpO1xuXHRcdCAqL1xuXHRcdGhpZGU6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoc2VsZWN0b3IpLmF0dHIoXCJ2aXNpYmlsaXR5XCIsICdoaWRkZW4nKTtcblx0XHRcdHNlbGYudmlzLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiIC5sZWdlbmRcIikuYXR0cihcInZpc2liaWxpdHlcIiwgJ2hpZGRlbicpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogU2hvd3MgdGhlIGVsZW1lbnRzIG9uIHRoZSBncmFwaGljIHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yLiBcblx0XHQgKiBDaGVjayB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzL1wiPkNTUzMgc2VsZWN0b3JzIGRvY3VtZW50YXRpb248L2E+IHRvIGJ1aWxkIGEgc2VsZWN0b3Igc3RyaW5nIFxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBhIHN0cmluZyB0byByZXByZXNlbnQgYSBzZXQgb2YgZWxlbWVudHMuIENoZWNrIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvXCI+Q1NTMyBzZWxlY3RvcnMgZG9jdW1lbnRhdGlvbjwvYT4gdG8gYnVpbGQgYSBzZWxlY3RvciBzdHJpbmdcblx0XHQgKiAgXG5cdFx0ICogQGV4YW1wbGUgXG5cdFx0ICogaW5zdGFuY2Uuc2hvdyhcIltpZCA9IG5vZGVfMTBdXCIpO1xuXHRcdCAqL1xuXHRcdHNob3c6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoc2VsZWN0b3IpLmF0dHIoXCJ2aXNpYmlsaXR5XCIsICd2aXNpYmxlJyk7XG5cdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoc2VsZWN0b3IpLnNlbGVjdEFsbChcIiAubGVnZW5kXCIpLmF0dHIoXCJ2aXNpYmlsaXR5XCIsZnVuY3Rpb24oZCkgeyByZXR1cm4gKGQuc2hvd0xlZ2VuZCk/XCJ2aXNpYmxlXCI6XCJoaWRkZW5cIjt9KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEhpZ2hsaWdodCB0aGUgZWxlbWVudHMgb24gdGhlIGdyYXBoaWMgdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IuIFxuXHRcdCAqIENoZWNrIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvXCI+Q1NTMyBzZWxlY3RvcnMgZG9jdW1lbnRhdGlvbjwvYT4gdG8gYnVpbGQgYSBzZWxlY3RvciBzdHJpbmcgXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIGEgc3RyaW5nIHRvIHJlcHJlc2VudCBhIHNldCBvZiBlbGVtZW50cy4gQ2hlY2sgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy9cIj5DU1MzIHNlbGVjdG9ycyBkb2N1bWVudGF0aW9uPC9hPiB0byBidWlsZCBhIHNlbGVjdG9yIHN0cmluZ1xuXHRcdCAqICBcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5oaWdobGlnaHQoXCJbaWQgKj0gbm9kZV8xXVwiKTtcblx0XHQgKi9cblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoc2VsZWN0b3IpLnN0eWxlKFwic3Ryb2tlXCIsICcjM2Q2Jyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGZpbGwncyBjb2xvciBvZiB0aGUgZWxlbWVudHMgb24gdGhlIGdyYXBoaWMgdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IuIFxuXHRcdCAqIENoZWNrIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvXCI+Q1NTMyBzZWxlY3RvcnMgZG9jdW1lbnRhdGlvbjwvYT4gdG8gYnVpbGQgYSBzZWxlY3RvciBzdHJpbmcgXG5cdFx0ICogXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIGEgc3RyaW5nIHRvIHJlcHJlc2VudCBhIHNldCBvZiBlbGVtZW50cy4gQ2hlY2sgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy9cIj5DU1MzIHNlbGVjdG9ycyBkb2N1bWVudGF0aW9uPC9hPiB0byBidWlsZCBhIHNlbGVjdG9yIHN0cmluZ1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciBhIGNvbG9yIGluIHdlYiBmb3JtYXQgZWcuICNGRjAwMDBcblx0XHQgKiAgXG5cdFx0ICogQGV4YW1wbGUgXG5cdFx0ICogaW5zdGFuY2Uuc2V0RmlsbENvbG9yKFwiLmZpZ3VyZVwiLFwiI0ZGMDAwMFwiKTtcblx0XHQgKi9cblx0XHRzZXRGaWxsQ29sb3I6IGZ1bmN0aW9uKHNlbGVjdG9yLGNvbG9yKXtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoc2VsZWN0b3IpLnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIHN0cm9rZSdzIGNvbG9yIG9mIHRoZSBlbGVtZW50cyBvbiB0aGUgZ3JhcGhpYyB0aGF0IG1hdGNoIHRoZSBzZWxlY3Rvci4gXG5cdFx0ICogQ2hlY2sgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy9cIj5DU1MzIHNlbGVjdG9ycyBkb2N1bWVudGF0aW9uPC9hPiB0byBidWlsZCBhIHNlbGVjdG9yIHN0cmluZyBcblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgYSBzdHJpbmcgdG8gcmVwcmVzZW50IGEgc2V0IG9mIGVsZW1lbnRzLiBDaGVjayB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzL1wiPkNTUzMgc2VsZWN0b3JzIGRvY3VtZW50YXRpb248L2E+IHRvIGJ1aWxkIGEgc2VsZWN0b3Igc3RyaW5nXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yIGEgY29sb3IgaW4gd2ViIGZvcm1hdCBlZy4gI0ZGMDAwMFxuXHRcdCAqICBcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5zZXRDb2xvcihcIltpZCAqPSBub2RlXzJdXCIsXCIjRkYwMDAwXCIpO1xuXHRcdCAqL1xuXHRcdHNldENvbG9yOiBmdW5jdGlvbihzZWxlY3Rvcixjb2xvcil7XG5cdFx0XHR2YXIgc2VsZj10aGlzO1xuXHRcdFx0c2VsZi52aXMuc2VsZWN0QWxsKHNlbGVjdG9yKS5zdHlsZShcInN0cm9rZVwiLCBjb2xvcik7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBJZiB0aGUgcHJvdGVpbiBoYXMgYSBmaXhlZCBwb3NpdGlvbiBpbiB0aGUgZ3JhcGhpYyBpdCBnZXRzIHJlbGVhc2VkLCBvciB2aWNldmVyc2Egb3RoZXIgd2lzZVxuXHRcdCAqIFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm90ZWluIHRoZSBpZCBvZiB0aGUgcHJvdGVpbiB0byBzd2FwIGlzIHBvc2l0aW9uIG9uIHRoZSBncmFwaGljXG5cdFx0ICogIFxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGluc3RhbmNlLnN3YXBGaXhlZChcIjNcIik7XG5cdFx0ICovXG5cdFx0c3dhcEZpeGVkOiBmdW5jdGlvbihwcm90ZWluKXtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHR2YXIgbm9kZXM9c2VsZi5mb3JjZS5ub2RlcygpO1xuXHRcdFx0bm9kZXMuZm9yRWFjaChmdW5jdGlvbihkLCBpKSB7XG5cdFx0XHQgIGlmIChkLmlkPT1wcm90ZWluKVxuXHRcdFx0XHQgIGQuZml4ZWQgPSAhZC5maXhlZDtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogU2hvd3MgdGhlIGxlZ2VuZChpZCkgb2YgdGhlIHByb3RlaW5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvdGVpbiB0aGUgaWQgb2YgdGhlIHByb3RlaW4gdG8gc3dhcCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbGVnZW5kXG5cdFx0ICogIFxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGluc3RhbmNlLnN3YXBTaG93TGVnZW5kKFwiI25vZGVfNSAubGVnZW5kXCIpO1xuXHRcdCAqL1xuXHRcdHNob3dMZWdlbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLHR5cGVMZWdlbmQpe1xuXHRcdFx0dmFyIHNlbGY9dGhpcztcblx0XHRcdHNlbGYudmlzLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKS5hdHRyKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIikudGV4dChmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGQudHlwZUxlZ2VuZD10eXBlTGVnZW5kO1xuXHRcdFx0XHRpZiAoZC50eXBlTGVnZW5kPT1cImlkXCIpIFxuXHRcdFx0XHRcdHJldHVybiBkLmlkO1xuXHRcdFx0XHRlbHNlIC8vaWYgKGQudHlwZUxlZ2VuZC5pbmRleE9mKFwiZmVhdHVyZXMuXCIpPT0wKVxuXHRcdFx0XHRcdHJldHVybiBkLmZlYXR1cmVzW2QudHlwZUxlZ2VuZF07XG4vL1x0XHRcdFx0ZWxzZVxuLy9cdFx0XHRcdFx0cmV0dXJuIGRbZC50eXBlTGVnZW5kXTtcblx0XHRcdFx0fSk7XG4vL1x0XHRcdHNlbGYucmVzdGFydCgpO1xuXHRcdH0sIFxuXHRcdC8qKlxuXHRcdCAqIFNjYWxlcyB0aGUgYXJlYSBvZiBhIHByb3RlaW5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvdGVpbiB0aGUgaWQgb2YgdGhlIHByb3RlaW4gdG8gc2NhbGVcblx0XHQgKiBAcGFyYW0ge2ludGVnZXJ9IHNjYWxlIHZhbHVlIHRvIHNjYWxlIGEgbm9kZVxuXHRcdCAqICBcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5zZXRTaXplU2NhbGUoXCIjZmlndXJlXzFcIiw0KTtcblx0XHQgKi9cblx0XHRzZXRTaXplU2NhbGU6IGZ1bmN0aW9uKHNlbGVjdG9yLHNjYWxlKXtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoc2VsZWN0b3IpLmF0dHIoXCJkXCIsIGQzLnN2Zy5zeW1ib2woKVxuXHRcdFx0XHRcdC5zaXplKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRcdGQuc2l6ZT1zY2FsZTtcblx0XHRcdFx0XHRcdHJldHVybiAoMipzZWxmLm9wdC5yYWRpdXMpKigyKnNlbGYub3B0LnJhZGl1cykqc2NhbGU7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQudHlwZShmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZDMuc3ZnLnN5bWJvbFR5cGVzW3NlbGYuX2ZpZ3VyZXNPcmRlcltzZWxmLm9yZ2FuaXNtc1tkLm9yZ2FuaXNtXV1dO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdCk7XG5cdFx0fSwgXG5cdFx0LyoqXG5cdFx0ICogU2NhbGVzIHRoZSBzaXplIG9mIHRoZSBwcm90ZWlucyB3aGljaCB2YWx1ZSBoYXMgYmVlbiBtb2RpZnkgYnkgb3RoZXIgbWVhbnNcblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgYSBDU1MzIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgbm9kZXMgdG8gcmVzaXplXG5cdFx0ICogIFxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGZvciAodmFyIGk9MDtpPGluc3RhbmNlLnByb3RlaW5zLmxlbmd0aDtpKyspXG5cdFx0ICogXHRpbnN0YW5jZS5wcm90ZWluc1tpXS5zaXplPTEraSU0O1xuXHRcdCAqIGluc3RhbmNlLnJlZnJlc2hTaXplU2NhbGUoXCIuZmlndXJlXCIpO1xuXHRcdCAqL1xuXHRcdHJlZnJlc2hTaXplU2NhbGU6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcblx0XHRcdHZhciBzZWxmPXRoaXM7XG5cdFx0XHRzZWxmLnZpcy5zZWxlY3RBbGwoc2VsZWN0b3IpLmF0dHIoXCJkXCIsIGQzLnN2Zy5zeW1ib2woKVxuXHRcdFx0XHRcdC5zaXplKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAoMipzZWxmLm9wdC5yYWRpdXMpKigyKnNlbGYub3B0LnJhZGl1cykqZC5zaXplO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnR5cGUoZnVuY3Rpb24oZCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGQzLnN2Zy5zeW1ib2xUeXBlc1tzZWxmLl9maWd1cmVzT3JkZXJbc2VsZi5vcmdhbmlzbXNbZC5vcmdhbmlzbV1dXTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQpO1xuXHRcdH0sIFxuXHRcdC8qKlxuXHRcdCAqIEhpZGUgdGhlIGxlZ2VuZChpZCkgb2YgdGhlIHByb3RlaW5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgYSBDU1MzIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgbm9kZXMgdG8gaGlkZSBpdHMgbGVnZW5kXG5cdFx0ICogIFxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGluc3RhbmNlLmhpZGVMZWdlbmQoXCIjbm9kZV81IC5sZWdlbmRcIik7XG5cdFx0ICovXG5cdFx0aGlkZUxlZ2VuZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuXHRcdFx0dmFyIHNlbGY9dGhpcztcblx0XHRcdHNlbGYudmlzLnNlbGVjdEFsbChzZWxlY3Rvcikuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKS5hdHRyKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFNob3dzL0hpZGUgdGhlIGxlZ2VuZChpZCkgb2YgdGhlIHByb3RlaW5cblx0XHQgKiBcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvdGVpbiB0aGUgaWQgb2YgdGhlIHByb3RlaW4gdG8gc3dhcCB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbGVnZW5kXG5cdFx0ICogIFxuXHRcdCAqIEBleGFtcGxlIFxuXHRcdCAqIGluc3RhbmNlLnN3YXBTaG93TGVnZW5kKFwiI25vZGVfNSAubGVnZW5kXCIpO1xuXHRcdCAqL1xuXHRcdHN3YXBTaG93TGVnZW5kOiBmdW5jdGlvbihzZWxlY3Rvcil7XG5cdFx0XHR2YXIgc2VsZj10aGlzO1xuXHRcdFx0c2VsZi52aXMuc2VsZWN0QWxsKHNlbGVjdG9yKS5hdHRyKFwidmlzaWJpbGl0eVwiLCBmdW5jdGlvbihkKSB7XG5cdFx0XHRcdGQuc2hvd0xlZ2VuZCA9ICFkLnNob3dMZWdlbmQ7XG5cdFx0XHRcdHJldHVybiAoZC5zaG93TGVnZW5kKT9cInZpc2libGVcIjpcImhpZGRlblwiO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBnZXRzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgbGlzdCBvZiBwcm90ZWlucyB3aGljaCBwb2l0aW9uIGhhcyBiZWVuIGZpeGVkIGludG8gdGhlIGdyYXBoaWNcblx0XHQgKiBcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBhbGVydChpbnN0YW5jZS5nZXRGaXhlZFByb3RlaW5zKCkpO1xuXHRcdCAqL1xuXHRcdGdldEZpeGVkUHJvdGVpbnM6ZnVuY3Rpb24oKXtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdHZhciBwcm90cz1bXTtcblx0XHRcdGZvciAodmFyIHByb3QgaW4gc2VsZi5wcm90ZWluc0Epe1xuXHRcdFx0XHRpZiAoc2VsZi5wcm90ZWluc0FbcHJvdF0uZml4ZWQpe1xuXHRcdFx0XHRcdHByb3RzLnB1c2goe1xuXHRcdFx0XHRcdFx0XCJwcm90ZWluXCI6cHJvdCxcblx0XHRcdFx0XHRcdFwieFwiOnNlbGYucHJvdGVpbnNBW3Byb3RdLngsXG5cdFx0XHRcdFx0XHRcInlcIjpzZWxmLnByb3RlaW5zQVtwcm90XS55IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvdHM7XG5cdFx0fSxcblx0XHRmaXhlZFByb3RlaW5zOnt9LFxuXHRcdC8qKlxuXHRcdCAqIGZpeCBpbnRvIHRoZSBncmFwaGljIGEgcHJvdGVpbiBpbiBhIGRldGVybWluZWQgcG9zaXRpb25cblx0XHQgKiBcblx0XHQgKiBAZXhhbXBsZSBcblx0XHQgKiBpbnN0YW5jZS5maXhQcm90ZWluQXQoXCI3XCIsMTAsMTApO1xuXHRcdCAqIGluc3RhbmNlLnJlc3RhcnQoKTtcblx0XHQgKi9cblx0XHRmaXhQcm90ZWluQXQ6ZnVuY3Rpb24ocHJvdGVpbix4LHkpe1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0aWYgKHR5cGVvZiBzZWxmLnByb3RlaW5zQVtwcm90ZWluXSA9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRcdHNlbGYuZml4ZWRQcm90ZWluc1twcm90ZWluXT1beCx5XTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5wcm90ZWluc0FbcHJvdGVpbl0ueD14O1xuXHRcdFx0c2VsZi5wcm90ZWluc0FbcHJvdGVpbl0ueT15O1xuXHRcdFx0c2VsZi5wcm90ZWluc0FbcHJvdGVpbl0ucHg9eDtcblx0XHRcdHNlbGYucHJvdGVpbnNBW3Byb3RlaW5dLnB5PXk7XG5cdFx0XHRzZWxmLnByb3RlaW5zQVtwcm90ZWluXS5maXhlZD10cnVlO1xuXHRcdC8vXHRzZWxmLnRpY2soKTtcblx0XHR9LFxuXG5cdFx0Y29sb3JzOiBbIFwiIzFmNzdiNFwiLCBcIiNhZWM3ZThcIiwgXCIjZmY3ZjBlXCIsIFwiI2ZmYmI3OFwiLCBcIiMyY2EwMmNcIiwgXCIjOThkZjhhXCIsIFwiI2Q2MjcyOFwiLCBcIiNmZjk4OTZcIiwgXCIjOTQ2N2JkXCIsIFwiI2M1YjBkNVwiLCBcblx0XHQgICAgICAgICAgXCIjOGM1NjRiXCIsIFwiI2M0OWM5NFwiLCBcIiNlMzc3YzJcIiwgXCIjZjdiNmQyXCIsIFwiIzdmN2Y3ZlwiLCBcIiNjN2M3YzdcIiwgXCIjYmNiZDIyXCIsIFwiI2RiZGI4ZFwiLCBcIiMxN2JlY2ZcIiwgXCIjOWVkYWU1XCIsXG5cdFx0ICAgICAgICAgICcjMzM5OUZGJywgJyM5OUZGNjYnLCAnIzY2RkY5OScsICcjQ0NGRjAwJywgJyM2Njk5Q0MnLCAnIzk5Q0MwMCcsICcjOTlGRkNDJywgJyM5OTMzOTknLCAnIzMzRkZGRicsICcjMzNDQzMzJywgXG5cdFx0ICAgICAgICAgJyM2NkNDRkYnLCAnIzAwOTk5OScsICcjMDBGRkZGJywgJyNDQzY2Q0MnLCAnI0ZGOTk2NicsICcjQ0MzMzAwJywgJyMwMDk5NjYnLCAnIzY2MDAwMCcsICcjOTlGRjMzJywgJyMzMzAwNjYnLCBcblx0XHQgICAgICAgICAnI0ZGRkYwMCcsICcjMDA5OUZGJywgJyNGRjY2OTknLCAnIzMzRkYwMCcsICcjRkZGRkNDJywgJyM5OTAwMDAnLCAnIzk5Q0MzMycsICcjMDAzM0NDJywgJyMwMDY2OTknLCAnIzY2OTlGRicsIFxuXHRcdCAgICAgICAgICcjRkZDQzAwJywgJyMzMzAwOTknLCAnIzk5OTk5OScsICcjNjY2NjMzJywgJyNGRkNDOTknLCAnIzAwQ0NDQycsICcjMDA2NjMzJywgJyNDQ0NDOTknLCAnIzMzMDBGRicsICcjMzNDQzY2JywgXG5cdFx0ICAgICAgICAgJyMzMzk5OTknLCAnIzY2NjZGRicsICcjMzNGRjY2JywgJyM5OTAwMzMnLCAnIzMzQ0M5OScsICcjOTkzMzAwJywgJyMwMEZGMDAnLCAnIzY2NjY5OScsICcjMDBDQzAwJywgJyNGRjY2Q0MnLCBcblx0XHQgICAgICAgICAnIzAwRkZDQycsICcjRkY5OTk5JywgJyM2NkZGMDAnLCAnIzAwMzM2NicsICcjQ0NGRjMzJywgJyM2NjAwNjYnLCAnIzY2MzNDQycsICcjRkYzMzY2JywgJyM5OUZGMDAnLCAnI0ZGMzNDQycsIFxuXHRcdCAgICAgICAgICcjQ0NGRkNDJywgJyM5OUNDQ0MnLCAnIzMzMDBDQycsICcjMDA2NkZGJywgJyM2NkNDMzMnLCAnIzMzNjZDQycsICcjQ0NDQ0NDJywgJyNGRjAwMDAnLCAnIzY2NjZDQycsICcjMzM2Njk5JywgXG5cdFx0ICAgICAgICAgJyM5OTk5NjYnLCAnI0ZGRkY5OScsICcjNjZDQzk5JywgJyNGRjAwMzMnLCAnIzk5OTkzMycsICcjQ0M5OUZGJywgJyNGRjAwOTknLCAnIzY2MDBDQycsICcjQ0M5OTY2JywgJyMwMENDNjYnLCBcblx0XHQgICAgICAgICAnIzMzQ0MwMCcsICcjNjY2NjY2JywgJyMzM0NDQ0MnLCAnI0ZGMDA2NicsICcjMDBDQzMzJywgJyNGRkNDNjYnLCAnI0ZGNjYwMCcsICcjOTk5OUZGJywgJyNDQzY2RkYnLCAnIzk5MzNGRicsIFxuXHRcdCAgICAgICAgICcjRkYwMENDJywgJyNDQzMzOTknLCAnI0NDNjYzMycsICcjMzNGRkNDJywgJyNGRjMzRkYnLCAnIzAwOTkwMCcsICcjNjYwMDk5JywgJyM2Njk5OTknLCAnI0NDMzM2NicsICcjMDA5OUNDJywgXG5cdFx0ICAgICAgICAgJyM5OTAwRkYnLCAnIzY2OTkzMycsICcjRkZGRkZGJywgJyNDQ0NDRkYnLCAnIzY2Q0NDQycsICcjNjY5OTY2JywgJyMwMDY2Q0MnLCAnI0NDOTkwMCcsICcjNjYzMzAwJywgJyMzM0ZGOTknLCBcblx0XHQgICAgICAgICAnIzk5NjY2NicsICcjMzM5OUNDJywgJyM5OUZGOTknLCAnIzY2Q0M2NicsICcjQ0MwMDY2JywgJyNDQ0ZGNjYnLCAnIzY2MzM2NicsICcjOTlDQzY2JywgJyMwMDAwMzMnLCAnIzAwMzMzMycsIFxuXHRcdCAgICAgICAgICcjRkY2NjY2JywgJyMwMDk5MzMnLCAnI0ZGRkY2NicsICcjOTk2Njk5JywgJyNGRkNDQ0MnLCAnIzAwQ0NGRicsICcjMzM5OTY2JywgJyMzMzY2RkYnLCAnIzAwQ0M5OScsICcjMzM2NjMzJywgXG5cdFx0ICAgICAgICAgJyNGRjk5RkYnLCAnIzY2MzMzMycsICcjQ0NGRjk5JywgJyNDQzk5Q0MnLCAnIzMzOTkzMycsICcjMzNDQ0ZGJywgJyMzMzMzNjYnLCAnIzAwNjY2NicsICcjQ0M2NjAwJywgJyMzMzMzMDAnLCBcblx0XHQgICAgICAgICAnI0ZGQ0MzMycsICcjOTk2NkNDJywgJyMwMDMzMDAnLCAnIzk5NjZGRicsICcjOTk2NjAwJywgJyNDQzk5MzMnLCAnIzk5OTlDQycsICcjRkY5OTMzJywgJyMwMDY2MDAnLCAnIzY2MzNGRicsIFxuXHRcdCAgICAgICAgICcjQ0M2Njk5JywgJyNGRjMzOTknLCAnIzk5MzMzMycsICcjQ0NGRkZGJywgJyMzMzAwMzMnLCAnI0ZGQ0NGRicsICcjRkZGRjMzJywgJyM5OTAwNjYnLCAnI0NDQ0M2NicsICcjQ0MwMDk5JywgXG5cdFx0ICAgICAgICAgJyNDQ0NDMDAnLCAnIzMzOTkwMCcsICcjNjYwMDMzJywgJyNGRjAwRkYnLCAnIzMzMzMzMycsICcjOTlDQzk5JywgJyM2NkZGQ0MnLCAnIzAwMzM5OScsICcjOTk5OTAwJywgJyM5OUZGRkYnLCBcblx0XHQgICAgICAgICAnIzk5MDA5OScsICcjMzMzM0ZGJywgJyNDQzMzQ0MnLCAnI0NDNjY2NicsICcjMzMzM0NDJywgJyM5OTAwQ0MnLCAnIzk5MzNDQycsICcjQ0MwMDMzJywgJyNDQzAwRkYnLCAnI0ZGOTlDQycsIFxuXHRcdCAgICAgICAgICcjRkY2NkZGJywgJyM2NkZGRkYnLCAnIzY2MDBGRicsICcjNjZGRjY2JywgJyM5OTY2MzMnLCAnIzY2OTkwMCcsICcjMDBGRjk5JywgJyNDQzk5OTknLCAnIzk5MzM2NicsICcjQ0MzM0ZGJywgXG5cdFx0ICAgICAgICAgJyMzMzY2NjYnLCAnIzAwMzNGRicsICcjMzM2NjAwJywgJyNDQzAwMDAnLCAnI0ZGOTkwMCcsICcjMzNGRjMzJywgJyMwMDAwMDAnLCAnIzk5Q0NGRicsICcjMDAwMDY2JywgJyMwMDAwQ0MnLCBcblx0XHQgICAgICAgICAnIzAwMDA5OScsICcjMDBGRjMzJywgJyM2NjY2MDAnLCAnIzY2RkYzMycsICcjQ0NDQzMzJywgJyM2NkNDMDAnLCAnI0ZGMzMzMycsICcjQ0MzMzMzJywgJyM2NjMzOTknLCAnIzMzMzM5OScsIFxuXHRcdCAgICAgICAgICcjRkYzMzAwJywgJyMwMDAwRkYnLCAnI0NDMDBDQycsICcjMDBGRjY2JywgJyMzMzAwMDAnLCAnI0ZGNjYzMyddXG5cblx0fSk7XG5cblxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJ2Jpb2pzLWV2ZW50cycpO1xuRXZlbnRzLm1peGluKEludGVyYWN0aW9uc0QzLnByb3RvdHlwZSk7XG4iLCJ2YXIgZXZlbnRzID0gcmVxdWlyZShcImJhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lXCIpO1xuXG5ldmVudHMub25BbGwgPSBmdW5jdGlvbihjYWxsYmFjayxjb250ZXh0KXtcbiAgdGhpcy5vbihcImFsbFwiLCBjYWxsYmFjayxjb250ZXh0KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBNaXhpbiB1dGlsaXR5XG5ldmVudHMub2xkTWl4aW4gPSBldmVudHMubWl4aW47XG5ldmVudHMubWl4aW4gPSBmdW5jdGlvbihwcm90bykge1xuICBldmVudHMub2xkTWl4aW4ocHJvdG8pO1xuICAvLyBhZGQgY3VzdG9tIG9uQWxsXG4gIHZhciBleHBvcnRzID0gWydvbkFsbCddO1xuICBmb3IodmFyIGk9MDsgaSA8IGV4cG9ydHMubGVuZ3RoO2krKyl7XG4gICAgdmFyIG5hbWUgPSBleHBvcnRzW2ldO1xuICAgIHByb3RvW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgfVxuICByZXR1cm4gcHJvdG87XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZW50cztcbiIsIi8qKlxuICogU3RhbmRhbG9uZSBleHRyYWN0aW9uIG9mIEJhY2tib25lLkV2ZW50cywgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jeSByZXF1aXJlZC5cbiAqIERlZ3JhZGVzIG5pY2VseSB3aGVuIEJhY2tvbmUvdW5kZXJzY29yZSBhcmUgYWxyZWFkeSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnRcbiAqIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCBkb2NzIHN1Z2dlc3QgdG8gdXNlIHVuZGVyc2NvcmUncyBgXy5leHRlbmQoKWAgbWV0aG9kIHRvIGFkZCBFdmVudHNcbiAqIHN1cHBvcnQgdG8gc29tZSBnaXZlbiBvYmplY3QuIEEgYG1peGluKClgIG1ldGhvZCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRXZlbnRzXG4gKiBwcm90b3R5cGUgdG8gYXZvaWQgdXNpbmcgdW5kZXJzY29yZSBmb3IgdGhhdCBzb2xlIHB1cnBvc2U6XG4gKlxuICogICAgIHZhciBteUV2ZW50RW1pdHRlciA9IEJhY2tib25lRXZlbnRzLm1peGluKHt9KTtcbiAqXG4gKiBPciBmb3IgYSBmdW5jdGlvbiBjb25zdHJ1Y3RvcjpcbiAqXG4gKiAgICAgZnVuY3Rpb24gTXlDb25zdHJ1Y3Rvcigpe31cbiAqICAgICBNeUNvbnN0cnVjdG9yLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbigpe31cbiAqICAgICBCYWNrYm9uZUV2ZW50cy5taXhpbihNeUNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gKlxuICogKGMpIDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogKGMpIDIwMTMgTmljb2xhcyBQZXJyaWF1bHRcbiAqL1xuLyogZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgZGVmaW5lLCBtb2R1bGUgKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgYnJlYWtlciA9IHt9LFxuICAgICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICBpZENvdW50ZXIgPSAwO1xuXG4gIC8vIFJldHVybnMgYSBwYXJ0aWFsIGltcGxlbWVudGF0aW9uIG1hdGNoaW5nIHRoZSBtaW5pbWFsIEFQSSBzdWJzZXQgcmVxdWlyZWRcbiAgLy8gYnkgQmFja2JvbmUuRXZlbnRzXG4gIGZ1bmN0aW9uIG1pbmlzY29yZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleXMoKSBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXksIGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9LFxuXG4gICAgICB1bmlxdWVJZDogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICAgICAgfSxcblxuICAgICAgaGFzOiBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgICB9LFxuXG4gICAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25jZTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfID0gbWluaXNjb3JlKCksIEV2ZW50cztcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGRlbGV0ZUxpc3RlbmVyID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgaWYgKG9iaikgKGxpc3RlbmVycyA9IHt9KVtvYmouX2xpc3RlbmVySWRdID0gb2JqO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpZF0ub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RlbmVyKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEltcGxlbWVudCBmYW5jeSBmZWF0dXJlcyBvZiB0aGUgRXZlbnRzIEFQSSBzdWNoIGFzIG11bHRpcGxlIGV2ZW50XG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgdmFyIGV2ZW50c0FwaSA9IGZ1bmN0aW9uKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuZXJJZCB8fCAob2JqLl9saXN0ZW5lcklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmVyc1tpZF0gPSBvYmo7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBvYmpbaW1wbGVtZW50YXRpb25dKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBNaXhpbiB1dGlsaXR5XG4gIEV2ZW50cy5taXhpbiA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ3RyaWdnZXInLCAnc3RvcExpc3RlbmluZycsICdsaXN0ZW5UbycsXG4gICAgICAgICAgICAgICAgICAgJ2xpc3RlblRvT25jZScsICdiaW5kJywgJ3VuYmluZCddO1xuICAgIF8uZWFjaChleHBvcnRzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3RvO1xuICB9O1xuXG4gIC8vIEV4cG9ydCBFdmVudHMgYXMgQmFja2JvbmVFdmVudHMgZGVwZW5kaW5nIG9uIGN1cnJlbnQgY29udGV4dFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEV2ZW50cztcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50cztcbiAgICB9XG4gICAgZXhwb3J0cy5CYWNrYm9uZUV2ZW50cyA9IEV2ZW50cztcbiAgfSBlbHNlIHtcbiAgICByb290LkJhY2tib25lRXZlbnRzID0gRXZlbnRzO1xuICB9XG59KSh0aGlzKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZScpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqIEBwcmVzZXJ2ZSBodHRwOi8vZ2l0aHViLmNvbS9lYXNld2F5L2pzLWNsYXNzICovXG5cbi8vIENsYXNzIERlZmluaXRpb24gdXNpbmcgRUNNQTUgcHJvdG90eXBlIGNoYWluXG5cbmZ1bmN0aW9uIGluaGVyaXQoZGVzdCwgc3JjLCBub1BhcmVudCkge1xuICAgIHdoaWxlIChzcmMgJiYgc3JjICE9PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgIT0gJy5jbGFzcycgJiYgIWRlc3QuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3JjLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgbmFtZSwgZGVzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9QYXJlbnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNyYyA9IHNyYy5fX3Byb3RvX187XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuXG52YXIgQ2xhc3MgPSBmdW5jdGlvbiAoYmFzZSwgcHJvdG8sIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mKGJhc2UpICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucyA9IHByb3RvO1xuICAgICAgICBwcm90byA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSBPYmplY3Q7XG4gICAgfVxuICAgIGlmICghcHJvdG8pIHtcbiAgICAgICAgcHJvdG8gPSB7fTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1ldGEgPSB7XG4gICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgaW1wbGVtZW50czogW11cbiAgICB9XG4gICAgdmFyIGNsYXNzUHJvdG8gPSBDbGFzcy5jbG9uZShwcm90byk7XG4gICAgaWYgKG9wdGlvbnMuaW1wbGVtZW50cykge1xuICAgICAgICAoQXJyYXkuaXNBcnJheShvcHRpb25zLmltcGxlbWVudHMpID8gb3B0aW9ucy5pbXBsZW1lbnRzIDogW29wdGlvbnMuaW1wbGVtZW50c10pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaW1wbGVtZW50ZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihpbXBsZW1lbnRlZFR5cGUpID09ICdmdW5jdGlvbicgJiYgaW1wbGVtZW50ZWRUeXBlLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhLmltcGxlbWVudHMucHVzaChpbXBsZW1lbnRlZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBDbGFzcy5leHRlbmQoY2xhc3NQcm90bywgaW1wbGVtZW50ZWRUeXBlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsYXNzUHJvdG8uX19wcm90b19fID0gYmFzZS5wcm90b3R5cGU7XG4gICAgdmFyIHRoZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuY29uc3RydWN0b3IpID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgbWV0YS50eXBlID0gdGhlQ2xhc3M7XG4gICAgdGhlQ2xhc3MucHJvdG90eXBlID0gY2xhc3NQcm90bztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhlQ2xhc3MsICcuY2xhc3MubWV0YScsIHsgdmFsdWU6IG1ldGEsIGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzUHJvdG8sICcuY2xhc3MnLCB7IHZhbHVlOiB0aGVDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBpZiAob3B0aW9ucy5zdGF0aWNzKSB7XG4gICAgICAgIENsYXNzLmV4dGVuZCh0aGVDbGFzcywgb3B0aW9ucy5zdGF0aWNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoZUNsYXNzO1xufTtcblxuQ2xhc3MuZXh0ZW5kID0gaW5oZXJpdDtcblxuQ2xhc3MuY2xvbmUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIGluaGVyaXQoe30sIG9iamVjdCk7XG59O1xuXG5mdW5jdGlvbiBmaW5kVHlwZShtZXRhLCB0eXBlKSB7XG4gICAgd2hpbGUgKG1ldGEpIHtcbiAgICAgICAgaWYgKG1ldGEudHlwZS5wcm90b3R5cGUgPT09IHR5cGUucHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIGluIG1ldGEuaW1wbGVtZW50cykge1xuICAgICAgICAgICAgdmFyIGltcGxUeXBlID0gbWV0YS5pbXBsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIGltcGxNZXRhID0gaW1wbFR5cGVbJy5jbGFzcy5tZXRhJ107XG4gICAgICAgICAgICBpZiAoaW1wbE1ldGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZFR5cGUoaW1wbE1ldGEsIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvdG8gPSBpbXBsVHlwZS5wcm90b3R5cGU7IHByb3RvOyBwcm90byA9IHByb3RvLl9fcHJvdG9fXykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG8gPT09IHR5cGUucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhID0gbWV0YS5iYXNlID8gbWV0YS5iYXNlWycuY2xhc3MubWV0YSddIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBDaGVja2VyID0gQ2xhc3Moe1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIH0sXG4gICAgXG4gICAgdHlwZU9mOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5vYmplY3QgaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0YSA9IENsYXNzLnR5cGVJbmZvKHRoaXMub2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIG1ldGEgJiYgZmluZFR5cGUobWV0YSwgdHlwZSk7XG4gICAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbkNoZWNrZXIucHJvdG90eXBlLmEgPSBDaGVja2VyLnByb3RvdHlwZS50eXBlT2Y7XG5DaGVja2VyLnByb3RvdHlwZS5hbiA9IENoZWNrZXIucHJvdG90eXBlLnR5cGVPZjtcblxuQ2xhc3MuaXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBDaGVja2VyKG9iamVjdCk7XG59O1xuXG5DbGFzcy50eXBlSW5mbyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgdGhlQ2xhc3MgPSBvYmplY3QuX19wcm90b19fWycuY2xhc3MnXTtcbiAgICByZXR1cm4gdGhlQ2xhc3MgPyB0aGVDbGFzc1snLmNsYXNzLm1ldGEnXSA6IHVuZGVmaW5lZDtcbn07XG5cbkNsYXNzLlZFUlNJT04gPSBbMCwgMCwgMl07XG5cbmlmIChtb2R1bGUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsYXNzO1xufSBlbHNlIHtcbiAgICBnbG9iYWwuQ2xhc3MgPSBDbGFzczsgICAvLyBmb3IgYnJvd3NlclxufVxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uKCkgeyBcblxuICB2YXIgc2xpY2UgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICAgIGVhY2ggICAgPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcblxuICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IG9iaiArICcgaXMgbm90IGFuIG9iamVjdCcgO1xuXG4gICAgdmFyIHNvdXJjZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IFxuXG4gICAgZWFjaC5jYWxsKHNvdXJjZXMsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYoc291cmNlKSB7XG4gICAgICAgIGZvcih2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZih0eXBlb2Ygc291cmNlW3Byb3BdID09PSAnb2JqZWN0JyAmJiBvYmpbcHJvcF0pIHtcbiAgICAgICAgICAgIGV4dGVuZC5jYWxsKG9iaiwgb2JqW3Byb3BdLCBzb3VyY2VbcHJvcF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHRoaXMuZXh0ZW5kID0gZXh0ZW5kO1xuXG59KS5jYWxsKHRoaXMpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL0Jpb2pzLkludGVyYWN0aW9uc0QzXCIpO1xuIl19
